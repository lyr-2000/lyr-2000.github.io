<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>排序算法 - Even - A super concise theme for Hugo</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="LYR" /><meta name="description" content="插入排序 直接插入排序 插入排序是最简单的，我们不断比较插入数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 插入排序 // 时间复杂度 n^2 // 因为我们这里" /><meta name="keywords" content="LYR的文档站, LYR的个人博客, even" />






<meta name="generator" content="Hugo 0.87.0 with theme even" />


<link rel="canonical" href="http://doc.lyr-2000.xyz/post/06.%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01.%E7%AE%97%E6%B3%95/01.%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.b5a744db6de49a86cadafb3b70f555ab443f83c307a483402259e94726b045ff.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="排序算法" />
<meta property="og:description" content="插入排序 直接插入排序 插入排序是最简单的，我们不断比较插入数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 插入排序 // 时间复杂度 n^2 // 因为我们这里" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://doc.lyr-2000.xyz/post/06.%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01.%E7%AE%97%E6%B3%95/01.%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-03-21T19:07:54+00:00" />
<meta property="article:modified_time" content="2021-03-21T19:07:54+00:00" />

<meta itemprop="name" content="排序算法">
<meta itemprop="description" content="插入排序 直接插入排序 插入排序是最简单的，我们不断比较插入数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 插入排序 // 时间复杂度 n^2 // 因为我们这里"><meta itemprop="datePublished" content="2021-03-21T19:07:54+00:00" />
<meta itemprop="dateModified" content="2021-03-21T19:07:54+00:00" />
<meta itemprop="wordCount" content="6633">
<meta itemprop="keywords" content="," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="排序算法"/>
<meta name="twitter:description" content="插入排序 直接插入排序 插入排序是最简单的，我们不断比较插入数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 插入排序 // 时间复杂度 n^2 // 因为我们这里"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">LYR的文档站</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">首页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档页</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">LYR的文档站</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">首页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">排序算法</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-03-21 </span>
        <div class="post-category">
            <a href="/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"> 算法和数据结构 </a>
            <a href="/categories/%E7%AE%97%E6%B3%95/"> 算法 </a>
            </div>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#插入排序">插入排序</a>
          <ul>
            <li><a href="#直接插入排序">直接插入排序</a></li>
            <li><a href="#折半插入排序">折半插入排序</a></li>
            <li><a href="#希尔排序">希尔排序</a></li>
          </ul>
        </li>
        <li><a href="#交换排序">交换排序</a>
          <ul>
            <li><a href="#冒泡排序">冒泡排序</a></li>
            <li><a href="#快速排序">快速排序</a></li>
          </ul>
        </li>
        <li><a href="#选择排序">选择排序</a>
          <ul>
            <li><a href="#简单选择排序">简单选择排序</a></li>
            <li><a href="#堆排序">堆排序</a></li>
            <li><a href="#归并排序">归并排序</a></li>
          </ul>
        </li>
        <li><a href="#其他排序">其他排序</a>
          <ul>
            <li><a href="#计数排序">计数排序</a></li>
            <li><a href="#桶排序">桶排序</a></li>
            <li><a href="#基数排序">基数排序</a></li>
          </ul>
        </li>
        <li><a href="#动图展示">动图展示</a>
          <ul>
            <li><a href="#冒泡排序-1">冒泡排序</a></li>
            <li><a href="#选择排序-1">选择排序</a></li>
            <li><a href="#插入排序-1">插入排序</a></li>
            <li><a href="#希尔排序-1">希尔排序</a></li>
            <li><a href="#归并排序-1">归并排序</a></li>
            <li><a href="#快速排序-1">快速排序</a></li>
            <li><a href="#堆排序-1">堆排序</a></li>
            <li><a href="#计数排序-1">计数排序</a></li>
            <li><a href="#桶排序-1">桶排序</a></li>
            <li><a href="#基数排序-1">基数排序</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p><img src="https://img.xiaoyou66.com/2021/03/21/da92ad2a88146.png" alt="image-20210310152450389"></p>
<h2 id="插入排序">插入排序</h2>
<h3 id="直接插入排序">直接插入排序</h3>
<p>插入排序是最简单的，我们不断比较插入数据</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 插入排序
</span><span class="c1">// 时间复杂度 n^2
</span><span class="c1">// 因为我们这里是两层for循环，运气好的话，如果是有序的那么只需要执行一层，时间复杂度就是n
</span><span class="c1">// 运气不好的话时间复杂度就是 n^2 平均的时间复杂度为 n^2
</span><span class="c1">// 空间复杂度 1 ，因为我们只使用了一个临时变量，然后就没申请其他的了，所以空间复杂度为 1
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">insertSort</span><span class="p">(</span><span class="nx">arr</span> <span class="p">[]</span><span class="kt">int</span><span class="p">){</span>
	<span class="c1">// 使用j来表示当前排序的位置
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">j</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">1</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">);</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
		<span class="c1">// 使用临时变量存储
</span><span class="c1"></span>		<span class="nx">tmp</span><span class="o">:=</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="c1">// 这个就是核心部分，首先我们让j处于i上
</span><span class="c1"></span>		<span class="c1">// 当j-1大于tmp也就是arr[i]的时候,我们就需要把数字向后移动
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">j</span> <span class="p">=</span> <span class="nx">i</span> <span class="p">;</span> <span class="nx">j</span><span class="p">&gt;</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">&gt;</span> <span class="nx">tmp</span> <span class="p">;</span> <span class="nx">j</span><span class="o">--</span><span class="p">{</span>
			<span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="p">}</span>
		<span class="c1">// for循环的顺序 就是先j=1，然后执行判断语句，成功的话我们就执行函数体，最后才执行j--
</span><span class="c1"></span>		<span class="c1">// 所以我们这里移动后，j实际上减了1，这样我们就可以直接替换了
</span><span class="c1"></span>		<span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">tmp</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>插入排序的思想如下</p>
<p><img src="https://img.xiaoyou66.com/2021/03/21/da5ab445a3753.png" alt="image-20210128094237098"></p>
<p>时间复杂度为o(n^2) 空间复杂度为o(1)</p>
<h3 id="折半插入排序">折半插入排序</h3>
<p><img src="https://img.xiaoyou66.com/2021/03/21/42f4510a65212.png" alt="image-20210128102903185"></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 折半插入排序（这个不算10大排序算法）
</span><span class="c1">// 时间复杂度为 n^2，为什么是n^2呢，外面这一层不必多说就是n
</span><span class="c1">// 里面这层，虽然有两个for循环，但是实际情况下，这个执行的时间是随n线性变化的，所以也可以看成n
</span><span class="c1">// 空间复杂度为 1 这里为什么不是3呢，因为我们这个空间复杂度反映的是一个趋势
</span><span class="c1">// 无论我们的n是多大，我们始终只用了三个变量，所以空间复杂度为1
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">bInsertSort</span><span class="p">(</span><span class="nx">arr</span> <span class="p">[]</span><span class="kt">int</span><span class="p">){</span>
	<span class="kd">var</span> <span class="nx">j</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">1</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">);</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
		<span class="c1">// 存储临时变量
</span><span class="c1"></span>		<span class="nx">tmp</span> <span class="o">:=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="c1">// 赋值low和high，这里high等于i-1
</span><span class="c1"></span>		<span class="c1">// 这里为什么i-1，因为我们最后计算的时候要确保low指针+1不会越界
</span><span class="c1"></span>		<span class="nx">low</span><span class="p">,</span><span class="nx">high</span><span class="p">,</span><span class="nx">mid</span><span class="o">:=</span><span class="mi">0</span><span class="p">,</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span>
		<span class="c1">// 我们使用指针来查找需要插入的位置
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">low</span> <span class="o">&lt;=</span> <span class="nx">high</span> <span class="p">{</span>
			<span class="nx">mid</span> <span class="p">=</span> <span class="p">(</span><span class="nx">low</span><span class="o">+</span><span class="nx">high</span><span class="p">)</span> <span class="o">/</span><span class="mi">2</span>
			<span class="k">if</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">mid</span><span class="p">]</span> <span class="p">&gt;</span> <span class="nx">tmp</span> <span class="p">{</span>
				<span class="nx">high</span> <span class="p">=</span> <span class="nx">mid</span> <span class="o">-</span> <span class="mi">1</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">low</span> <span class="p">=</span> <span class="nx">mid</span> <span class="o">+</span> <span class="mi">1</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="c1">// 这里说一下为什么最后这个low就是我们应该放入的位置
</span><span class="c1"></span>		<span class="c1">// low,high,mid的值是两个一组的，上一组是a[i]和a[mid]未经比较以前的，
</span><span class="c1"></span>		<span class="c1">// 下一组是比较后，经过调整的。调整结果要么是low=mid+1，要么是high=mid-1。
</span><span class="c1"></span>		<span class="c1">// 不知大家从上面的数据看出了什么。对！我们现在可以清楚的肯定：新元素的插入位置就是low。
</span><span class="c1"></span>		<span class="c1">// 并且还发现high比low要小一，即high+1才与low相等。这是显然的，否则while循环如何结束。
</span><span class="c1"></span>		<span class="c1">// 我想此刻大家的疑惑肯定是解开了。那么插入位置的写法就很随意了:low和high+1都行！
</span><span class="c1"></span>		<span class="c1">// fmt.Println(low,mid,high)
</span><span class="c1"></span>		<span class="c1">// 这里为什么要取low因为我们结束后j一定为是low，所以我们可以直接替换
</span><span class="c1"></span>		<span class="c1">// 我也尝试过high不减一，low&lt;high 但是就是调不出来，我也不知道为什么
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">j</span><span class="p">=</span><span class="nx">i</span><span class="p">;</span><span class="nx">j</span><span class="p">&gt;</span><span class="nx">low</span><span class="p">;</span><span class="nx">j</span><span class="o">--</span> <span class="p">{</span>
			<span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="p">}</span>
		<span class="nx">arr</span><span class="p">[</span><span class="nx">low</span><span class="p">]</span> <span class="p">=</span> <span class="nx">tmp</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>时间复杂度为o(n^2) 时间复杂度为O(1)</p>
<h3 id="希尔排序">希尔排序</h3>
<p><img src="https://img.xiaoyou66.com/2021/03/21/b674a6b489086.png" alt="image-20210310105042665"></p>
<p>也叫缩小增量排序，通过把整个待排序记录序列分割成几组，从而减少需要排序的数据量</p>
<p><img src="https://img.xiaoyou66.com/2021/03/21/6b2b3f93f9185.png" alt="image-20210310105238782"></p>
<p>我们的代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 希尔排序
</span><span class="c1">// 时间复杂度 n^1.3 这个是别人试验验证的结果
</span><span class="c1">// 空间复杂度 不随n变化就是1
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">shellSort</span><span class="p">(</span><span class="nx">arr</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 首先我们就是要确定增量大小，默认情况下，我们取n=len(arr)/2，后面我们的增量就会不断的缩小
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">gap</span><span class="o">:=</span><span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span><span class="nx">gap</span><span class="p">&gt;</span><span class="mi">0</span><span class="p">;</span><span class="nx">gap</span><span class="o">/=</span><span class="mi">2</span><span class="p">{</span>
		<span class="c1">// 确定好增量后我们就从gap开始,这里为什么是i等于gap呢，因为我们后面是j-gap，所以我们需要从这个增量开始计算
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="nx">gap</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">);</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
			<span class="c1">// 用一个变量来暂存i的位置
</span><span class="c1"></span>			<span class="nx">j</span><span class="o">:=</span><span class="nx">i</span>
			<span class="c1">// 这里就开始比较了，我们是从gap开始的，j-gap 是我们比的第二个数字，然后我们进行交换
</span><span class="c1"></span>			<span class="k">for</span> <span class="nx">j</span><span class="o">-</span><span class="nx">gap</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">&lt;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="o">-</span><span class="nx">gap</span><span class="p">]</span> <span class="p">{</span>
				<span class="c1">// 如果发现右边大于左边的，我们就交换一下
</span><span class="c1"></span>				<span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span><span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="o">-</span><span class="nx">gap</span><span class="p">]</span> <span class="p">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="o">-</span><span class="nx">gap</span><span class="p">],</span><span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
				<span class="c1">// 这一步其实是优化，要不要都一样，我们这里就是确保后面排序后再给前面排序，加快排序速度
</span><span class="c1"></span>				<span class="nx">j</span><span class="o">-=</span><span class="nx">gap</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="交换排序">交换排序</h2>
<h3 id="冒泡排序">冒泡排序</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 冒泡排序
</span><span class="c1">// 时间复杂度 n^2 因为我们用了两层循环，这种两层循环的一般都是n^2
</span><span class="c1">// 空间复杂度 1 这个和上面一样，不解释
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">bubbleSort</span><span class="p">(</span><span class="nx">arr</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span>  <span class="p">{</span>
	<span class="nx">flag</span><span class="o">:=</span><span class="kc">true</span>
	<span class="c1">// 首先我们直接设置i，i表示当前未排序的区间最大值,同时为了避免重复比较，设置一个flag来进行标记
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="nx">i</span><span class="p">&gt;</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">flag</span><span class="p">;</span><span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
		<span class="c1">// 把flag置为false，如果没有排序那么我们就退出循环
</span><span class="c1"></span>		<span class="nx">flag</span> <span class="p">=</span> <span class="kc">false</span>
		<span class="c1">// 然后我们只需要按顺序排好i前面的就行了
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">j</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">j</span><span class="p">&lt;</span><span class="nx">i</span><span class="p">;</span><span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="c1">// 冒泡排序是比较相邻两个位置的元素
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">&gt;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="p">{</span>
				<span class="c1">// flag置为true表示已经排过序了
</span><span class="c1"></span>				<span class="nx">flag</span> <span class="p">=</span> <span class="kc">true</span>
				<span class="c1">// 交换
</span><span class="c1"></span>				<span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span><span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>算法思路如下</p>
<p><img src="https://img.xiaoyou66.com/2021/03/21/8b70039e1ab2c.png" alt="image-20210202102330722"></p>
<blockquote>
<p>算法特点</p>
</blockquote>
<p>(1)稳定排序。</p>
<p>(2)可用于链式存储结构。</p>
<p>(3)移动记录次数较多，算法平均时间性能比直接插入排序差。当初始记录无序，n较大时此算法不宜采用。</p>
<h3 id="快速排序">快速排序</h3>
<p>快速排序(QuickSort) 是由冒泡排序改进而得的。在冒泡排序过程中， 只对相邻的两个记录进行比较，因此每次交换两个相邻记录时只能消除一个逆序。如果能通过两个(不相邻)记录的一次交换，消除多个逆序，则会大大加快排序的速度。快速排序方法中的一次交换可能消除多个逆序。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 快速排序-返回枢纽位置并进行排序，传入一个low指针，一个high指针，然后给数组进行简单排序
</span><span class="c1">// 这里我们的数组排序好后返回一个中间位置的指针
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">partition</span><span class="p">(</span><span class="nx">arr</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span><span class="nx">low</span> <span class="kt">int</span><span class="p">,</span><span class="nx">high</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="c1">// 一般情况下我们直接取low点作为枢纽，然后我们就要进行排序，把比low小的排左边，比low大的排右边
</span><span class="c1"></span>	<span class="nx">tmp</span><span class="o">:=</span><span class="nx">arr</span><span class="p">[</span><span class="nx">low</span><span class="p">]</span>
	<span class="c1">// 当low大于high时我们的排序就已经好了,这个时候其实low就是high同时这个值为我们的枢纽
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">low</span> <span class="p">&lt;</span> <span class="nx">high</span> <span class="p">{</span>
		<span class="c1">// 首先我们从high哪里往左遍历，找出第一个比tmp小的点
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">low</span> <span class="p">&lt;</span> <span class="nx">high</span> <span class="o">&amp;&amp;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">high</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="nx">tmp</span> <span class="p">{</span>
			<span class="nx">high</span> <span class="o">--</span>
		<span class="p">}</span>
		<span class="c1">// 找到这个比tmp小的点后我们就替换过去，这个时候我们的high其实留了一个空
</span><span class="c1"></span>		<span class="nx">arr</span><span class="p">[</span><span class="nx">low</span><span class="p">]</span> <span class="p">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">high</span><span class="p">]</span>
		<span class="c1">// 因为上面high有一个空，所以这时候我们就可以从low指针开始出发，找到一个比tmp大的
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">low</span> <span class="p">&lt;</span> <span class="nx">high</span> <span class="o">&amp;&amp;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">low</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="nx">tmp</span> <span class="p">{</span>
			<span class="nx">low</span> <span class="o">++</span>
		<span class="p">}</span>
		<span class="c1">// 找到后我们就可以替换了，这个时候我们就把high给替换了，此时low就没用了
</span><span class="c1"></span>		<span class="c1">// 然后我们就可以进行下一轮比较了，然后我们可以继续把比tmp小的点放到low这里
</span><span class="c1"></span>		<span class="nx">arr</span><span class="p">[</span><span class="nx">high</span><span class="p">]</span> <span class="p">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">low</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="c1">// fmt.Println(low,high)
</span><span class="c1"></span>	<span class="c1">// 最后替换完后，low和high其实就指向同一个位置了，这时我们就可以把low换成tmp了
</span><span class="c1"></span>	<span class="nx">arr</span><span class="p">[</span><span class="nx">low</span><span class="p">]</span> <span class="p">=</span> <span class="nx">tmp</span>
	<span class="c1">// 返回low指针
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">low</span>
<span class="p">}</span>

<span class="c1">// 快速排序
</span><span class="c1">// 时间复杂度 nlogn 这东西推导比较复杂
</span><span class="c1">// 具体参考 https://www.zhihu.com/question/22393997
</span><span class="c1">// 空间复杂度 最好情况nlogn（注意这个log以2为底），最坏情况就是n
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">quickSort</span><span class="p">(</span><span class="nx">arr</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span><span class="nx">low</span> <span class="kt">int</span><span class="p">,</span><span class="nx">high</span> <span class="kt">int</span><span class="p">)</span>  <span class="p">{</span>
	<span class="c1">// 这里也要判断，要不然会堆栈溢出
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">low</span> <span class="p">&lt;</span> <span class="nx">high</span> <span class="p">{</span>
		<span class="c1">// 给数组进行简单排序，同时留下一个mid位置的指针
</span><span class="c1"></span>		<span class="nx">mid</span><span class="o">:=</span><span class="nf">partition</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span><span class="nx">low</span><span class="p">,</span><span class="nx">high</span><span class="p">)</span>
		<span class="c1">// 这里我们使用递归来分别递归左右两部分
</span><span class="c1"></span>		<span class="nf">quickSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span><span class="nx">low</span><span class="p">,</span><span class="nx">mid</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="nf">quickSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span><span class="nx">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nx">high</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>算法特点</p>
</blockquote>
<p>(1)记录非顺次的移动导致排序方法是不稳定的。</p>
<p>(2)排序过程中需要定位表的下界和上界，所以适合用于顺序结构，很难用于链式结构。</p>
<p>(3)当n较大时，在平均情况下快速排序是所有内部排序方法中速度最快的一种，所以其适合初始记录无序、n较大时的情况。</p>
<h2 id="选择排序">选择排序</h2>
<p>选择排序的基本思想是：每一趟从待排序的记录中选出关键字最小的记录，按顺序放在已排序的记录序列的最后，直到全部排完为止。本节首先介绍一种简单选择排序方法，然后给出另一种改进的选择排序方法——堆排序。</p>
<h3 id="简单选择排序">简单选择排序</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 选择排序
</span><span class="c1">// 时间复杂度 n^2 这个很简单，因为是for循环嵌套
</span><span class="c1">// 空间复杂度为1 
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">selectSort</span><span class="p">(</span><span class="nx">arr</span> <span class="p">[]</span><span class="kt">int</span><span class="p">){</span>
	<span class="nx">j</span><span class="o">:=</span><span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="c1">// 记录最小值的位置
</span><span class="c1"></span>		<span class="nx">min</span><span class="o">:=</span><span class="nx">i</span>
		<span class="c1">// 找出最小的那个值，这里我们从i开始往后找，找到一个最小的
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">j</span><span class="p">=</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="nx">j</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">);</span><span class="nx">j</span><span class="o">++</span><span class="p">{</span>
			<span class="k">if</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">&lt;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">min</span><span class="p">]{</span>
				<span class="nx">min</span> <span class="p">=</span> <span class="nx">j</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="c1">// 最小值进行替换一下
</span><span class="c1"></span>		<span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span><span class="nx">arr</span><span class="p">[</span><span class="nx">min</span><span class="p">]</span> <span class="p">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">min</span><span class="p">],</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><img src="https://img.xiaoyou66.com/2021/03/21/c1989e6313203.png" alt="image-20210203145740355"></p>
<p>(1)就选择排序方法本身来讲，它是一种稳定的排序方法，但图8.6所表现出来的现象是不稳定的，这是因为上述实现选择排序的算法采用“交换记录”的策略所造成的，改变这个策略，可以写出不产生“不稳定现象”的选择排序算法。</p>
<p>(2)可用于链式存储结构。</p>
<p>(3)移动记录次数较少，当每一记录占用的空间较多时，此方法比直接插入排序快。</p>
<h3 id="堆排序">堆排序</h3>
<p>堆排序(HeapSort) 是一种树形选择排序， 在排序过程中， 将待排序的记录[.] 看成是一根完全二叉树的顺序存储结构、利用完全二叉树中双亲结点和孩子结点之间的内在关系、在当前无序的序列中选择关键字最大(或最小)的记录。</p>
<blockquote>
<p>堆的定义</p>
</blockquote>
<p>堆要满足下面这样的条件</p>
<p><img src="https://img.xiaoyou66.com/2021/03/21/229b9060ac35d.png" alt="image-20210203160925522"></p>
<p>堆可以看成完全二叉树</p>
<p><img src="https://img.xiaoyou66.com/2021/03/21/4c0d20ff9dc1d.png" alt="image-20210203161155273"></p>
<blockquote>
<p>堆排序的步骤</p>
</blockquote>
<p>首先需要建初堆，建初堆的目的是将无序序列调整为堆，然后我们不断交换堆顶和堆最后一个元素，然后重新调整堆</p>
<p>筛选法调整堆的算法步骤如下</p>
<p><img src="https://img.xiaoyou66.com/2021/03/21/2ce1ccad34d6e.png" alt="image-20210203162419868"></p>
<p>建初堆的步骤如下</p>
<p><img src="https://img.xiaoyou66.com/2021/03/21/abc86fe9db917.png" alt="image-20210203162626056"></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 建初堆
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">createHeap</span><span class="p">(</span><span class="nx">arr</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span>  <span class="p">{</span>
	<span class="c1">// 这里我们使用筛选法来建初堆，我们依次把、[n/2],[n/2]-1,....,1的节点都调整为堆即可
</span><span class="c1"></span>	<span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
	<span class="c1">// 根据堆的性质，在完全二叉树中所有序号大于 [n/2]的节点都是叶子，
</span><span class="c1"></span>	<span class="c1">// 所以我们只需要调整 1 - n/2 这个区间把这几个点调整为大根堆就行
</span><span class="c1"></span>	<span class="c1">// 这里调整堆传入了一个开始点和结束点
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span><span class="nx">n</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span><span class="nx">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="o">--</span><span class="p">{</span>
		<span class="nf">adjustHeap</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span><span class="nx">i</span><span class="p">,</span><span class="nx">n</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 调整堆
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">adjustHeap</span><span class="p">(</span><span class="nx">arr</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span><span class="nx">s</span> <span class="kt">int</span><span class="p">,</span><span class="nx">m</span> <span class="kt">int</span><span class="p">)</span>  <span class="p">{</span>
	<span class="c1">// 保存起始点的值作为临变量
</span><span class="c1"></span>	<span class="nx">rc</span><span class="o">:=</span><span class="nx">arr</span><span class="p">[</span><span class="nx">s</span><span class="p">]</span>
	<span class="c1">// 我们使用筛选法来调整堆
</span><span class="c1"></span>	<span class="c1">// 这里使用了堆的性质
</span><span class="c1"></span>	<span class="c1">// 当 ki&gt;=k2i 且 ki &gt;= k2i+1 或 ki &lt;=k2i 且 ki &lt;= k2i+1
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">j</span><span class="o">:=</span><span class="mi">2</span><span class="o">*</span><span class="nx">s</span><span class="p">;</span><span class="nx">j</span><span class="o">&lt;=</span><span class="nx">m</span><span class="p">;</span><span class="nx">j</span><span class="o">*=</span><span class="mi">2</span><span class="p">{</span>
		<span class="k">if</span> <span class="nx">j</span><span class="p">&lt;</span><span class="nx">m</span> <span class="o">&amp;&amp;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]&lt;</span><span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]{</span> <span class="nx">j</span><span class="o">++</span> <span class="p">}</span>
		<span class="k">if</span> <span class="nx">rc</span> <span class="o">&gt;=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">{</span> <span class="k">break</span><span class="p">}</span>
		<span class="nx">arr</span><span class="p">[</span><span class="nx">s</span><span class="p">]</span> <span class="p">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
		<span class="nx">s</span><span class="p">=</span><span class="nx">j</span>
	<span class="p">}</span>
	<span class="nx">arr</span><span class="p">[</span><span class="nx">s</span><span class="p">]</span> <span class="p">=</span> <span class="nx">rc</span>
<span class="p">}</span>

<span class="c1">// 堆排序
</span><span class="c1">// 时间复杂度 nlogn
</span><span class="c1">// 这里耗时操作在于筛选和调整 筛选需要n-1次 然后n个节点的二叉树深度为logn +1
</span><span class="c1">// 空间复杂度 1 因为只需要一个临时空间
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">heapSort</span><span class="p">(</span><span class="nx">arr</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span>  <span class="p">{</span>
	<span class="c1">// 先建堆，保证初始的时候是一个堆
</span><span class="c1"></span>	<span class="nf">createHeap</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span>
	<span class="c1">// 开始进行for循环，进行堆排序
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="nx">i</span><span class="p">&gt;</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="o">--</span><span class="p">{</span>
		<span class="c1">// 这里我们把最大的那个最后一个（这个指的是当前堆的最大一个）互换
</span><span class="c1"></span>		<span class="c1">// 因为我们堆排序后0号是最大的
</span><span class="c1"></span>		<span class="nx">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span><span class="nx">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="c1">// 我们i号是最大的了，所以我们忽略i，从i-1开始进行调整
</span><span class="c1"></span>		<span class="nf">adjustHeap</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>利用了堆里面首部元素最大的特点</p>
<p><img src="https://img.xiaoyou66.com/2021/03/21/cb931655fc9d7.png" alt="image-20210203163030143"></p>
<h3 id="归并排序">归并排序</h3>
<p><img src="https://img.xiaoyou66.com/2021/03/21/84dcfcf2cff3c.png" alt="image-20210203163313449"></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 合并表
</span><span class="c1">// 注意这里我们arr2是一个空数组，然后arr1的low和mid是一个排好序的数组，mid+1和high也是一个排好序的数组
</span><span class="c1">// 这个函数的作用就是把两个数组合并为一个数组，放入arr2中
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Merge</span><span class="p">(</span><span class="nx">arr1</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span><span class="nx">arr2</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span><span class="nx">low</span> <span class="kt">int</span><span class="p">,</span><span class="nx">mid</span> <span class="kt">int</span><span class="p">,</span><span class="nx">high</span> <span class="kt">int</span><span class="p">)</span>  <span class="p">{</span>
	<span class="c1">// 这里我们使用i和j来表示arr1数组的两部分，然后k就表示arr2数组的位置
</span><span class="c1"></span>	<span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">,</span><span class="nx">k</span><span class="o">:=</span><span class="nx">low</span><span class="p">,</span><span class="nx">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nx">low</span>
	<span class="c1">// 只要有一个数组到头了，我们就介绍排序
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">mid</span> <span class="o">&amp;&amp;</span> <span class="nx">j</span><span class="o">&lt;=</span><span class="nx">high</span> <span class="p">{</span>
		<span class="c1">// 因为我们要合并两个数组，所以我们需要判断一下数组的两部分到底谁大
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">arr1</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">&gt;</span> <span class="nx">arr1</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">{</span>
			<span class="c1">// 注意，k表示arr2的位置，然后j表示的是 mid+1 到high这个数组
</span><span class="c1"></span>			<span class="nx">arr2</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span> <span class="p">=</span> <span class="nx">arr1</span><span class="p">[</span><span class="nx">j</span><span class="p">];</span><span class="nx">k</span><span class="o">++</span><span class="p">;</span><span class="nx">j</span><span class="o">++</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c1">// 注意，k表示arr2的位置，然后j表示的是 low 到mid 这个数组
</span><span class="c1"></span>			<span class="nx">arr2</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span> <span class="p">=</span> <span class="nx">arr1</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span><span class="nx">k</span><span class="o">++</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// 剩余部分因为已经是一个有序的数组了，所以我们直接按顺序加到arr2就行
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span><span class="o">&lt;=</span><span class="nx">mid</span> <span class="p">{</span>
		<span class="nx">arr2</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span> <span class="p">=</span> <span class="nx">arr1</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span><span class="nx">i</span><span class="o">++</span><span class="p">;</span><span class="nx">k</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">j</span><span class="o">&lt;=</span><span class="nx">high</span> <span class="p">{</span>
		<span class="nx">arr2</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span> <span class="p">=</span> <span class="nx">arr1</span><span class="p">[</span><span class="nx">j</span><span class="p">];</span><span class="nx">j</span><span class="o">++</span><span class="p">;</span><span class="nx">k</span><span class="o">++</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 2-路归并排序
</span><span class="c1">// 时间复杂度nlogn
</span><span class="c1">// 空间复杂度 n 因为我们排序的时候需要申请n个空间来存储
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">mSort</span><span class="p">(</span><span class="nx">arr</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span><span class="nx">arr2</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span><span class="nx">low</span> <span class="kt">int</span><span class="p">,</span><span class="nx">high</span> <span class="kt">int</span><span class="p">)</span>  <span class="p">{</span>
	<span class="c1">// 当low和high相等的时候，这个时候大小为1，我们直接放到arr2就行
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">low</span> <span class="o">==</span> <span class="nx">high</span><span class="p">{</span>
		<span class="nx">arr2</span><span class="p">[</span><span class="nx">low</span><span class="p">]</span> <span class="p">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">low</span><span class="p">]</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// 我们准备开始进行拆分,我们需要把我们的数组拆成两部分
</span><span class="c1"></span>		<span class="nx">arr3</span><span class="o">:=</span><span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="nx">high</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
		<span class="c1">// 直接取mid作为数组的分界点
</span><span class="c1"></span>		<span class="nx">mid</span><span class="o">:=</span> <span class="p">(</span><span class="nx">low</span> <span class="o">+</span> <span class="nx">high</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
		<span class="c1">// 首先我们把low和mid 进行排序并放入arr3中
</span><span class="c1"></span>		<span class="nf">mSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span><span class="nx">arr3</span><span class="p">,</span><span class="nx">low</span><span class="p">,</span><span class="nx">mid</span><span class="p">)</span>
		<span class="c1">// 然后我们把mid+1和high 进行排序并放入arr3中
</span><span class="c1"></span>		<span class="nf">mSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span><span class="nx">arr3</span><span class="p">,</span><span class="nx">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nx">high</span><span class="p">)</span>
		<span class="c1">// 最后我们得到的数组在arr3中已经排好序并分成了两部分
</span><span class="c1"></span>		<span class="c1">// 因为arr2是一个空数组，所以我们把arr3再进行排序，最后就是合并为一个有序的表并放入arr2中
</span><span class="c1"></span>		<span class="nf">Merge</span><span class="p">(</span><span class="nx">arr3</span><span class="p">,</span><span class="nx">arr2</span><span class="p">,</span><span class="nx">low</span><span class="p">,</span><span class="nx">mid</span><span class="p">,</span><span class="nx">high</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="其他排序">其他排序</h2>
<h3 id="计数排序">计数排序</h3>
<p>参考：<a href="https://www.cxyxiaowu.com/5437.html">漫画：什么是计数排序？-五分钟学算法 (cxyxiaowu.com)</a></p>
<p>这个算法不是基于元素比较，而是利用数组下标来确定元素的正确位置</p>
<p>假定我的的20个随机整数值如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">9，3，5，4，9，1，2，7，8，1，3，6，5，3，4，0，10，9 ，7，9
</code></pre></td></tr></table>
</div>
</div><p>我们可以确定最大值为10最小值为0，这样我们就建立一个大小为11的数组</p>
<p><img src="https://img.xiaoyou66.com/2021/03/21/5bef6772d5153.png" alt="image-20210311103052699"></p>
<p>非常简单，让我们遍历这个无序的随机数列，每一个整数按照其值对号入座，对应数组下标的元素进行加1操作。比如第一个整数是9，那么数组下标为9的元素加1</p>
<p><img src="https://img.xiaoyou66.com/2021/03/21/3b5862164bea3.png" alt="image-20210311103146018"></p>
<p>最终，数列遍历完毕时，数组的状态如下：</p>
<p><img src="https://img.xiaoyou66.com/2021/03/21/4a2963699bcbc.png" alt="image-20210311103157084"></p>
<p>有了这个“统计结果”，排序就很简单了。直接遍历数组，输出数组元素的下标值，元素的值是几，就输出几次：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">0，1，1，2，3，3，3，4，4，5，5，6，7，7，8，9，9，9，9，10
</code></pre></td></tr></table>
</div>
</div><p>通常，我们为了节省空间，需要确定一个最大值和最小值</p>
<p><img src="https://img.xiaoyou66.com/2021/03/21/b17700d544132.png" alt="image-20210311104347879"></p>
<p>实际代码如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 计数排序,这里我们传入一个数组，一个最小值，一个最大值
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">countingSort</span><span class="p">(</span><span class="nx">arr</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">minvalue</span><span class="p">,</span> <span class="nx">maxValue</span> <span class="kt">int</span><span class="p">){</span>
	<span class="c1">// 首先我们建立一个统计数组,为了节省空间我们直接取最大值和最小值的差+1的空间，这个时候最大值在最后一个，最小值在第一个
</span><span class="c1"></span>	<span class="nx">count</span><span class="o">:=</span><span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="nx">maxValue</span><span class="o">-</span><span class="nx">minvalue</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
	<span class="c1">// 遍历数组，统计出现的次数，注意我们计算的时候需要减minValue
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span><span class="nx">v</span><span class="o">:=</span><span class="k">range</span> <span class="nx">arr</span><span class="p">{</span>
		<span class="nx">count</span><span class="p">[</span><span class="nx">v</span><span class="o">-</span><span class="nx">minvalue</span><span class="p">]</span> <span class="o">++</span>
	<span class="p">}</span>
	<span class="c1">// 最后我们输出数组，这里我们使用i来标记arr数组
</span><span class="c1"></span>	<span class="nx">i</span><span class="o">:=</span><span class="mi">0</span>
	<span class="c1">// 遍历count
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">k</span><span class="p">,</span><span class="nx">v</span><span class="o">:=</span><span class="k">range</span> <span class="nx">count</span><span class="p">{</span>
		<span class="c1">// 如果count数组为0那么就不管，如果不为0那么就为几，我们就输出几次
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">v</span><span class="o">!=</span><span class="mi">0</span> <span class="p">{</span>
			<span class="c1">// 输出v次
</span><span class="c1"></span>			<span class="k">for</span> <span class="nx">j</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">j</span><span class="p">&lt;</span><span class="nx">v</span><span class="p">;</span><span class="nx">j</span><span class="o">++</span><span class="p">{</span>
				<span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">minvalue</span> <span class="o">+</span> <span class="nx">k</span>
				<span class="nx">i</span> <span class="o">++</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="桶排序">桶排序</h3>
<p><a href="https://www.runoob.com/w3cnote/bucket-sort.html">1.9 桶排序 | 菜鸟教程 (runoob.com)</a></p>
<p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：</p>
<ol>
<li>在额外空间充足的情况下，尽量增大桶的数量</li>
<li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中</li>
</ol>
<p>同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。</p>
<p><strong>1. 什么时候最快</strong></p>
<p>当输入的数据可以均匀的分配到每一个桶中。</p>
<p><strong>2. 什么时候最慢</strong></p>
<p>当输入的数据被分配到了同一个桶中。</p>
<p><img src="https://img.xiaoyou66.com/2021/03/21/4fb64a1f7d2af.png" alt="image-20210311105443539"></p>
<p>比如我们有下面这几个数组</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">[63,157,189,51,101,47,141,121,157,156,194,117,98,139,67,133,181,13,28,109] 
</code></pre></td></tr></table>
</div>
</div><p>我们分成5个桶，下面开始排序</p>
<ol>
<li>找到数组中的最大值194和最小值13，然后根据桶数为5，计算出每个桶中的数据范围为<code>(194-13+1)/5=36.4</code></li>
<li>遍历原始数据，(以第一个数据63为例)先找到该数据对应的桶序列<code>Math.floor(63 - 13) / 36.4) =1</code>，然后将该数据放入序列为1的桶中(从0开始算)</li>
<li>当向同一个序列的桶中第二次插入数据时，判断桶中已存在的数字与新插入的数字的大小，按从左到右，从小打大的顺序插入。如第一个桶已经有了63，再插入51，67后，桶中的排序为(51,63,67) <strong>一般通过链表来存放桶中数据，但js中可以使用数组来模拟</strong></li>
<li>全部数据装桶完毕后，按序列，从小到大合并所有非空的桶(如0,1,2,3,4桶)</li>
<li>合并完之后就是已经排完序的数据</li>
</ol>
<p><img src="https://img.xiaoyou66.com/2021/03/21/079dbab6a522f.png" alt="image-20210311105823407"></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 桶排序，这里我们传入一个最大值，还有一为个桶的数量
</span><span class="c1">// 时间复杂度 为n+k
</span><span class="c1">// 空间复杂度为 n+k
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">sortBucket</span><span class="p">(</span><span class="nx">arr</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span><span class="nx">max</span> <span class="kt">int</span><span class="p">,</span><span class="nx">num</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 创建桶，大小为我们传入桶的数量
</span><span class="c1"></span>	<span class="nx">buckets</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span><span class="nx">num</span><span class="p">)</span>
	<span class="kd">var</span> <span class="nx">index</span> <span class="kt">int</span>
	<span class="c1">// 遍历数组
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span><span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">arr</span><span class="p">{</span>
		<span class="c1">// 分配桶 index = value * (n-1)/k 这里我们使用公式来确放入的位置
</span><span class="c1"></span>		<span class="nx">index</span> <span class="p">=</span> <span class="nx">v</span> <span class="o">*</span> <span class="p">(</span><span class="nx">num</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="nx">max</span>
		<span class="c1">// 把我们的数字放入桶内
</span><span class="c1"></span>		<span class="nx">buckets</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">buckets</span><span class="p">[</span><span class="nx">index</span><span class="p">],</span><span class="nx">v</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 桶内排序
</span><span class="c1"></span>	<span class="nx">tmpPos</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="c1">// 这里我们遍历每一个桶
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">k</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">k</span> <span class="p">&lt;</span> <span class="nx">num</span><span class="p">;</span> <span class="nx">k</span><span class="o">++</span> <span class="p">{</span>
		<span class="c1">// 获取桶里面数据的长度
</span><span class="c1"></span>		<span class="nx">bucketLen</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">buckets</span><span class="p">[</span><span class="nx">k</span><span class="p">])</span>
		<span class="c1">// 如果我们这个桶大小为0，那么我们就对桶里面进行排序
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">bucketLen</span><span class="p">&gt;</span><span class="mi">0</span><span class="p">{</span>
			<span class="c1">// 使用插入排序对数组进行排序
</span><span class="c1"></span>			<span class="nf">insertSort</span><span class="p">(</span><span class="nx">buckets</span><span class="p">[</span><span class="nx">k</span><span class="p">])</span>
			<span class="c1">// 我们把排序好的部分复制到数组中
</span><span class="c1"></span>			<span class="nb">copy</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">tmpPos</span><span class="p">:],</span><span class="nx">buckets</span><span class="p">[</span><span class="nx">k</span><span class="p">])</span>
			<span class="c1">// 数组位置加上桶的大小，开始保存下一个桶
</span><span class="c1"></span>			<span class="nx">tmpPos</span> <span class="o">+=</span><span class="nx">bucketLen</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="基数排序">基数排序</h3>
<p>基数排序与桶排序、计数排序都用到了桶的概念，但对桶的使用方法上有明显差异：</p>
<ul>
<li>基数排序：根据键值的每位数字来分配桶；</li>
<li>计数排序：每个桶只存储单一键值；</li>
<li>桶排序：每个桶存储一定范围的数值；</li>
</ul>
<p>基数排序按取数方向分为两种：从左取每个数列上的数，为<strong>最高位优先（Most Significant Digit first, MSD）</strong>；从右取每个数列上的数，为<strong>最低位优先（Least Significant Digit first, LSD）</strong>。下列以LSD为例。</p>
<p>基数排序步骤：</p>
<ul>
<li>将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零</li>
<li>从最低位开始，依次进行一次排序</li>
<li>从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">radixSort</span><span class="p">(</span><span class="nx">theArray</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span><span class="nx">max</span> <span class="kt">int</span><span class="p">){</span>
	<span class="c1">// 因为前面我们获取了最大值，这里我们获取一下最大值的位数
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">count</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">max</span> <span class="o">%</span> <span class="mi">10</span><span class="p">&gt;</span><span class="mi">0</span><span class="p">{</span>
		<span class="nx">max</span> <span class="o">/=</span> <span class="mi">10</span>
		<span class="nx">count</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="c1">// 给桶中对应的位置放数据
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="p">&lt;</span><span class="nx">count</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="c1">// 根据不同的位数，我们来获取10的n次方，用于后面获取每位的值
</span><span class="c1"></span>		<span class="nx">theData</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">math</span><span class="p">.</span><span class="nf">Pow10</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span>
		<span class="c1">// 建立空桶
</span><span class="c1"></span>		<span class="nx">bucket</span><span class="o">:=</span><span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
		<span class="c1">// 遍历数组
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">k</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">k</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">theArray</span><span class="p">);</span> <span class="nx">k</span><span class="o">++</span><span class="p">{</span>
			<span class="c1">// 这里我们进行取余操作，目的是为了获取这个数组在每位上的值
</span><span class="c1"></span>			<span class="nx">theResidue</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">theArray</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span><span class="o">/</span><span class="nx">theData</span><span class="p">)</span> <span class="o">%</span><span class="mi">10</span>
			<span class="c1">// 获取到了位数后我们直接放入对应的桶中
</span><span class="c1"></span>			<span class="nx">bucket</span><span class="p">[</span><span class="nx">theResidue</span><span class="p">]</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">bucket</span><span class="p">[</span><span class="nx">theResidue</span><span class="p">],</span><span class="nx">theArray</span><span class="p">[</span><span class="nx">k</span><span class="p">])</span>
		<span class="p">}</span>

		<span class="c1">// 一遍循环完之后需要把数组二维数据进行重新排序，比如数组开始是10 1 18 30 23 12 7 5 18 233 144 ，循环个位数
</span><span class="c1"></span>		<span class="c1">// 循环之后的结果为10 30 1 12 23 233 144 5 7 18 18 ，然后循环十位数，结果为1 5 7 10 12 18 18 23 30 233 144
</span><span class="c1"></span>		<span class="c1">// 最后循环百位数，结果为1 5 7 10 12 18 18 23 30 144 233
</span><span class="c1"></span>		<span class="kd">var</span> <span class="nx">x</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="c1">// 遍历我们的桶
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">p</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">p</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">bucket</span><span class="p">);</span> <span class="nx">p</span><span class="o">++</span> <span class="p">{</span>
			<span class="k">for</span> <span class="nx">q</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">q</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">bucket</span><span class="p">[</span><span class="nx">p</span><span class="p">]);</span> <span class="nx">q</span><span class="o">++</span> <span class="p">{</span>
				<span class="c1">// 这里按照桶的结构，按桶的顺序把桶里面的数据放入数组中
</span><span class="c1"></span>				<span class="k">if</span> <span class="nx">bucket</span><span class="p">[</span><span class="nx">p</span><span class="p">][</span><span class="nx">q</span><span class="p">]</span><span class="o">!=</span><span class="mi">0</span> <span class="p">{</span>
					<span class="nx">theArray</span><span class="p">[</span><span class="nx">x</span><span class="p">]</span> <span class="p">=</span> <span class="nx">bucket</span><span class="p">[</span><span class="nx">p</span><span class="p">][</span><span class="nx">q</span><span class="p">]</span>
					<span class="nx">x</span><span class="o">++</span>
				<span class="p">}</span><span class="k">else</span> <span class="p">{</span>
					<span class="k">break</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="动图展示">动图展示</h2>
<h3 id="冒泡排序-1">冒泡排序</h3>
<p><img src="https://img.xiaoyou66.com/2021/03/21/951aff5d869c3.gif" alt="img"></p>
<h3 id="选择排序-1">选择排序</h3>
<p><img src="https://img.xiaoyou66.com/2021/03/21/5ed0ae683a31a.gif" alt="img"></p>
<h3 id="插入排序-1">插入排序</h3>
<p><img src="https://img.xiaoyou66.com/2021/03/21/a945cc090e486.gif" alt="img"></p>
<h3 id="希尔排序-1">希尔排序</h3>
<p><img src="https://img.xiaoyou66.com/2021/03/21/0a0918702b478.gif" alt="归并排序"></p>
<h3 id="归并排序-1">归并排序</h3>
<p><img src="https://img.xiaoyou66.com/2021/03/21/5a6e77b2dd552.gif" alt="img"></p>
<p><img src="https://img.xiaoyou66.com/2021/03/21/6f7105de6ceb1.gif" alt="img"></p>
<h3 id="快速排序-1">快速排序</h3>
<p><img src="https://img.xiaoyou66.com/2021/03/21/3c1572ae25ca1.gif" alt="img"></p>
<p><img src="https://img.xiaoyou66.com/2021/03/21/4ea3a4530f2c4.gif" alt="img"></p>
<h3 id="堆排序-1">堆排序</h3>
<p><img src="https://img.xiaoyou66.com/2021/03/21/91246bdf58339.gif" alt="img"></p>
<p><img src="https://img.xiaoyou66.com/2021/03/21/ba376597c7685.gif" alt="img"></p>
<h3 id="计数排序-1">计数排序</h3>
<p><img src="https://img.xiaoyou66.com/2021/03/21/f6df9e7ff91c9.gif" alt="img"></p>
<h3 id="桶排序-1">桶排序</h3>
<p><img src="https://img.xiaoyou66.com/2021/03/21/4455032208e07.gif" alt="img"></p>
<h3 id="基数排序-1">基数排序</h3>
<p><img src="https://img.xiaoyou66.com/2021/03/21/685892720c3c9.gif" alt="img"></p>
<p>参考<a href="https://www.jianshu.com/p/bd7d6f1be6e7">收集一波十大算法动态图 - 简书 (jianshu.com)</a></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">LYR</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2021-03-21
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags//"></a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/06.%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/03.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/03.%E8%A1%8C%E4%B8%BA%E5%9E%8B/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">行为型</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/06.%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01.%E7%AE%97%E6%B3%95/02.%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/">
            <span class="next-text nav-default">查找算法</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:lyr-2000@qq.com" class="iconfont icon-email" title="email"></a>
  <a href="http://doc.lyr-2000.xyz/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021<span class="heart"><i class="iconfont icon-heart"></i></span><span>lyr</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>








</body>
</html>
