<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>IO模型 - Even - A super concise theme for Hugo</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="LYR" /><meta name="description" content="网络IO模型 [TOC] 同步异步, 阻塞非阻塞 同步 : 在发出一个 功能调用 的时候, 在没有得到结果之前, 该调用就不返回 异步 : 在发出一个 功能调用 的时候, 不管有没" /><meta name="keywords" content="LYR的文档站, LYR的个人博客, even" />






<meta name="generator" content="Hugo 0.86.0 with theme even" />


<link rel="canonical" href="http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/javaio/io%E6%A8%A1%E5%9E%8B/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.b5a744db6de49a86cadafb3b70f555ab443f83c307a483402259e94726b045ff.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="IO模型" />
<meta property="og:description" content="网络IO模型 [TOC] 同步异步, 阻塞非阻塞 同步 : 在发出一个 功能调用 的时候, 在没有得到结果之前, 该调用就不返回 异步 : 在发出一个 功能调用 的时候, 不管有没" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/javaio/io%E6%A8%A1%E5%9E%8B/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-08-14T22:43:02+08:00" />
<meta property="article:modified_time" content="2021-08-14T22:43:02+08:00" />

<meta itemprop="name" content="IO模型">
<meta itemprop="description" content="网络IO模型 [TOC] 同步异步, 阻塞非阻塞 同步 : 在发出一个 功能调用 的时候, 在没有得到结果之前, 该调用就不返回 异步 : 在发出一个 功能调用 的时候, 不管有没"><meta itemprop="datePublished" content="2021-08-14T22:43:02+08:00" />
<meta itemprop="dateModified" content="2021-08-14T22:43:02+08:00" />
<meta itemprop="wordCount" content="1908">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="IO模型"/>
<meta name="twitter:description" content="网络IO模型 [TOC] 同步异步, 阻塞非阻塞 同步 : 在发出一个 功能调用 的时候, 在没有得到结果之前, 该调用就不返回 异步 : 在发出一个 功能调用 的时候, 不管有没"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">LYR的文档站</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">首页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档页</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a><a href="/friends">
        <li class="mobile-menu-item">大佬</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">LYR的文档站</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">首页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/friends">大佬</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">IO模型</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-08-14 </span>
        
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#网络io模型">网络IO模型</a></li>
    <li><a href="#同步异步-阻塞非阻塞">同步异步, 阻塞非阻塞</a></li>
    <li><a href="#端口与连接">端口与连接</a>
      <ul>
        <li><a href="#什么是-socket-">什么是 Socket ?</a></li>
      </ul>
    </li>
    <li><a href="#bio---阻塞io模型">BIO - 阻塞IO模型</a>
      <ul>
        <li><a href="#bio-各线程什么情况会被阻塞">BIO 各线程什么情况会被阻塞</a></li>
        <li><a href="#bio-的缺点">BIO 的缺点</a></li>
      </ul>
    </li>
    <li><a href="#nio---单线程模型">NIO - 单线程模型</a>
      <ul>
        <li><a href="#nio-的思想">NIO 的思想</a></li>
        <li><a href="#nio-java-实现">NIO Java 实现</a></li>
      </ul>
    </li>
    <li><a href="#经典的-io-三模型">经典的 IO 三模型</a></li>
    <li><a href="#一-select-模型">一. select 模型</a></li>
    <li><a href="#二-poll-模型">二. poll 模型</a></li>
    <li><a href="#三-epoll-模型-linux">三. epoll 模型 (Linux)</a>
      <ul>
        <li><a href="#概述">概述</a></li>
        <li><a href="#已知的-epoll-模型应用">已知的 epoll 模型应用</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h1 id="网络io模型">网络IO模型</h1>
<p>[TOC]</p>
<h1 id="同步异步-阻塞非阻塞">同步异步, 阻塞非阻塞</h1>
<ul>
<li>
<p>同步 : 在发出一个 <strong>功能调用</strong> 的时候, 在没有得到结果之前, 该调用就不返回</p>
</li>
<li>
<p>异步 : 在发出一个 <strong>功能调用</strong> 的时候, 不管有没有结果, 先执行后续的操作. 异步的模型的复杂度远高于同步.</p>
<p><code>e.g.1</code> : NIO 服务端通过 <strong>状态轮询 (select)</strong>  , <strong>通知 (epoll)</strong> , <strong>回调 (epoll)</strong> 的方式去发现结果有没有被处理完</p>
<p><code>e.g.2</code> : Netty 给另一端发送消息的时候, 并不判断消息发送的成功与否, 而是直接进行下面的步骤, 成功与否通过 <strong>回调</strong> 的方式去判断</p>
</li>
<li>
<p>阻塞和非阻塞是针对于线程在等待某个事的状态来说的, 如果等待的是时候, 让出 CPU 资源, 直到等待事件发生, 便为 <strong>阻塞</strong></p>
</li>
</ul>
<p><code>Java 网络I/O</code>  的发展路线如下 :</p>
<p><code>BIO -&gt; NIO -&gt; AIO -&gt; Netty</code> 实际上 <code>Netty</code> 只是对 <code>NIO </code> 的封装</p>
<blockquote>
<p><a href="https://www.cnblogs.com/yangyuanhu/p/11152914.html">epoll 详解</a></p>
</blockquote>
<h1 id="端口与连接">端口与连接</h1>
<p>注意, <strong>并不是</strong> 一个端口只能建立一个连接, 而是可以建立非常多的连接, 参考 <code>80</code> 端口就可以同时建立多条 <strong>Web 请求</strong> , 且建立连接的数量和系统内核有关系.</p>
<p>但是 每个链接会对应不同的 <code>Socket</code> , 然后链接也用 <code>Socket</code> 进行标示</p>
<p><code>Socket = (源地址、源端口、目的地址、目的端口、协议号)</code></p>
<p>每次 <code>server</code> <code>accept</code> 一个连接后, 都会返回一个 <code>Socket</code> 去标示这一个链接</p>
<h2 id="什么是-socket-">什么是 Socket ?</h2>
<p>Socket 本质就是一个 <strong>文件</strong>, 这个文件用于维护所有和 当前连接有关的信息 :</p>
<ul>
<li>数据缓冲区</li>
<li>等待队列</li>
<li>&hellip;</li>
</ul>
<h1 id="bio---阻塞io模型">BIO - 阻塞IO模型</h1>
<p><code>Java.io	</code>包为传统的 IO 模型, 里面就是使用了 BIO</p>
<p><code>BIO Blocking-IO</code> 即为 <code>阻塞IO</code></p>
<p>使用的是 <strong>Thread Per Client</strong> 的模式 ,  即 每一个 <code>Client</code> 尝试连接 <code>server</code> , <code>server</code> 都会去</p>
<p>起一个新的 <code>Thread</code> 去处理这个请求.</p>
<img src='/image/2019-08-23-BIO.png'>
<p><code>BIO</code> 的实现机制如下 :</p>
<ul>
<li>
<p><code>server</code> 监听我们的规定 <code>端口号</code> , 如果一直没有 <code>clent</code> 连接便 一直阻塞这个 监听线程</p>
<p>阻塞语句为 : <code>ServerSocket.accept()</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 
</span><span class="c1"></span><span class="n">ServerSocket</span> <span class="n">ss</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ServerSocket</span><span class="o">();</span>

<span class="c1">// 绑定端口和ip
</span><span class="c1"></span><span class="n">ss</span><span class="o">.</span><span class="na">bind</span><span class="o">(</span><span class="k">new</span> <span class="n">InetSocketAddress</span><span class="o">(</span><span class="s">&#34;127.0.0.1&#34;</span><span class="o">,</span> <span class="n">8888</span><span class="o">));</span>
<span class="c1">// 循环监听
</span><span class="c1"></span><span class="k">while</span><span class="o">(</span><span class="kc">true</span><span class="o">){</span>
    <span class="n">Socket</span> <span class="n">s</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="na">accept</span><span class="o">();</span>	<span class="c1">// 线程阻塞 -- 释放 CPU 资源
</span><span class="c1"></span>
    <span class="c1">// 有客户端连接, 则开一个线程处理
</span><span class="c1"></span>    <span class="c1">// s 为一个 int 类型的值, 表示这个 C/S 连接
</span><span class="c1"></span>    <span class="k">new</span> <span class="n">Thread</span><span class="o">(()-&gt;{</span>
        <span class="c1">// do somethings ...
</span><span class="c1"></span>    <span class="o">}).</span><span class="na">run</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>一旦有 <code>client</code> 请求, 则开一个线程去处理, 然后主线继续进入监听阻塞状态, 否则无法处理并发</p>
</li>
</ul>
<p>​</p>
<h2 id="bio-各线程什么情况会被阻塞">BIO 各线程什么情况会被阻塞</h2>
<p><code>BIO</code> 模式下, 被阻塞的线程的情况非常的多</p>
<ul>
<li>主线程 监听的时候会被阻塞</li>
<li>处理线程 处理读写 字节流的时候 会被阻塞</li>
</ul>
<p>所有由于线程阻塞的情况, 我们的 <code>BIO</code> 的实际效率非常的低.</p>
<h2 id="bio-的缺点">BIO 的缺点</h2>
<p>对于 BIO 模型, <strong>每一个客户端连接都会创建一个新的线程去处理</strong>. 首先线程的创建和销毁极其的耗费时间. 且并不是每一个连接都会去 进行读写数据操作, 如果并没有写操作, 处理这个连接的线程就会一直阻塞. 这时服务器线程变成为了无效线程. 非常的浪费服务器资源</p>
<h1 id="nio---单线程模型">NIO - 单线程模型</h1>
<p><code>Java.nio</code> 包下的 <code>IO</code> 模型</p>
<p>NIO 模型引用 <code>selector</code> , 可以实现用较少的线程, 甚至只需要一个线程, 就可以去处理我们的所有的客户端的请求.</p>
<img src='/image/2019-08-23-NIO.png'>
<h2 id="nio-的思想">NIO 的思想</h2>
<p>在 BIO 中, 每一个新开的线程, 会 <strong>阻塞的的等待 Client 发送信息</strong>, 这是 BIO 效率低的一个非常关键的点.</p>
<p>在 NIO 中, 我们 **引入了新的思想 : ** 三个关键思量</p>
<ul>
<li><strong>ServerSocket</strong> 此时 <strong>不会阻塞的去接受请求</strong></li>
<li><strong>有请求来了后的 Socket</strong> 不会开一个新的线程去处理, 而是放入一个 Socket 容器</li>
<li>每次循环, 都会去检查我们的 Socket 容器里的 Socket 有没有新的数据, 如果有就处理, 否则继续循环</li>
</ul>
<h2 id="nio-java-实现">NIO Java 实现</h2>
<p><strong>NIO 单线程实现 多客户端连接操作</strong></p>
<p>NIO 引入一个新的 Java API : <code>ServerSocketChannel</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 存放 SocketChannel 的容器
</span><span class="c1"></span><span class="n">List</span><span class="o">&lt;</span><span class="n">SocketChannel</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">arrayList</span><span class="o">();</span>

<span class="c1">// Java 中的 NIO API
</span><span class="c1"></span><span class="n">ServerSocketChannel</span> <span class="n">ssc</span> <span class="o">=</span> <span class="n">ServerSocketChannel</span><span class="o">.</span><span class="na">open</span><span class="o">()</span>

<span class="c1">// 绑定 ip 已经 Port 号
</span><span class="c1"></span><span class="n">ssc</span><span class="o">.</span><span class="na">bind</span><span class="o">(</span><span class="k">new</span> <span class="n">InetSocketAddress</span><span class="o">(</span><span class="n">8888</span><span class="o">);</span>

<span class="c1">// 设置为非阻塞 IO
</span><span class="c1"></span><span class="n">ssc</span><span class="o">.</span><span class="na">configureBlocking</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
         
		
         <span class="k">while</span><span class="o">(</span><span class="kc">true</span><span class="o">){</span>
             
            <span class="c1">// 非阻塞的监听
</span><span class="c1"></span>			<span class="n">SocketChannel</span> <span class="n">socketChannel</span> <span class="o">=</span> <span class="n">ssc</span><span class="o">.</span><span class="na">accept</span><span class="o">();</span>
            
             <span class="k">if</span><span class="o">(</span><span class="n">SocketChannel</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
                 <span class="c1">// 放入 SocketChannel 容器
</span><span class="c1"></span>                 <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">SocketChannel</span><span class="o">)</span>
             <span class="o">}</span>
			
            <span class="c1">// 设置为 非阻塞的 等待 Read or Write
</span><span class="c1"></span>            <span class="n">SocketChannel</span><span class="o">.</span><span class="na">configureBlocking</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
             
             <span class="k">for</span><span class="o">(</span><span class="n">SocketChannel</span> <span class="n">sc</span> <span class="o">:</span> <span class="n">list</span><span class="o">){</span>
                 <span class="c1">// 循环 list 看有没有 SocketChannel 可以读写数据
</span><span class="c1"></span>                 <span class="c1">// code ...
</span><span class="c1"></span>                 
                 
             <span class="o">}</span>
             
         <span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在这种模型中, 我 利用 <strong>Java app</strong> 自己创建且维护了一个 <code>List</code> , 然后每一次都 遍历一边整个 <code>List</code> 从而得出哪些的 <code>socketChannel</code> 有数据可以读取. 也就是说 <strong>SocketChannel 容器</strong> 是维护在 <code>Java</code> 层的 :</p>
<img src='/image/2019-09-06-basicNIO.svg'>
<h1 id="经典的-io-三模型">经典的 IO 三模型</h1>
<h1 id="一-select-模型">一. select 模型</h1>
<p>和上面的模型不同的是, select 模型的 socket 容器维护在  <code>OS</code> 内核中.</p>
<p><img src='/image/2019-09-06-select.svg' /></p>
<p>在 Java 中体现就是 <strong>SocketServerChannel + SocketServer + Selector</strong></p>
<ul>
<li>select 容器被定义与 <code>fd_size</code> 大小大约为 1024 个 <code>fd_id</code> 也就是说 <strong>一个线程下的</strong> select 模型同时最大只能去处理 1024 个连接.</li>
<li>采用 遍历整个数组的的方式去判断 哪些 连接有事件发生, 极其的损耗时间</li>
</ul>
<p>对于 <code>select / poll</code> 模型来说, 每一次轮询, 都会遍历所有的 <strong>Socket</strong> , 从而判断哪些通道有新的 <strong>IO</strong> 请求. 也就是</p>
<p>说在 <code>select / poll </code> 模型, 我们处理的时间复杂度在 <code>O(n)</code> 范围.</p>
<h1 id="二-poll-模型">二. poll 模型</h1>
<p>poll 模型 和 Select模型 非常相似. 不同的是  <strong>poll使用链表保存文件描述符, 也就没有了文件描述符大小的限制, 但是 select 的缺点依然存在</strong></p>
<h1 id="三-epoll-模型-linux">三. epoll 模型 (Linux)</h1>
<h2 id="概述">概述</h2>
<p>Linux 平台才提供 epoll 模型, 其他平台没有实现</p>
<p>Linux 平台下 epoll 的系统调用函数有 :</p>
<ul>
<li><code>epoll_create </code> : 用来创建一个 epoll <strong>文件描述符</strong></li>
<li><code>epoll_ctl </code> : 用来添加/修改/删除需要监听的文件及其时间</li>
<li><code>epoll_wait</code> : 监听描述符上的, 用户感兴趣的 IO 事件</li>
</ul>
<p><strong>epoll 模型为现阶段最高效的 IO 模型, 它的高效主要来自于</strong></p>
<ul>
<li>红黑树 + 双链表的数据结构</li>
<li><strong>回调机制 (Callback)</strong></li>
</ul>
<p>不同于 <code>select/poll</code> 模型, <code>epoll</code> 模型不会去线性扫描所有的 <code>Socket 列表</code> , 取而代之的是只对 <strong>已经做好IO装备的 Socket 进行处理</strong> , 那么如何知道哪些 <strong>Socket 已经做好了 IO 装备</strong> , 一个很重要的特性就是 <strong>回调函数</strong> , 准备 <strong>IO</strong> 的 <strong>Socket</strong> 会通过回调函数, 告诉系统哪些 <strong>Socket</strong> 已经准备好, 从而让 <strong>线程知道哪些 Socket 有 IO 请求</strong></p>
<h2 id="已知的-epoll-模型应用">已知的 epoll 模型应用</h2>
<ul>
<li>Nginx</li>
<li>Redis</li>
</ul>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">LYR</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2021-08-14
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      
      <nav class="post-nav">
        
        <a class="next" href="/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/javaio/javaio%E6%93%8D%E4%BD%9C/">
            <span class="next-text nav-default">Java IO操作</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:lyr-2000@qq.com" class="iconfont icon-email" title="email"></a>
  <a href="http://doc.lyr-2000.xyz/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021<span class="heart"><i class="iconfont icon-heart"></i></span><span>lyr</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script type="text/javascript" async src="/lib/mathjax/es5/tex-mml-chtml.js"></script>








</body>
</html>
