<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on Even - A super concise theme for Hugo</title>
    <link>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/</link>
    <description>Recent content in Java on Even - A super concise theme for Hugo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>lyr</copyright>
    <lastBuildDate>Sun, 15 Aug 2021 21:00:05 +0800</lastBuildDate><atom:link href="http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>AOP 面向切面编程</title>
      <link>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/spring/aop/</link>
      <pubDate>Sat, 14 Aug 2021 22:43:02 +0800</pubDate>
      
      <guid>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/spring/aop/</guid>
      <description>AOP 面向切面编程 [TOC] 一 概述 面向切面编程 只是一种编程范式 它是 oop 的补充, 可是实现 关注点 分离 , 一般有如下的用途 : 权限控制 缓存控制 事务控制 日志 性能监控 AOP</description>
    </item>
    
    <item>
      <title>IOCI</title>
      <link>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/spring/ioci/</link>
      <pubDate>Sat, 14 Aug 2021 22:43:02 +0800</pubDate>
      
      <guid>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/spring/ioci/</guid>
      <description>IoC 装配 与 DI [TOC] 一. IoC 和 DI IoC 即为 控制反转, 各个对象将创建对象的能力交给 IoC 容器去完成, 需要的时候, 直接从容器里面取即可. 我们将容器里面的对象叫做 组</description>
    </item>
    
    <item>
      <title>IO模型</title>
      <link>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/javaio/io%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Sat, 14 Aug 2021 22:43:02 +0800</pubDate>
      
      <guid>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/javaio/io%E6%A8%A1%E5%9E%8B/</guid>
      <description>网络IO模型 [TOC] 同步异步, 阻塞非阻塞 同步 : 在发出一个 功能调用 的时候, 在没有得到结果之前, 该调用就不返回 异步 : 在发出一个 功能调用 的时候, 不管有没</description>
    </item>
    
    <item>
      <title>Java IO操作</title>
      <link>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/javaio/javaio%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Sat, 14 Aug 2021 22:43:02 +0800</pubDate>
      
      <guid>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/javaio/javaio%E6%93%8D%E4%BD%9C/</guid>
      <description>[TOC] Java I/O 操作 Java.io 包里面的都是阻塞的 IO. 即为 BIO 也就说, 利用这个包读取的时候 线程为阻塞的 按流数据结构划分 字节流 : InputStream, outputStream 字符流 : Read , Write 对于 Java.io 的操作里面来说</description>
    </item>
    
    <item>
      <title>java 传值</title>
      <link>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/javase/java%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92%E4%B8%8E%E6%8C%89%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</link>
      <pubDate>Sat, 14 Aug 2021 22:43:02 +0800</pubDate>
      
      <guid>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/javase/java%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92%E4%B8%8E%E6%8C%89%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</guid>
      <description>[TOC] JAVA 按值传递 与 按引用传递 基本数据类型 数组 1 2 3 4 /* String[] myString 可以直接在函数修改值 */ ArrayList 容器 java 允许通过函数 来改变 ArrayList容器的值 说明 此时 Title 为</description>
    </item>
    
    <item>
      <title>java 基本数据类型</title>
      <link>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/javase/java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Sat, 14 Aug 2021 22:43:02 +0800</pubDate>
      
      <guid>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/javase/java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1/</guid>
      <description>[TOC] 基本数据类型 对象封装 Java 对基本的数据类型进行了封装 为了方便操作基本类型值, 将 基本数据类型封装 成了类, 且在对象中 定义了属性和行为丰富了该数据的</description>
    </item>
    
    <item>
      <title>java内存区域</title>
      <link>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/jvm/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</link>
      <pubDate>Sat, 14 Aug 2021 22:43:02 +0800</pubDate>
      
      <guid>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/jvm/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</guid>
      <description>Java 内存区域 [TOC] 一. 运行时内存区域 Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域 : 共享和私有 一个 Java 进程 可以包含多个 线程,</description>
    </item>
    
    <item>
      <title>java基础部分</title>
      <link>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/readme/</link>
      <pubDate>Sat, 14 Aug 2021 22:43:02 +0800</pubDate>
      
      <guid>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/readme/</guid>
      <description>Java 基础部分 Java SE Java 运行 Java 异常 反射 多态 泛型 一切皆对象 八大基本数据对象 面向对象 类初始化和方法重载 内部类 类再生 类访问控制 抽象类和接口 其他 JAVA 按值传递 与</description>
    </item>
    
    <item>
      <title>Java工具类- Map</title>
      <link>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/%E5%AE%B9%E5%99%A8/java%E5%B7%A5%E5%85%B7%E7%B1%BB-map/</link>
      <pubDate>Sat, 14 Aug 2021 22:43:02 +0800</pubDate>
      
      <guid>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/%E5%AE%B9%E5%99%A8/java%E5%B7%A5%E5%85%B7%E7%B1%BB-map/</guid>
      <description>[TOC] Java 工具类-Map 一. 概述 Key =&amp;gt; Value的存储结构 : 给定一个键和一个值，你可以将该值存储在一个Map对象. 之后，你可以通过键来访问对应的值。</description>
    </item>
    
    <item>
      <title>Java工具类-集合</title>
      <link>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/%E5%AE%B9%E5%99%A8/java%E5%B7%A5%E5%85%B7%E7%B1%BB-%E9%9B%86%E5%90%88/</link>
      <pubDate>Sat, 14 Aug 2021 22:43:02 +0800</pubDate>
      
      <guid>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/%E5%AE%B9%E5%99%A8/java%E5%B7%A5%E5%85%B7%E7%B1%BB-%E9%9B%86%E5%90%88/</guid>
      <description>[TOC] Java 工具类-集合 一. 概述 集合是 用于 存储对象 的容器, 注意, 存放的为 对象的地址 集合是一个 动态大小的容器, 即长度可变 集合可以 添加不同的对象 1 2 3 4</description>
    </item>
    
    <item>
      <title>java异常</title>
      <link>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/javase/java%E5%BC%82%E5%B8%B8/</link>
      <pubDate>Sat, 14 Aug 2021 22:43:02 +0800</pubDate>
      
      <guid>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/javase/java%E5%BC%82%E5%B8%B8/</guid>
      <description>java 异常 [TOC] 一. 异常概述 什么是异常? java程序运行时期发生的不正常的情况 注意编译器并不会因为异常报错 异常就是java封装的专门用于异常问题处理</description>
    </item>
    
    <item>
      <title>java类加载</title>
      <link>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/jvm/java%E7%B1%BB%E5%8A%A0%E8%BD%BD/</link>
      <pubDate>Sat, 14 Aug 2021 22:43:02 +0800</pubDate>
      
      <guid>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/jvm/java%E7%B1%BB%E5%8A%A0%E8%BD%BD/</guid>
      <description>[TOC] JVM JVM 可以不只运行 Java 文件, 而是可以运行所有的 可以编译成字节码文件的 语言 虚拟机的实现不只一种, 我们最常用的为 HotSpot 虚拟机 JVM 结束生命周期: 执行了 System.exit(); 正</description>
    </item>
    
    <item>
      <title>java访问控制</title>
      <link>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/javase/java%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Sat, 14 Aug 2021 22:43:02 +0800</pubDate>
      
      <guid>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/javase/java%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</guid>
      <description>JAVA访问控制 1. java 数据成员访问指示符 分为 public, protected, private, 友好的 四大类, 与c++不同, java类的每一个数据成员都必须有指示一个标识符. 1. 1 友好的 如果</description>
    </item>
    
    <item>
      <title>java运行</title>
      <link>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/javase/%E5%85%B3%E4%BA%8Ejava%E8%BF%90%E8%A1%8C/</link>
      <pubDate>Sat, 14 Aug 2021 22:43:02 +0800</pubDate>
      
      <guid>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/javase/%E5%85%B3%E4%BA%8Ejava%E8%BF%90%E8%A1%8C/</guid>
      <description>关于java 运行 ###1. .java 和 .class 文件 .java 是自己(开发者)编写的源文件 .class 是通过编译 .java 文件之后生成的文件 Tips : **java 程序的运行依赖于虚拟机(JVM),这也是ja</description>
    </item>
    
    <item>
      <title>JDBC</title>
      <link>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/jdbc/jdbc/</link>
      <pubDate>Sat, 14 Aug 2021 22:43:02 +0800</pubDate>
      
      <guid>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/jdbc/jdbc/</guid>
      <description>JDBC [TOC] 一. 概述 JDBC (Java DataBase Connection) 是 Java开发的数据库的统一的接口, 对于不同的 database 使用统一的接口 即可. 本质上 : JDBC 是官方定义的 一套操作所有 关系型数据库 的规则</description>
    </item>
    
    <item>
      <title>Math类</title>
      <link>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/%E5%85%B6%E4%BB%96%E7%B1%BB/math/</link>
      <pubDate>Sat, 14 Aug 2021 22:43:02 +0800</pubDate>
      
      <guid>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/%E5%85%B6%E4%BB%96%E7%B1%BB/math/</guid>
      <description>Java Math 数学类 一: 取根号: Math.sqrt()</description>
    </item>
    
    <item>
      <title>Mybatis</title>
      <link>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/mybatis/mybatis/</link>
      <pubDate>Sat, 14 Aug 2021 22:43:02 +0800</pubDate>
      
      <guid>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/mybatis/mybatis/</guid>
      <description>Spring 持久层 一. 数据库 数据源配置 I. 数据库连接池的数据源配置 II. 基于 JDBC 驱动的数据源 二. Spring 的持久层操作 (JDBC) Spring 中使用 模版JDBC 利用 JDBC 模版 插入数据 MyBatis 框架 一</description>
    </item>
    
    <item>
      <title>Runtime类</title>
      <link>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/%E5%85%B6%E4%BB%96%E7%B1%BB/runtime/</link>
      <pubDate>Sat, 14 Aug 2021 22:43:02 +0800</pubDate>
      
      <guid>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/%E5%85%B6%E4%BB%96%E7%B1%BB/runtime/</guid>
      <description>Java Runtime 类 这个类 可以直接在 java 程序里面进行 系统命令调用 e.g. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 try { /* Java 调用 py 文件 */ InputStream ip = Runtime.getRuntime().exec (&amp;#34;python3test.py&amp;#34;).getInputStream(); byte[] buffer = new byte[1024]; int len</description>
    </item>
    
    <item>
      <title>String</title>
      <link>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/%E5%85%B6%E4%BB%96%E7%B1%BB/string/</link>
      <pubDate>Sat, 14 Aug 2021 22:43:02 +0800</pubDate>
      
      <guid>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/%E5%85%B6%E4%BB%96%E7%B1%BB/string/</guid>
      <description>[TOC] 一. 字符串的不可变性 字符串对象 一旦初始化就不可以被改变 , 例如 : 🌟 字符串对象的不变性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* 此时 &amp;#34;abc&amp;#34; 为一个字符串</description>
    </item>
    
    <item>
      <title>一切皆对象</title>
      <link>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/javase/%E4%B8%80%E5%88%87%E7%9A%86%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Sat, 14 Aug 2021 22:43:02 +0800</pubDate>
      
      <guid>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/javase/%E4%B8%80%E5%88%87%E7%9A%86%E5%AF%B9%E8%B1%A1/</guid>
      <description>[TOC] Java对象的根类 Object Object: Java的上帝类 java中所有的类都是继承于一个特殊的类 : object 1 2 3 4 5 6 7 8 9 class A{ } // 其实是下面的省略写法 // 即其实A</description>
    </item>
    
    <item>
      <title>内部类</title>
      <link>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/javase/%E5%86%85%E9%83%A8%E7%B1%BB/</link>
      <pubDate>Sat, 14 Aug 2021 22:43:02 +0800</pubDate>
      
      <guid>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/javase/%E5%86%85%E9%83%A8%E7%B1%BB/</guid>
      <description>[TOC] 内部类 什么是内部类? 将一个类定义在另一个类里面, 则对里面的类就称为内部类. 在访问特点上 内部类可以直接去访问外部类的成员, 即使是私有成员 外部</description>
    </item>
    
    <item>
      <title>反射</title>
      <link>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/javase/%E5%8F%8D%E5%B0%84/</link>
      <pubDate>Sat, 14 Aug 2021 22:43:02 +0800</pubDate>
      
      <guid>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/javase/%E5%8F%8D%E5%B0%84/</guid>
      <description>反射 [TOC] 一. 什么是反射 将 类的各个组成部分 封装为 对应Class对象的各个字段 行为就是反射机制 将 每一个类 .class 文件的描述一个类型的信息 封装成一个对象 !!</description>
    </item>
    
    <item>
      <title>垃圾回收机制</title>
      <link>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Sat, 14 Aug 2021 22:43:02 +0800</pubDate>
      
      <guid>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</guid>
      <description>垃圾回收机制 [TOC] Java 内存回收主要围绕以下流程展开: 一. 揭开 JVM 内存分配与回收神秘面纱 Java 的自动内存管理 最核心的内容 是针对 堆中对象 的分配与回收 Java 堆是垃</description>
    </item>
    
    <item>
      <title>多态</title>
      <link>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/javase/%E5%A4%9A%E6%80%81/</link>
      <pubDate>Sat, 14 Aug 2021 22:43:02 +0800</pubDate>
      
      <guid>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/javase/%E5%A4%9A%E6%80%81/</guid>
      <description>[TOC] 多态 Java 程序设计的的三大特性: 松耦合 : 降低类与类之间的联系 高内聚 : 一个模块只实现一个单一的功能 紧封装 : 成员变量最好作为私有, 通过公有的方法进</description>
    </item>
    
    <item>
      <title>多线程</title>
      <link>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/%E5%B9%B6%E5%8F%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Sat, 14 Aug 2021 22:43:02 +0800</pubDate>
      
      <guid>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/%E5%B9%B6%E5%8F%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</guid>
      <description>多线程 [TOC] 一. 进程和线程 进程 进程是 资源分配 的基本单位 进程不直接执行, 而只是获得分配计算机的相关资源 线程 线程是 独立调度 的基本单位 而线程是在进程的</description>
    </item>
    
    <item>
      <title>多线程面试易问</title>
      <link>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/%E5%B9%B6%E5%8F%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E6%98%93%E9%97%AE/</link>
      <pubDate>Sat, 14 Aug 2021 22:43:02 +0800</pubDate>
      
      <guid>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/%E5%B9%B6%E5%8F%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E6%98%93%E9%97%AE/</guid>
      <description>多线程面试易问 [TOC] 说说线程的生命周期和状态? 由上图可以看出：线程创建之后它将处于 NEW（新建） 状态，调用 start() 方法后开始运行，线程这时候处于 REA</description>
    </item>
    
    <item>
      <title>容器高阶</title>
      <link>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/%E5%AE%B9%E5%99%A8/%E5%AE%B9%E5%99%A8%E9%AB%98%E9%98%B6/</link>
      <pubDate>Sat, 14 Aug 2021 22:43:02 +0800</pubDate>
      
      <guid>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/%E5%AE%B9%E5%99%A8/%E5%AE%B9%E5%99%A8%E9%AB%98%E9%98%B6/</guid>
      <description>容器高阶 list , Set, Map区别 Arraylist 与 LinkedList 区别? ArrayList 与 Vector 区别呢?为什么要用Arraylist取代Vector呢？ HashMap 的存储过程 JDK1.8之前 JDK1.8之</description>
    </item>
    
    <item>
      <title>抽象类和接口</title>
      <link>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/javase/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Sat, 14 Aug 2021 22:43:02 +0800</pubDate>
      
      <guid>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/javase/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/</guid>
      <description>[TOC] 抽象类 和 接口 抽象类 为什么要衍生出抽象类? 联系到上一节的类多态, 基类被子类重写(override)的方法其实只是起一个规范的作用, 我们并不会</description>
    </item>
    
    <item>
      <title>泛型</title>
      <link>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/javase/%E6%B3%9B%E5%9E%8B/</link>
      <pubDate>Sat, 14 Aug 2021 22:43:02 +0800</pubDate>
      
      <guid>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/javase/%E6%B3%9B%E5%9E%8B/</guid>
      <description>泛型 OverView JDK 1.5 (5.0) 以后开始引入 泛型, 是一种 安全性机制 早期容器没有泛型机制, 所以统一接受的 Object 类型, 很容易造成 ClassCastException 异常 1 2 3 4 5 6 7 8 9 10 11 /* 使得 ArrayList 只能</description>
    </item>
    
    <item>
      <title>琐碎问题集合</title>
      <link>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/%E7%90%90%E7%A2%8E%E9%97%AE%E9%A2%98%E9%9B%86%E5%90%88/</link>
      <pubDate>Sat, 14 Aug 2021 22:43:02 +0800</pubDate>
      
      <guid>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/%E7%90%90%E7%A2%8E%E9%97%AE%E9%A2%98%E9%9B%86%E5%90%88/</guid>
      <description>琐碎问题集合 [TOC] ==, hashCode, equals 对于所有的对象来说, == 都是直接比较的两个对象的地址 1 2 3 4 5 6 7 8 9 10 11 /* == */ string a = &amp;#34;123&amp;#34;; string b = &amp;#34;123&amp;#34;; string c = new string(a); // true; sout(a == b); // false sout(a</description>
    </item>
    
    <item>
      <title>类再生</title>
      <link>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/javase/%E7%B1%BB%E5%86%8D%E7%94%9F/</link>
      <pubDate>Sat, 14 Aug 2021 22:43:02 +0800</pubDate>
      
      <guid>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/javase/%E7%B1%BB%E5%86%8D%E7%94%9F/</guid>
      <description>[TOC] 类再生(合成与继承) 1. 类的合成 所谓类的合成就是在一个类中加入另外已经存在的类. 只需要在新类简单的置入对象的句柄即可 例如: 一个汽车类便可以由</description>
    </item>
    
    <item>
      <title>类初始化</title>
      <link>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/javase/%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%87%8D%E8%BD%BD/</link>
      <pubDate>Sat, 14 Aug 2021 22:43:02 +0800</pubDate>
      
      <guid>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/javase/%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%87%8D%E8%BD%BD/</guid>
      <description>类初始化和重载 1. 类的初始化构造函数 和c++一样, java中类的构造函数名就是类名 构造函数没有返回值, 且与void返回值有明显的区别 当对象没有</description>
    </item>
    
    <item>
      <title>线程池</title>
      <link>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</link>
      <pubDate>Sat, 14 Aug 2021 22:43:02 +0800</pubDate>
      
      <guid>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</guid>
      <description>[TOC] 线程池概述 线程池简单来说就是一个负责 协调, 管理 众多 线程的一个容器. 创造出线程池这样一个容器的 目的 是 : 在线程的使用中, 线程的频繁的 创建 或者 销</description>
    </item>
    
    <item>
      <title>高并发JUC</title>
      <link>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/%E5%B9%B6%E5%8F%91/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%8C%85juc/</link>
      <pubDate>Sat, 14 Aug 2021 22:43:02 +0800</pubDate>
      
      <guid>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/%E5%B9%B6%E5%8F%91/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%8C%85juc/</guid>
      <description>[TOC] 锁的类型 互斥锁 mutex 任意一个时刻, 都只能有一个现象访问该对象 常见的互斥锁有 : synchronized 底层的互斥信号量 ReentrantLock 读写锁 rwlock 分为读锁和写锁。处于读操作时，可以允许</description>
    </item>
    
    <item>
      <title></title>
      <link>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/spring/iocii/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/spring/iocii/</guid>
      <description>Spring [TOC] 一. 概述 二 .IOC 控制反转原理 IOC : 控制反转, 指创建对象的权利交给对象 .包括了 依赖注入 和 依赖查找 IOC 的主要作用是用来 减少 我们的项目给类之间的依赖的</description>
    </item>
    
    <item>
      <title></title>
      <link>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/springmvc/springmvc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/springmvc/springmvc/</guid>
      <description>[TOC] 一. 基本配置 web.xml文件 : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 &amp;lt;servlet&amp;gt; &amp;lt;servlet-name&amp;gt;dispatcher&amp;lt;/servlet-name&amp;gt; &amp;lt;servlet-class&amp;gt;org.springframework.web.servlet.DispatcherServlet&amp;lt;/servlet-class&amp;gt; &amp;lt;!-- 定义和我们的SpringMVC.xml 绑定 --&amp;gt; &amp;lt;init-param&amp;gt; &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt; &amp;lt;param-value&amp;gt;classpath:springMVC.xml&amp;lt;/param-value&amp;gt; &amp;lt;/init-param&amp;gt; &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt; &amp;lt;/servlet&amp;gt; &amp;lt;!-- 配置拦</description>
    </item>
    
    <item>
      <title></title>
      <link>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/springmvc/springmvc%E5%90%AF%E5%8A%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/springmvc/springmvc%E5%90%AF%E5%8A%A8/</guid>
      <description>[TOC] SpringMVC 详解 一. 构建 SpringMVC 利用 JavaConifg 类代替 XML 文件 利用 SpringMVC 构建的 WEB 项目中, 一般有三个 XML 文件位于 WEB-INF下 : web.xml , dispatcher-servlet.xml , applicationContext.xml, 但是在 Servlet3.0 规范中, 我们使用 JavaConfig 替代所有</description>
    </item>
    
  </channel>
</rss>
