<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>垃圾回收机制 - Even - A super concise theme for Hugo</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="LYR" /><meta name="description" content="垃圾回收机制 [TOC] Java 内存回收主要围绕以下流程展开: 一. 揭开 JVM 内存分配与回收神秘面纱 Java 的自动内存管理 最核心的内容 是针对 堆中对象 的分配与回收 Java 堆是垃" /><meta name="keywords" content="LYR的文档站, LYR的个人博客, even" />






<meta name="generator" content="Hugo 0.86.0 with theme even" />


<link rel="canonical" href="http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.b5a744db6de49a86cadafb3b70f555ab443f83c307a483402259e94726b045ff.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="垃圾回收机制" />
<meta property="og:description" content="垃圾回收机制 [TOC] Java 内存回收主要围绕以下流程展开: 一. 揭开 JVM 内存分配与回收神秘面纱 Java 的自动内存管理 最核心的内容 是针对 堆中对象 的分配与回收 Java 堆是垃" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-08-14T22:43:02+08:00" />
<meta property="article:modified_time" content="2021-08-14T22:43:02+08:00" />

<meta itemprop="name" content="垃圾回收机制">
<meta itemprop="description" content="垃圾回收机制 [TOC] Java 内存回收主要围绕以下流程展开: 一. 揭开 JVM 内存分配与回收神秘面纱 Java 的自动内存管理 最核心的内容 是针对 堆中对象 的分配与回收 Java 堆是垃"><meta itemprop="datePublished" content="2021-08-14T22:43:02+08:00" />
<meta itemprop="dateModified" content="2021-08-14T22:43:02+08:00" />
<meta itemprop="wordCount" content="2128">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="垃圾回收机制"/>
<meta name="twitter:description" content="垃圾回收机制 [TOC] Java 内存回收主要围绕以下流程展开: 一. 揭开 JVM 内存分配与回收神秘面纱 Java 的自动内存管理 最核心的内容 是针对 堆中对象 的分配与回收 Java 堆是垃"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">LYR的文档站</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">首页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档页</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a><a href="/friends">
        <li class="mobile-menu-item">大佬</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">LYR的文档站</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">首页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/friends">大佬</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">垃圾回收机制</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-08-14 </span>
        
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#垃圾回收机制">垃圾回收机制</a></li>
    <li><a href="#一-揭开-jvm-内存分配与回收神秘面纱">一. 揭开 JVM 内存分配与回收神秘面纱</a></li>
    <li><a href="#二-如何判断对象已经死亡">二. 如何判断对象已经死亡</a>
      <ul>
        <li><a href="#21-引用计数法">2.1 引用计数法</a></li>
        <li><a href="#22-根搜索算法可达性算法">2.2 根搜索算法(可达性算法)</a></li>
      </ul>
    </li>
    <li><a href="#三-如何收集已死亡对象-gc-算法">三. 如何收集已死亡对象 (GC 算法)</a>
      <ul>
        <li><a href="#31-标记-清除算法">3.1 标记-清除算法</a></li>
        <li><a href="#32-标记-整理算法">3.2 标记-整理算法</a></li>
        <li><a href="#33-复制算法">3.3 复制算法</a></li>
        <li><a href="#34-分代收集算法">3.4 分代收集算法</a>
          <ul>
            <li><a href="#新生代">新生代</a></li>
            <li><a href="#老年代">老年代</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#四-垃圾收集器-gc-tools">四. 垃圾收集器 (GC Tools)</a>
      <ul>
        <li><a href="#41-serial-收集器">4.1 Serial 收集器</a></li>
        <li><a href="#42-parnew-收集器">4.2 ParNew 收集器</a></li>
        <li><a href="#43-cms-收集器">4.3 CMS 收集器</a></li>
        <li><a href="#44-g1-收集器">4.4 G1 收集器</a></li>
      </ul>
    </li>
    <li><a href="#常量池垃圾回收机制">常量池垃圾回收机制</a></li>
    <li><a href="#内存泄漏与内存溢出">内存泄漏与内存溢出</a>
      <ul>
        <li><a href="#内存泄漏的各种情况">内存泄漏的各种情况</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h1 id="垃圾回收机制">垃圾回收机制</h1>
<p>[TOC]</p>
<p>Java 内存回收主要围绕以下流程展开:</p>
<p><img src="https://camo.githubusercontent.com/0e9d71264db3f2fb98b08426bc07e41a4750fb47/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d382d32362f32393137363332352e6a7067" alt="img"></p>
<h1 id="一-揭开-jvm-内存分配与回收神秘面纱">一. 揭开 JVM 内存分配与回收神秘面纱</h1>
<p>Java 的自动内存管理 <strong>最核心的内容</strong> 是针对 <strong>堆中对象</strong> 的分配与回收</p>
<p>Java 堆是垃圾收集器管理的主要区域, 因此也被称为 <strong>GC(Garbage Collected Heap) 堆</strong>, 针对与垃圾回收机制,</p>
<p>Java堆空间 还可以被分为 :</p>
<ul>
<li>新生代
<ul>
<li>Eden 空间</li>
<li>From Survivor</li>
<li>To Survivor</li>
</ul>
</li>
<li>老年代
<ul>
<li>Tentired</li>
</ul>
</li>
</ul>
<h1 id="二-如何判断对象已经死亡">二. 如何判断对象已经死亡</h1>
<p>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断那些对象已经死亡（即不能再被任何途径使用的对象。</p>
<h2 id="21-引用计数法">2.1 引用计数法</h2>
<p>给对象加一个引用计数器, 如果有一个地方引用该对象, 那么计数器加1. 如果引用实效, 那么计数器减1. 如果一个对象的引用技术器为 0, 那么表示对象不能再被使用.</p>
<p><strong>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题</strong></p>
<p>什么是 <strong>循环引用 ?</strong></p>
<p>比如 ObjA 和 ObjB 相互引用对方, 但是没有了其他的引用, 这样会导致 A, B 不会被回收 For Example:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ReferenceCountingGc</span><span class="o">{</span>
 	<span class="n">Object</span> <span class="n">instance</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
    	<span class="n">ReferenceCountingGc</span> <span class="n">objA</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ReferenceCountingGc</span><span class="o">();</span>
        <span class="n">ReferenceCountingGc</span> <span class="n">objB</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ReferenceCountingGc</span><span class="o">();</span>
        <span class="c1">// 对象内部相互引用
</span><span class="c1"></span>        <span class="n">objA</span><span class="o">.</span><span class="na">instance</span> <span class="o">=</span> <span class="n">objB</span><span class="o">;</span>
        <span class="n">objB</span><span class="o">.</span><span class="na">instance</span> <span class="o">=</span> <span class="n">objA</span><span class="o">;</span>
        <span class="c1">// 释放引用
</span><span class="c1"></span>        <span class="n">objA</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="n">objB</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="22-根搜索算法可达性算法">2.2 根搜索算法(可达性算法)</h2>
<p>核心思想是通过一系列的称为 <strong>&ldquo;GC ROOTS&rdquo;</strong> 的对象作为起点 ,然后向下搜索, 所有可达的对象证明为仍然存活的对象, 反之为可回收的对象</p>
<p><img src="https://camo.githubusercontent.com/6c6a9c7e2a7849cab8d5966ec1916115380e2842/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d382d32372f37323736323034392e6a7067" alt="å¯è¾¾æ§åæç®æ³ "></p>
<p><code>Java</code> 中可作为 <code>GC Root</code> 的对象：</p>
<ul>
<li>虚拟机栈中引用的对象（本地变量表）</li>
<li>方法区中静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中引用的对象（Native对象）</li>
</ul>
<h1 id="三-如何收集已死亡对象-gc-算法">三. 如何收集已死亡对象 (GC 算法)</h1>
<p>在确定了哪些垃圾可以被回收后，垃圾收集器要做的就是进行垃圾的回收，有下面的几种算法：</p>
<h2 id="31-标记-清除算法">3.1 标记-清除算法</h2>
<p>该算法分为 &ldquo;标记&rdquo; 阶段 和 &ldquo;清除&rdquo; 阶段.</p>
<p>&ldquo;标记&rdquo; 阶段就是标示出我们不用的对象 然后再 &ldquo;清除&rdquo; 阶段进行清除</p>
<p><img src="https://camo.githubusercontent.com/dc1f798e7c7f9aa9a3ab692db10a6b1788e5d505/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d382d32372f36333730373238312e6a7067" alt="å¬ä¼å·"></p>
<p>该算法实现较为简单, 直接收回, 不移动</p>
<p>所以, 很容易造成以下的问题 :</p>
<ol>
<li>效率低下</li>
<li>空间回收后碎片太多</li>
</ol>
<h2 id="32-标记-整理算法">3.2 标记-整理算法</h2>
<p>结合前两个的优点.</p>
<p>标记过程和 &ldquo;标记-清除&rdquo; 算法一样, 但是后续不是直接对 不可用对象进行回收</p>
<p>而是让所有的可用对象, 移动向另外一端, 然后直接清理掉端边界以外的内存</p>
<p><img src="https://camo.githubusercontent.com/e5223ec7b2460498e1934c14eeaf969bafdcab59/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d382d32372f39343035373034392e6a7067" alt="æ è®°-æ´çç®æ³ "></p>
<p>优点 : 解决内存碎片问题</p>
<p>缺点 : 代价比较大</p>
<h2 id="33-复制算法">3.3 复制算法</h2>
<p>为了解决效率问题, 我们引进了 <strong>复制算法</strong></p>
<p>我们将内存分为两块, 然后每次使用其中的一块, <strong>每当这一块使用完之后, 就将还存活的对象复制到另一块.</strong></p>
<p>从而清除的时候可以将这一半空间整个回收, 增加了效率</p>
<p><img src="https://camo.githubusercontent.com/94cfc5e1fbe9d49b3ed056d2943fd86dac1833a2/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d382d32372f39303938343632342e6a7067" alt="å¬ä¼å·"></p>
<ul>
<li>优点 : 实现简单, 不易产生内存碎片, 每次只需要对半个区进行内存回收</li>
<li>缺点 : <strong>内存缩减为原来的一半</strong>, 且可存活对象越多, 效率越低</li>
</ul>
<h2 id="34-分代收集算法">3.4 分代收集算法</h2>
<p><strong>现在大部分虚拟机采用的算法(包括HotSpot)</strong></p>
<p>我们将堆内的内存分为不同的区域 (新生代, 老年代), 然后根据 <strong>不同的区域采取不同的回收策略</strong></p>
<p><img src='/image/2018-08-06-GC.png' /></p>
<p>可以看到, <strong>当前主流的 GC 算法中, 将Heap内存分为两个区</strong></p>
<ul>
<li>新生代</li>
<li>老年代</li>
</ul>
<h3 id="新生代">新生代</h3>
<p>也可以细分为三个区, 容量比为  <code>S0 : S1 : E = 1 : 1 : 8</code></p>
<p>E区 : 每次新对象的 <strong>出生点</strong></p>
<p><strong>当 E区满了之后</strong>, 会触发一次 <code>YoungGC</code>  基于的是 <code>复制算法</code></p>
<ol>
<li>将 E + S0 区的所有存活元素 移动到 S1区, 所有对象年龄 +1</li>
<li>清空 E + S0 区</li>
</ol>
<p>下次 <strong>E区满了之后</strong>, 又会触发一次 <code>YoungGC</code> :</p>
<ol>
<li>将 E + S1 区的所有存活元素 移动到 S0区, 所有对象年龄 +1</li>
<li>清空 E + S1 区</li>
</ol>
<p>当检测到对象的 Age &gt; 6 之后, 将该对象移动到 老年代中</p>
<h3 id="老年代">老年代</h3>
<p>老年代只有一个区域, 存放大对象 (e.g. 大数组对象, Age&gt;6 的对象)</p>
<p>当老年代内存满了之后, 触发 <code>OldGC</code> , 且会伴随 <code>YoungGC</code>的到来. 因此也叫:  <code>fullGC</code></p>
<p>此时会带来 <code>Stop The World</code> , 也就是说所有的 Java 程序停止, 全面执行垃圾回收工作</p>
<p><code>oldGC</code> 主要采用的为 <code>标记-清理/标记-整理</code> 的算法</p>
<h1 id="四-垃圾收集器-gc-tools">四. 垃圾收集器 (GC Tools)</h1>
<p><code>GC tools</code> 就是以上手机算法的 <code>具体实现了</code></p>
<p>目前还不存在一个完美的 垃圾回收器, 所以 <code>HotSpot</code> 实现了很多种垃圾收集器给我们选择</p>
<h2 id="41-serial-收集器">4.1 Serial 收集器</h2>
<p><img src="https://camo.githubusercontent.com/aba41c5c08ea9884554b9a69ea69c7ceeebc83ff/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d382d32372f34363837333032362e6a7067" alt=" Serial æ¶éå¨ "></p>
<p><code>单线程</code></p>
<p><code>Stop the World</code></p>
<p><code>新生代 : 复制</code></p>
<p><code>老年代 : 标记 - 整理</code></p>
<p><code>简单高效</code></p>
<h2 id="42-parnew-收集器">4.2 ParNew 收集器</h2>
<p><img src="https://camo.githubusercontent.com/f298ba56ec4667487fdf4acc987f2ef9e6df254e/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d382d32372f32323031383336382e6a7067" alt="ParNew æ¶éå¨ "></p>
<p><code>Seriral 的多线程版本</code></p>
<p><code>Stop the World</code></p>
<p><code>新生代 : 复制</code></p>
<p><code>老年代 : 标记 - 整理</code></p>
<h2 id="43-cms-收集器">4.3 CMS 收集器</h2>
<p>高并发、低停顿，追求最短 <code>GC</code> 回收停顿时间，<code>cpu</code> 占用比较高，响应时间快，停顿时间短，多核 <code>cpu</code> 追求高响应时间的选择</p>
<h2 id="44-g1-收集器">4.4 G1 收集器</h2>
<h1 id="常量池垃圾回收机制">常量池垃圾回收机制</h1>
<p>常量池的 <strong>GC</strong> 类似于普通变量的 <strong>GC</strong></p>
<p>在垃圾回收的时候, 如果没有一个指向常量池的饮用, 那么该常量被 GC</p>
<h1 id="内存泄漏与内存溢出">内存泄漏与内存溢出</h1>
<ul>
<li>内存泄漏 (memory leak) : 指一个确定不再被使用的对象, 仍然使用的 <strong>JVM</strong> 空间, 这种情况叫做内存泄漏</li>
<li>内存溢出 (out of memory) OOM : 值 <strong>JVM</strong> 没有足够的内存去给一个新的对象进行分配了</li>
</ul>
<h2 id="内存泄漏的各种情况">内存泄漏的各种情况</h2>
<ol>
<li>
<p>**静态的容器 : **  静态变量在类加载的时候, 便被放到了方法区, <strong>生命周期为 JVM 的生命周期</strong> 从而造成了内存泄漏</p>
</li>
<li>
<p>**各种连接 : ** 如数据库连接,  网络连接, IO连接等. 这些连接如果不关闭, 则不会被 <strong>GC</strong> 回收, 所以如果没有显现的关闭各类连接, 会造成大量的对象无法被回收, 从而引起内存泄漏</p>
</li>
<li>
<p>**不合理的作用域 : ** 如果变量的作用域大于起使用范围, 则很有可能造成内存泄漏, 比如 :</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="cm">/*
</span><span class="cm">	e.g.for 内存泄漏
</span><span class="cm">*/</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MemLeaking</span><span class="o">{</span>

    <span class="kd">private</span> <span class="n">String</span> <span class="n">msg</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">receiveMsg</span><span class="o">(){</span>

        <span class="n">readFromNet</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span>
        <span class="n">saveDB</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span>


</code></pre></td></tr></table>
</div>
</div><p>可以看到, <strong>msg</strong> 在方法内部使用完后, 就没用了, 但是由于 <strong>MSG 的生命周期和整个对象一样, 所以在用完 msg 后还不能回收, 这就导致了 内存泄漏</strong></p>
</li>
<li>
<p>改变 <strong>HASH值</strong>, 比如将一个对象存入了容器后, 重写了该对象的 <strong>hashCode</strong> 那么此时容器里面的某个对象遍永远不会被找到了, 从而造成了内存泄漏</p>
</li>
</ol>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">LYR</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2021-08-14
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      
      <nav class="post-nav">
        <a class="prev" href="/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/jvm/java%E7%B1%BB%E5%8A%A0%E8%BD%BD/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">java类加载</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:lyr-2000@qq.com" class="iconfont icon-email" title="email"></a>
  <a href="http://doc.lyr-2000.xyz/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021<span class="heart"><i class="iconfont icon-heart"></i></span><span>lyr</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>








</body>
</html>
