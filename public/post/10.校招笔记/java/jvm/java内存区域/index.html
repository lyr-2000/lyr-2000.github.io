<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>java内存区域 - Even - A super concise theme for Hugo</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="LYR" /><meta name="description" content="Java 内存区域 [TOC] 一. 运行时内存区域 Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域 : 共享和私有 一个 Java 进程 可以包含多个 线程," /><meta name="keywords" content="LYR的文档站, LYR的个人博客, even" />






<meta name="generator" content="Hugo 0.86.0 with theme even" />


<link rel="canonical" href="http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/jvm/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.b5a744db6de49a86cadafb3b70f555ab443f83c307a483402259e94726b045ff.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="java内存区域" />
<meta property="og:description" content="Java 内存区域 [TOC] 一. 运行时内存区域 Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域 : 共享和私有 一个 Java 进程 可以包含多个 线程," />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/jvm/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-08-14T22:43:02+08:00" />
<meta property="article:modified_time" content="2021-08-14T22:43:02+08:00" />

<meta itemprop="name" content="java内存区域">
<meta itemprop="description" content="Java 内存区域 [TOC] 一. 运行时内存区域 Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域 : 共享和私有 一个 Java 进程 可以包含多个 线程,"><meta itemprop="datePublished" content="2021-08-14T22:43:02+08:00" />
<meta itemprop="dateModified" content="2021-08-14T22:43:02+08:00" />
<meta itemprop="wordCount" content="3528">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="java内存区域"/>
<meta name="twitter:description" content="Java 内存区域 [TOC] 一. 运行时内存区域 Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域 : 共享和私有 一个 Java 进程 可以包含多个 线程,"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">LYR的文档站</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">首页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档页</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a><a href="/friends">
        <li class="mobile-menu-item">大佬</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">LYR的文档站</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">首页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/friends">大佬</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">java内存区域</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-08-14 </span>
        
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#java-内存区域">Java 内存区域</a></li>
    <li><a href="#一-运行时内存区域">一. 运行时内存区域</a>
      <ul>
        <li><a href="#共享和私有">共享和私有</a></li>
        <li><a href="#线程私有">线程私有</a>
          <ul>
            <li><a href="#程序计数器">程序计数器</a></li>
            <li><a href="#虚拟机栈">虚拟机栈</a></li>
            <li><a href="#本地方法栈">本地方法栈</a></li>
          </ul>
        </li>
        <li><a href="#线程共享">线程共享</a>
          <ul>
            <li><a href="#堆-heap">堆 (Heap)</a></li>
            <li><a href="#方法区-non---heap">方法区 (Non - heap)🌟</a></li>
            <li><a href="#直接内存">直接内存</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#二-hotspot-虚拟机对象创建过程">二. HotSpot 虚拟机对象创建过程</a>
      <ul>
        <li><a href="#1-类的加载">1. 类的加载</a></li>
        <li><a href="#2-分配内存">2. 分配内存</a></li>
        <li><a href="#3-初始化零值">3. 初始化零值</a></li>
        <li><a href="#4-设置对象头">4. 设置对象头</a></li>
        <li><a href="#5执行-init-方法">5.执行 init 方法</a></li>
      </ul>
    </li>
    <li><a href="#三-实例对象内存布局">三. 实例对象内存布局</a>
      <ul>
        <li><a href="#对象的访问定位">对象的访问定位</a></li>
      </ul>
    </li>
    <li><a href="#四常量池">四.常量池</a>
      <ul>
        <li><a href="#string-常量池">String 常量池</a>
          <ul>
            <li><a href="#-和-new">= 和 new</a></li>
            <li><a href="#拼接">拼接</a></li>
            <li><a href="#string-s1--new-stringabc这句话创建了几个字符串对象">String s1 = new String(&ldquo;abc&rdquo;);这句话创建了几个字符串对象？</a></li>
          </ul>
        </li>
        <li><a href="#八种基本类型的包装类和常量池">八种基本类型的包装类和常量池</a></li>
        <li><a href="#八种基本类型的本类">八种基本类型的本类</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h1 id="java-内存区域">Java 内存区域</h1>
<p>[TOC]</p>
<h1 id="一-运行时内存区域">一. 运行时内存区域</h1>
<p>Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域 :</p>
<img src ='https://camo.githubusercontent.com/a66819fd82c6adfa69b368edf3c52b1fa9cdc89d/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d332f4a564de8bf90e8a18ce697b6e695b0e68daee58cbae59f9f2e706e67' style='width:600px'/>
<h2 id="共享和私有">共享和私有</h2>
<p>一个 Java 进程 可以包含多个 线程, 所以内存角度上看, 分为 : 线程共有的区域 和 线程私有的区域</p>
<p>线程共享的区域</p>
<ul>
<li>堆</li>
<li>方法区</li>
<li>直接内存</li>
</ul>
<p>线程私有的区域</p>
<ul>
<li>程序计数器</li>
<li>(VM)虚拟机栈</li>
<li>本地方法栈</li>
</ul>
<h2 id="线程私有">线程私有</h2>
<h3 id="程序计数器">程序计数器</h3>
<p>程序计数器, 是当前线程所执行的字节码的行为指示器, 也就是说, 它是用来指示当前的线程该运行那一条命令的, 注意它存储的不是命令本身.</p>
<p>字节码解释器工作的时候, 是通过 <strong>改变这个技术器的值</strong>, 来选取该线程下一条需要执行的命令</p>
<p>每一个线程都有一个独立的程序计数器. 独立存储, 互不影响, 从而可以保证不同的线程在切换之后可以回到正确的位置</p>
<p>所以程序计数器作用如下 :</p>
<ol>
<li>字节码解释器 通过改变 程序计数器的值, 对线程进行控制</li>
<li>多线程情况下, 程序计数器记录 <strong>当前的执行位置</strong>, 保证切换过程正确执行</li>
</ol>
<p><strong>程序计数器就可以理解为 组原里面的PC</strong>, 里面就存放程序下一个命令的地址.</p>
<p><strong>程序计数器是唯一不会 出现 OutOfMemoryError 的内存区域, 它随着线性的生命周期 生死</strong></p>
<h3 id="虚拟机栈">虚拟机栈</h3>
<p><strong>虚拟机栈：</strong> 每个 Java 方法在执行的同时会创建一个栈帧用于存储 <strong>局部变量表、操作数栈、常量池引用</strong>等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</p>
<p><strong>VM栈也是线程私有的, 它的生命周期和线程相同</strong></p>
<p>VM 栈存储的东西 :</p>
<p>线程方法调用的数据是通过栈传递的. VM栈包含的很重要的一部分就是 <strong>局部变量表</strong>, 里面存放了 :</p>
<ol>
<li>局部变量为 : 八种数据类型的话, 就直接存值</li>
<li>局部变量为 : 对象的话, 就存放对象的引用 (Reference, 所有的Java对象, 都是用引用表示的)</li>
</ol>
<p>VM 栈作用 :</p>
<p>每一次函数调用, 对应的帧栈都会被压入VM栈, 每次调用结束 (Return &amp; 异常抛出), 相应函数帧栈都会出栈.</p>
<p>VM 栈异常 :</p>
<p>**StackOverFlowError：**若VM 栈的大小不允许动态扩展, 是有限的 所有当前的线程 调用方法过深, 会导致栈溢出</p>
<p>**OutOfMemoryError: **   VM 栈内存用完了</p>
<h3 id="本地方法栈">本地方法栈</h3>
<p>和 VM 栈即为类似, 功能也大致相同</p>
<p>和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p>
<h2 id="线程共享">线程共享</h2>
<h3 id="堆-heap">堆 (Heap)</h3>
<p>Java 堆 <strong>所有线程共享的一块内存区域</strong>, 在虚拟机启动的时候就创建</p>
<p><strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p>
<p><strong>存对象 !!! 存数组 !!!</strong></p>
<p>Java 堆也是垃圾回收机制管理的主要区域</p>
<p><strong>当然如果是静态对象,  那么存储地点为 方法区</strong></p>
<h3 id="方法区-non---heap">方法区 (Non - heap)🌟</h3>
<p>这个区域也是所有先出共享的一块 <strong>内存区域</strong> 主要存放以下内容 :</p>
<ol>
<li>
<p>加载的类的信息 : <strong>字节码对象</strong></p>
</li>
<li>
<p><strong>静态变量</strong></p>
</li>
<li>
<p>编译器编译后的代码</p>
</li>
<li>
<p><strong>运行时常量池</strong> 存放 <strong>编译器</strong> 就已经确定的值, 常量池又可以分为以下几类:</p>
<ul>
<li>注意, 基本数据类型只有被 final 修饰才会被放入常量池, 否则入栈.</li>
<li>注意, JDK1.7 以后, <strong>JVM 已经将常量池从方法区移出来了. 放在了 Heap 中</strong></li>
</ul>
</li>
</ol>
<p><img src='/image/2019-07-31-constant_pool.png' /></p>
<p>注意 <strong>不在常量池里面的元素</strong> 不意味着不能共享数据, 如 :</p>
<blockquote>
<p>此时栈中 i1,i2,i3的地址还是指向同一个值</p>
</blockquote>
<img src='/image/2019-07-30-StackOrConstant.jpg' style="width:300px"/> 
<h3 id="直接内存">直接内存</h3>
<p>直接内存并不是 JVM运行时数据区的一部分, 也不是 JVM 规范的内存区域 但是这一部分也会被 JVM 频繁使用.</p>
<p><strong>使用方式 :</strong></p>
<p>Jdk1.4 加入 NIO(New Input/Outout) 类, 引入了一种基于管道(Channel)和缓存区(Buffer)的 I/O 方式.</p>
<p>直接使用 <strong>Native</strong> 函数进行 <strong>堆外内存分配</strong> 从而可以不收到 Java 堆的限制</p>
<h1 id="二-hotspot-虚拟机对象创建过程">二. HotSpot 虚拟机对象创建过程</h1>
<p>HotSpot 虚拟机在 Java 堆中创建, 实例化一个对象的全过程如下</p>
<p><img src="https://camo.githubusercontent.com/8adbddf019488872c5da890c3bee263db22150fe/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f4a6176612545352538382539422545352542422542412545352541462542392545382542312541312545372539412538342545382542462538372545372541382538422e706e67" alt="Javaåå"ºå¯¹è±¡çè¿ç¨"></p>
<h2 id="1-类的加载">1. 类的加载</h2>
<p>虚拟机 <strong>遇到一条 new 指令时</strong>，首先将去检查这个指令的参数是否能在 <strong>常量池中定位到这个类的符号引用</strong>，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>
<p>注意 <strong>静态方法, 成员变量 都是在类加载的阶段放入方法区</strong></p>
<p><img src='/image/2019-08-03-Classload.svg' /></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="cm">/*
</span><span class="cm">	初始化阶段 静态代码块 和 静态成语变量 执行顺序
</span><span class="cm">*/</span>

<span class="cm">/* 错误的情况 */</span>
<span class="kd">class</span> <span class="nc">Mytest</span><span class="o">{</span>
    <span class="cm">/*
</span><span class="cm">    类的加载的初始化阶段的 静态成员变量 和 静态代码块 是***顺序进行的****
</span><span class="cm">    此时编译器会报错
</span><span class="cm">    */</span>
    <span class="kd">static</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;this is :&#34;</span> <span class="o">+</span> <span class="n">i</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;hello world&#34;</span><span class="o">);</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kd">static</span>  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">10</span><span class="o">;</span>

<span class="o">}</span>


<span class="cm">/* 正确的情况 */</span>
<span class="kd">class</span> <span class="nc">Mytest</span><span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span>  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">10</span><span class="o">;</span>
    <span class="cm">/*
</span><span class="cm">    静态代码块在初始化阶段执行，且只在类加载的时候执行一次
</span><span class="cm">    类的加载的初始化阶段的 静态成员变量 和 静态代码块 是***顺序进行的****
</span><span class="cm">    也就是说, 如下的情况才为正确
</span><span class="cm">    */</span>
    <span class="kd">static</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;this is :&#34;</span> <span class="o">+</span> <span class="n">i</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;hello world&#34;</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span>

</code></pre></td></tr></table>
</div>
</div><h2 id="2-分配内存">2. 分配内存</h2>
<p>在 <strong>类加载检查通过</strong> 之后 , 接下来 JVM 为新生的 <strong>实例化对象分配内存</strong> 到 <strong>堆区</strong></p>
<p>实例化一个对象所需要的内存大小 在加载初始化的阶段就可以确定, 分配就是从 堆区内从中划分一块确定大小的内存</p>
<h2 id="3-初始化零值">3. 初始化零值</h2>
<p>内存分配完成之后, JVM 需要将 为这个实例化的对象的 内存空间都初始化为 <strong>默认值</strong> 包括 :</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>short</td>
<td>0</td>
</tr>
<tr>
<td>btye</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>0</td>
</tr>
<tr>
<td>float</td>
<td>0.0</td>
</tr>
<tr>
<td>double</td>
<td>0.0</td>
</tr>
<tr>
<td>boolean</td>
<td>false</td>
</tr>
<tr>
<td>char</td>
<td>''</td>
</tr>
<tr>
<td>object</td>
<td>null</td>
</tr>
</tbody>
</table>
<p>从而保证 Java 代码中 <strong>类的成员字段</strong> 可以不赋值直接使用 !</p>
<h2 id="4-设置对象头">4. 设置对象头</h2>
<p>初始化零值完成之后, 会对象头进行必要的设置, 例如对象是这个类的实例, 那么会存放一些对于这个实例化类的 <strong>描述信息</strong> 比如 :</p>
<ul>
<li>如何才能找到类的元数据信息</li>
<li>对象的哈希码</li>
<li>对象的 GC 分代年龄等信息</li>
</ul>
<p>等等</p>
<h2 id="5执行-init-方法">5.执行 init 方法</h2>
<p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了, 此时可以开始安装 coder 的意愿去初始化这个实例化类了.</p>
<p>按顺序执行对象的构造函数, 如果有父类, 则先调用父类构造.</p>
<h1 id="三-实例对象内存布局">三. 实例对象内存布局</h1>
<p><img src='/image/2019-08-03-classmem.png' /></p>
<h2 id="对象的访问定位">对象的访问定位</h2>
<p>建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式有虚拟机实现而定，目前主流的访问方式有<strong>①使用句柄</strong>和<strong>②直接指针</strong>两种：</p>
<ol>
<li>
<p><strong>句柄：</strong> 如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；</p>
<p><img src="https://camo.githubusercontent.com/04c82b46121149c8cc9c3b81e18967a5ce06353f/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545352541462542392545382542312541312545372539412538342545382541452542462545392539372541452545352541452539412545342542442538442d2545342542442542462545372539342541382545352538462541352545362539462538342e706e67" alt="å¯¹è±¡çè®¿é®å®ä½-ä½¿ç¨å¥æ"></p>
<p><strong>使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改</strong></p>
</li>
<li>
<p><strong>直接指针：</strong> 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。</p>
<p><img src="https://camo.githubusercontent.com/0ae309b058b45ee14004cd001e334355231b2246/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545352541462542392545382542312541312545372539412538342545382541452542462545392539372541452545352541452539412545342542442538442d2545372539422542342545362538452541352545362538432538372545392539322538382e706e67" alt="å¯¹è±¡çè®¿é®å®ä½-ç´æ¥æé"></p>
<p><strong>使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</strong></p>
</li>
</ol>
<h1 id="四常量池">四.常量池</h1>
<p>这里的常量池 属于 <strong>运行时常量池</strong> 存在于 <strong>堆的方法区</strong></p>
<p>各个基本类型的常量池共享, 也就是说, <strong>在不同方法内创建的 对象 会放在同一个常量池</strong></p>
<p>e.g.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="cm">/*
</span><span class="cm">	常量池的唯一性
</span><span class="cm">*/</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">method1</span><span class="o">(</span><span class="n">String</span> <span class="n">s1</span><span class="o">){</span>   
    <span class="n">String</span> <span class="n">test</span> <span class="o">=</span> <span class="s">&#34;abc&#34;</span><span class="o">;</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span> <span class="o">==</span> <span class="n">test</span><span class="o">)</span> <span class="c1">// true, 即是在同一个常量池取值的
</span><span class="c1"></span><span class="o">}</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(){</span>
    <span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&#34;abc&#34;</span><span class="o">;</span>
    <span class="n">method1</span><span class="o">(</span><span class="n">s</span><span class="o">)</span>	
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="string-常量池">String 常量池</h2>
<h3 id="-和-new">= 和 new</h3>
<p>记住一点：<strong>只要使用 new 方法，便需要创建新的对象。</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="n">String</span> <span class="n">str1</span> <span class="o">=</span> <span class="s">&#34;abcd&#34;</span><span class="o">;</span><span class="c1">//先检查字符串常量池中有没有&#34;abcd&#34;，如果字符串常量池中没有，则创建一个，然后 str1 指向字符串常量池中的对象，如果有，则直接将 str1 指向&#34;abcd&#34;&#34;；
</span><span class="c1"></span><span class="n">String</span> <span class="n">str2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="s">&#34;abcd&#34;</span><span class="o">);</span><span class="c1">//堆中创建一个新的对象
</span><span class="c1"></span><span class="n">String</span> <span class="n">str3</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="s">&#34;abcd&#34;</span><span class="o">);</span><span class="c1">//堆中创建一个新的对象
</span><span class="c1"></span><span class="n">String</span> <span class="n">str4</span> <span class="o">=</span> <span class="s">&#34;abcd&#34;</span><span class="o">;</span>
<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">str1</span><span class="o">==</span><span class="n">str2</span><span class="o">);</span><span class="c1">//false
</span><span class="c1"></span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">str2</span><span class="o">==</span><span class="n">str3</span><span class="o">);</span><span class="c1">//false
</span><span class="c1"></span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">str1</span><span class="o">==</span><span class="n">str4</span><span class="o">);</span><span class="c1">//true
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>利用 引号的声明方式, 会去常量池找, 然后直接返回常量池里面的字符串. 如果常量池里面已经存在, 那直接返回, 否则创建一个并返回.</li>
<li>如果 使用 new 的方式, 会直接在堆里面创建, 不管值是否一样. 都会声明一个新的</li>
</ul>
<p><img src="https://camo.githubusercontent.com/48189454746b5979fd465b32b996d222619ac1dc/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d33537472696e672d506f6f6c2d4a617661312d343530783234392e706e67" alt="String-Pool-Java"></p>
<h3 id="拼接">拼接</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="n">String</span> <span class="n">str1</span> <span class="o">=</span> <span class="s">&#34;str&#34;</span><span class="o">;</span>
<span class="n">String</span> <span class="n">str2</span> <span class="o">=</span> <span class="s">&#34;ing&#34;</span><span class="o">;</span>

<span class="n">String</span> <span class="n">str3</span> <span class="o">=</span> <span class="s">&#34;str&#34;</span> <span class="o">+</span> <span class="s">&#34;ing&#34;</span><span class="o">;</span><span class="c1">//常量池中的对象
</span><span class="c1"></span><span class="n">String</span> <span class="n">str4</span> <span class="o">=</span> <span class="n">str1</span> <span class="o">+</span> <span class="n">str2</span><span class="o">;</span> <span class="c1">//在堆上创建的新的对象	  
</span><span class="c1"></span><span class="n">String</span> <span class="n">str5</span> <span class="o">=</span> <span class="s">&#34;string&#34;</span><span class="o">;</span><span class="c1">//常量池中的对象
</span><span class="c1"></span>
<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">str3</span> <span class="o">==</span> <span class="n">str4</span><span class="o">);</span><span class="c1">//false
</span><span class="c1"></span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">str3</span> <span class="o">==</span> <span class="n">str5</span><span class="o">);</span><span class="c1">//true
</span><span class="c1"></span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">str4</span> <span class="o">==</span> <span class="n">str5</span><span class="o">);</span><span class="c1">//false
</span></code></pre></td></tr></table>
</div>
</div><p><img src="https://camo.githubusercontent.com/6008db677de95edd009ce8dc9337f5bdf7de8d91/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545352541442539372545372541432541362545342542382542322545362538422542432545362538452541352e706e67" alt="img"></p>
<h3 id="string-s1--new-stringabc这句话创建了几个字符串对象">String s1 = new String(&ldquo;abc&rdquo;);这句话创建了几个字符串对象？</h3>
<p><strong>将创建 1 或 2 个字符串。如果池中已存在字符串文字“abc”，则池中只会创建一个字符串“s1”。如果池中没有字符串文字“abc”，那么它将首先在池中创建，然后在堆空间中创建，因此将创建总共 2 个字符串对象。</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="n">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="s">&#34;abc&#34;</span><span class="o">);</span><span class="c1">// 堆内存的地址值
</span><span class="c1"></span><span class="n">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">&#34;abc&#34;</span><span class="o">;</span>
<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span> <span class="o">==</span> <span class="n">s2</span><span class="o">);</span><span class="c1">// 输出 false,因为一个是堆内存，一个是常量池的内存，故两者是不同的。
</span><span class="c1"></span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">s2</span><span class="o">));</span><span class="c1">// 输出 true
</span></code></pre></td></tr></table>
</div>
</div><h2 id="八种基本类型的包装类和常量池">八种基本类型的包装类和常量池</h2>
<ul>
<li>Java 的基本类型的包装类大部分实现了 <strong>常量池技术</strong> 即 <strong>Byte,Short,Integer,Long,Character,Boolean</strong>.</li>
<li>浮点类 <strong>Float, Double 没有实现常量池技术</strong></li>
</ul>
<p>🌟🌟 注意常量池 只涉及包装类才有 !!</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="n">Integer</span> <span class="n">i1</span> <span class="o">=</span> <span class="n">33</span><span class="o">;</span>
<span class="n">Integer</span> <span class="n">i2</span> <span class="o">=</span> <span class="n">33</span><span class="o">;</span>
<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">i1</span> <span class="o">==</span> <span class="n">i2</span><span class="o">);</span><span class="c1">// 输出 true
</span><span class="c1"></span><span class="n">Integer</span> <span class="n">i11</span> <span class="o">=</span> <span class="n">333</span><span class="o">;</span>
<span class="n">Integer</span> <span class="n">i22</span> <span class="o">=</span> <span class="n">333</span><span class="o">;</span>
<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">i11</span> <span class="o">==</span> <span class="n">i22</span><span class="o">);</span><span class="c1">// 输出 false
</span><span class="c1"></span>
<span class="c1">// Double 没有实现常量池
</span><span class="c1"></span><span class="n">Double</span> <span class="n">i3</span> <span class="o">=</span> <span class="n">1</span><span class="o">.</span><span class="na">2</span><span class="o">;</span>
<span class="n">Double</span> <span class="n">i4</span> <span class="o">=</span> <span class="n">1</span><span class="o">.</span><span class="na">2</span><span class="o">;</span>
<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">i3</span> <span class="o">==</span> <span class="n">i4</span><span class="o">);</span><span class="c1">// 输出 false
</span></code></pre></td></tr></table>
</div>
</div><p><strong>这 5 种包装类默认创建了数值[-128，127] 的相应类型的缓存数据，但是超出此范围仍然会去创建新的对象。</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="cm">/*
</span><span class="cm">	注意知道 使用了 new
</span><span class="cm">	那么一定都是从 堆重新创建对象了 !!!
</span><span class="cm">*/</span>
<span class="n">Integer</span> <span class="n">i1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Integer</span><span class="o">(</span><span class="n">1</span><span class="o">);</span>
<span class="n">Integer</span> <span class="n">i2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Integer</span><span class="o">(</span><span class="n">1</span><span class="o">);</span>
<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">i1</span> <span class="o">==</span> <span class="n">i2</span><span class="o">);</span><span class="c1">// 输出 false
</span></code></pre></td></tr></table>
</div>
</div><h2 id="八种基本类型的本类">八种基本类型的本类</h2>
<p>而基本类型不管多大都是<strong>放在 栈里</strong>, 不会放在常量池 !!!!!!!!!!!!!!!!!!</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="cm">/*
</span><span class="cm">	对于本类, 无论数值多大, 都不算一个对象
</span><span class="cm">	只要值一样, 就指向同一个地方
</span><span class="cm">	且存储地方为 栈
</span><span class="cm">*/</span>
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">10000</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">10000</span><span class="o">;</span>
<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="o">);</span><span class="c1">// 输出 true
</span></code></pre></td></tr></table>
</div>
</div>
    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">LYR</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2021-08-14
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      
      <nav class="post-nav">
        
        <a class="next" href="/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/java/jvm/java%E7%B1%BB%E5%8A%A0%E8%BD%BD/">
            <span class="next-text nav-default">java类加载</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:lyr-2000@qq.com" class="iconfont icon-email" title="email"></a>
  <a href="http://doc.lyr-2000.xyz/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021<span class="heart"><i class="iconfont icon-heart"></i></span><span>lyr</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>








</body>
</html>
