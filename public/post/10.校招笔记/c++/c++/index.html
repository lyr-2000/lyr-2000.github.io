<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title> - Even - A super concise theme for Hugo</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="LYR" /><meta name="description" content="System ReView For C&#43;&#43; A System Review For C&#43;&#43; 内存分区 指针 Pointer 引用 Ref 数组 Array 智能类型 Auto New Abstract Data Type Struct Union Class 构造函数 Constructor 析构函数 destructors 拷贝构造函数 Copy Construstor 拷贝赋值运算符 重载 Copy assignment operator 浅拷贝 Shallow Copy 深" /><meta name="keywords" content="LYR的文档站, LYR的个人博客, even" />






<meta name="generator" content="Hugo 0.86.0 with theme even" />


<link rel="canonical" href="http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/c&#43;&#43;/c&#43;&#43;/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.b5a744db6de49a86cadafb3b70f555ab443f83c307a483402259e94726b045ff.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="" />
<meta property="og:description" content="System ReView For C&#43;&#43; A System Review For C&#43;&#43; 内存分区 指针 Pointer 引用 Ref 数组 Array 智能类型 Auto New Abstract Data Type Struct Union Class 构造函数 Constructor 析构函数 destructors 拷贝构造函数 Copy Construstor 拷贝赋值运算符 重载 Copy assignment operator 浅拷贝 Shallow Copy 深" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://doc.lyr-2000.xyz/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/c&#43;&#43;/c&#43;&#43;/" /><meta property="article:section" content="post" />



<meta itemprop="name" content="">
<meta itemprop="description" content="System ReView For C&#43;&#43; A System Review For C&#43;&#43; 内存分区 指针 Pointer 引用 Ref 数组 Array 智能类型 Auto New Abstract Data Type Struct Union Class 构造函数 Constructor 析构函数 destructors 拷贝构造函数 Copy Construstor 拷贝赋值运算符 重载 Copy assignment operator 浅拷贝 Shallow Copy 深">

<meta itemprop="wordCount" content="8038">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content=""/>
<meta name="twitter:description" content="System ReView For C&#43;&#43; A System Review For C&#43;&#43; 内存分区 指针 Pointer 引用 Ref 数组 Array 智能类型 Auto New Abstract Data Type Struct Union Class 构造函数 Constructor 析构函数 destructors 拷贝构造函数 Copy Construstor 拷贝赋值运算符 重载 Copy assignment operator 浅拷贝 Shallow Copy 深"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">LYR的文档站</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">首页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档页</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a><a href="/friends">
        <li class="mobile-menu-item">大佬</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">LYR的文档站</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">首页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/friends">大佬</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title"></h1>

      <div class="post-meta">
        <span class="post-time"> 0001-01-01 </span>
        
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#system-review-for-c">System ReView For C++</a></li>
    <li><a href="#a-system-review-for-c">A System Review For C++</a>
      <ul>
        <li><a href="#内存分区">内存分区</a></li>
        <li><a href="#指针-pointer">指针 Pointer</a></li>
        <li><a href="#引用-ref">引用 Ref</a></li>
        <li><a href="#数组-array">数组 Array</a></li>
        <li><a href="#智能类型-auto">智能类型 Auto</a></li>
        <li><a href="#new">New</a></li>
      </ul>
    </li>
    <li><a href="#abstract-data-type">Abstract Data Type</a>
      <ul>
        <li><a href="#struct">Struct</a></li>
        <li><a href="#union">Union</a></li>
        <li><a href="#class">Class</a>
          <ul>
            <li><a href="#构造函数-constructor">构造函数 Constructor</a></li>
            <li><a href="#析构函数-destructors">析构函数 destructors</a></li>
            <li><a href="#拷贝构造函数-copy-construstor">拷贝构造函数 Copy Construstor</a></li>
            <li><a href="#拷贝赋值运算符-重载-copy-assignment-operator">拷贝赋值运算符 重载 Copy assignment operator</a></li>
            <li><a href="#浅拷贝-shallow-copy">浅拷贝 Shallow Copy</a></li>
            <li><a href="#深拷贝-deep-copy">深拷贝 Deep Copy</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#overload-重载">Overload 重载</a>
      <ul>
        <li><a href="#函数重载">函数重载</a></li>
        <li><a href="#operator-运算符-重载">operator (运算符) 重载</a>
          <ul>
            <li><a href="#-overload">&lsquo;+&rsquo; overload</a></li>
            <li><a href="#-overload-1">&lsquo;=&rsquo; overload</a></li>
            <li><a href="#-overload---同理">&lsquo;&laquo;&rsquo; overload ( &ldquo;&raquo;&rdquo; 同理)</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#c-oop的相关的概念">C++ OOP的相关的概念</a>
      <ul>
        <li>
          <ul>
            <li><a href="#1-类访问的修饰符">1. 类访问的修饰符</a></li>
            <li><a href="#2类的系统函数">2.类的系统函数</a></li>
            <li><a href="#3类的继承">3.类的继承</a></li>
            <li><a href="#4-c多态">4. C++多态</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#class-relationships-and-features">Class Relationships and Features</a>
      <ul>
        <li><a href="#nested-classes">Nested classes</a></li>
        <li><a href="#继承-inheritance--generalisation">继承 Inheritance / Generalisation</a></li>
        <li><a href="#polymorphism-多态">polymorphism 多态</a></li>
        <li><a href="#多继承">多继承</a></li>
      </ul>
    </li>
    <li><a href="#exception">Exception</a></li>
    <li><a href="#design">Design</a>
      <ul>
        <li><a href="#design-patterns">Design Patterns</a>
          <ul>
            <li><a href="#singleton-单例">singleton 单例</a></li>
          </ul>
        </li>
        <li><a href="#design-principle">Design Principle</a>
          <ul>
            <li><a href="#coupling-耦合">Coupling 耦合</a></li>
            <li><a href="#cohesion-内聚">Cohesion 内聚</a></li>
            <li><a href="#observer-and-mutator">observer and mutator</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#泛化-generic">泛化 Generic</a>
      <ul>
        <li><a href="#函数模版-function-template">函数模版 function template</a></li>
        <li><a href="#类模版-class-template">类模版 class template</a></li>
      </ul>
    </li>
    <li><a href="#stl">STL</a>
      <ul>
        <li><a href="#stl-container">STL container</a></li>
        <li><a href="#stl-适配器">STL 适配器</a>
          <ul>
            <li><a href="#ostream_iterator">ostream_iterator</a></li>
          </ul>
        </li>
        <li><a href="#stl-迭代器类型">STL 迭代器类型</a></li>
      </ul>
    </li>
    <li><a href="#io">IO</a></li>
    <li><a href="#转化函数">转化函数</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h1 id="system-review-for-c">System ReView For C++</h1>
<ul>
<li><a href="#a-system-review-for-c">A System Review For C++</a>
<ul>
<li><a href="#%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA">内存分区</a></li>
<li><a href="#%E6%8C%87%E9%92%88-pointer">指针 Pointer</a></li>
<li><a href="#%E5%BC%95%E7%94%A8-ref">引用 Ref</a></li>
<li><a href="#%E6%95%B0%E7%BB%84-array">数组 Array</a></li>
<li><a href="#%E6%99%BA%E8%83%BD%E7%B1%BB%E5%9E%8B-auto">智能类型 Auto</a></li>
<li><a href="#new">New</a></li>
</ul>
</li>
<li><a href="#abstract-data-type">Abstract Data Type</a>
<ul>
<li><a href="#struct">Struct</a></li>
<li><a href="#union">Union</a></li>
<li><a href="#class">Class</a>
<ul>
<li><a href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-constructor">构造函数 Constructor</a></li>
<li><a href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-destructors">析构函数 destructors</a></li>
<li><a href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-copy-construstor">拷贝构造函数 Copy Construstor</a></li>
<li><a href="#%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6-%E9%87%8D%E8%BD%BD-copy-assignment-operator">拷贝赋值运算符 重载 Copy assignment operator</a></li>
<li><a href="#%E6%B5%85%E6%8B%B7%E8%B4%9D-shallow-copy">浅拷贝 Shallow Copy</a></li>
<li><a href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D-deep-copy">深拷贝 Deep Copy</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#overload-%E9%87%8D%E8%BD%BD">Overload 重载</a>
<ul>
<li><a href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD">函数重载</a></li>
<li><a href="#operator-%E8%BF%90%E7%AE%97%E7%AC%A6-%E9%87%8D%E8%BD%BD">operator (运算符) 重载</a>
<ul>
<li><a href="#-overload">'+' overload</a></li>
<li><a href="#-overload">'=' overload</a></li>
<li><a href="#-overload---%E5%90%8C%E7%90%86">'&laquo;' overload ( &ldquo;&raquo;&rdquo; 同理)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#c-oop%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9A%84%E6%A6%82%E5%BF%B5">C++ OOP的相关的概念</a>
<ul>
<li><a href="#1-%E7%B1%BB%E8%AE%BF%E9%97%AE%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6">1. 类访问的修饰符</a></li>
<li><a href="#2%E7%B1%BB%E7%9A%84%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0">2.类的系统函数</a></li>
<li><a href="#3%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF">3.类的继承</a></li>
<li><a href="#4-c%E5%A4%9A%E6%80%81">4. C++多态</a></li>
</ul>
</li>
<li><a href="#class-relationships-and-features">Class Relationships and Features</a>
<ul>
<li><a href="#nested-classes">Nested classes</a></li>
<li><a href="#%E7%BB%A7%E6%89%BF-inheritance--generalisation">继承 Inheritance / Generalisation</a></li>
<li><a href="#polymorphism-%E5%A4%9A%E6%80%81">polymorphism 多态</a></li>
<li><a href="#%E5%A4%9A%E7%BB%A7%E6%89%BF">多继承</a></li>
</ul>
</li>
<li><a href="#exception">Exception</a></li>
<li><a href="#design">Design</a>
<ul>
<li><a href="#design-patterns">Design Patterns</a>
<ul>
<li><a href="#singleton-%E5%8D%95%E4%BE%8B">singleton 单例</a></li>
</ul>
</li>
<li><a href="#design-principle">Design Principle</a>
<ul>
<li><a href="#coupling-%E8%80%A6%E5%90%88">Coupling 耦合</a></li>
<li><a href="#cohesion-%E5%86%85%E8%81%9A">Cohesion 内聚</a></li>
<li><a href="#observer-and-mutator">observer and mutator</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%B3%9B%E5%8C%96-generic">泛化 Generic</a>
<ul>
<li><a href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E7%89%88-function-template">函数模版 function template</a></li>
<li><a href="#%E7%B1%BB%E6%A8%A1%E7%89%88-class-template">类模版 class template</a></li>
</ul>
</li>
<li><a href="#stl">STL</a>
<ul>
<li><a href="#stl-container">STL container</a></li>
<li><a href="#stl-%E9%80%82%E9%85%8D%E5%99%A8">STL 适配器</a>
<ul>
<li><a href="#ostream_iterator">ostream_iterator</a></li>
</ul>
</li>
<li><a href="#stl-%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BB%E5%9E%8B">STL 迭代器类型</a></li>
</ul>
</li>
<li><a href="#io">IO</a></li>
<li><a href="#%E8%BD%AC%E5%8C%96%E5%87%BD%E6%95%B0">转化函数</a></li>
</ul>
<h1 id="a-system-review-for-c">A System Review For C++</h1>
<p>#Memory</p>
<h2 id="内存分区">内存分区</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">/* c++ 5大内存区域 *

- stack 区 : 里面的变量通常是局部变量、函数参数等, 分配在函数的运行栈中, 随着函数的结束而被释放

- heap 堆区: new 语句动态申请的内存区域, 释放由 coder 手动delete, 否则会泄露. 

- 自由存储区: 和 heap 区即为相似, 是malloc申请的内存, 但是删除要用 free

- 全局/静态区 : 用于放 全局/静态变量

- 常量区 : 放只读常量
</code></pre></td></tr></table>
</div>
</div><h2 id="指针-pointer">指针 Pointer</h2>
<ul>
<li><strong>指针并不是 alias, 它们是真实的 objects !</strong></li>
<li>指针可以不被初始化 (虽然可以不被强制初始化, 但是使用一个未初始化的指针会抛出异常)</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/* 定义指针 */</span>
<span class="cm">/* &#39;*&#39; called the dereference operator */</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">intPtr</span><span class="p">;</span>

<span class="cm">/* 赋值 */</span>
<span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="n">intPtr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">;</span>

<span class="cm">/* 通过pointer 改变值 */</span>
<span class="o">*</span><span class="n">intPtr</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/* 初始化指针 */</span>

<span class="o">/-----------------------/</span>
<span class="cm">/* 初始化 空指针 */</span>
<span class="cm">/* 三种方式其实是一样的 */</span>
<span class="cm">/* NULL id defined as 0 in cstdlib */</span>
<span class="cm">/*  注意 : 
</span><span class="cm">	nullptr is always a pointer type , 且为 -std=c++11 提出的标准
</span><span class="cm">	NULL 只是一个 Integer type (0)
</span><span class="cm">*/</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">ptr1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">ptr2</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>

<span class="cm">/* ❌ */</span>
<span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="mi">10</span> 

<span class="o">/-----------------------/</span>

<span class="cm">/* 一个未初始化的指针, 叫 野指针, wild pointer */</span>
<span class="cm">/* 野指针 */</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

<span class="cm">/* 不管是野追针, 还是空指针, 都不能直接用*运算法符号复制 */</span>
<span class="cm">/* ❌ */</span>
<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">10</span> 
   
    
    
<span class="o">/-----------------------/</span>
    
<span class="cm">/* 使用 new 初始化指针, 且分配内存 */</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">;</span>
<span class="cm">/* ✅ */</span>
<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>函数指针 :</p>
<p>我们可以用指针指向一个函数. 从而实现, 函数调用等操作</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/* 少了括号, 并不是函数指针的定义 */</span>
<span class="kt">int</span>  <span class="o">*</span><span class="nf">f</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

<span class="cm">/* g是一个指向 pass int, return char 的函数的指针*/</span>
<span class="kt">char</span> <span class="p">(</span><span class="o">*</span><span class="n">g</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>

<span class="cm">/* h是一个指向 pass int,int,  return char 的函数的指针*/</span>
<span class="kt">char</span> <span class="p">(</span><span class="o">*</span><span class="n">h</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>


<span class="cm">/* for example */</span>
<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">Compare</span><span class="p">)(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="o">=</span> <span class="n">strcmp</span><span class="p">;</span>

<span class="cm">/* 以下三种情况相同 */</span>
<span class="n">strcmp</span><span class="p">(</span><span class="s">&#34;cat&#34;</span><span class="p">,</span> <span class="s">&#34;bat&#34;</span><span class="p">);</span>
<span class="p">(</span><span class="o">*</span><span class="n">Compare</span><span class="p">)(</span><span class="s">&#34;cat&#34;</span><span class="p">,</span> <span class="s">&#34;bat&#34;</span><span class="p">);</span>
<span class="n">Compare</span><span class="p">(</span><span class="s">&#34;cat&#34;</span><span class="p">,</span> <span class="s">&#34;bat&#34;</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>Void 指针, c++独有, 用于定义一个目前还不知道类型的指针, 且此时取内容符号* 失效</p>
<p>但是我们可以通过 <strong>cast operation (类型转化)</strong> 重新为 void pointer 定义类型</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">ip</span><span class="p">;</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">vp</span><span class="p">;</span>
<span class="n">ip</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">;</span>
<span class="n">vp</span> <span class="o">=</span> <span class="n">ip</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">vp</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>			<span class="cm">/* doesn&#39;t work */</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="p">((</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">vp</span> <span class="p">)</span><span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>	<span class="cm">/* work */</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>**c++ 不允许在函数内部返回局部变量的地址, 除非变量陪设置为 <code>static</code> **</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="o">*</span><span class="nf">testPointer</span> <span class="p">(){</span>

    <span class="cm">/* 返回局部变量的地址的时候, 需要设置为 static */</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">testPointer</span><span class="p">();</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h2 id="引用-ref">引用 Ref</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">// 取地址符号定义引用
</span><span class="c1"></span><span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">&amp;</span><span class="n">refInt</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">&amp;</span><span class="n">refInt2</span> <span class="o">=</span> <span class="n">refInt</span><span class="p">;</span>

<span class="c1">// 此后改变 refInt, refInt2 的值 即相当于改变了 value 的值
</span><span class="c1"></span><span class="n">refInt</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span> <span class="c1">// value == 100 true
</span><span class="c1"></span>
<span class="c1">// 注意 引用必须要初始化
</span></code></pre></td></tr></table>
</div>
</div><p><strong>Different with point, 引用 Ref 最终只是一个 alias, 它不是 object, 每当发生对它的操作, 那么就会被转移到被它绑定的元素上</strong></p>
<h2 id="数组-array">数组 Array</h2>
<ul>
<li>
<p>多个相同类型的 ele 的集合.</p>
</li>
<li>
<p><strong>它的大小需要在编译器就被定义</strong>, (constant 而非 variable) !!!</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/* size */</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

<span class="cm">/* 仅仅被分配内存, 而未初始化 */</span>
<span class="kt">int</span> <span class="n">intArr</span><span class="p">[</span><span class="n">size</span><span class="p">];</span>

<span class="cm">/* 全部被初始化为 0 */</span>
<span class="kt">int</span> <span class="n">intArr2</span><span class="p">[</span><span class="n">size</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>


<span class="cm">/* ----------------- */</span>

<span class="cm">/* char 数组较为特殊, 它们一般以 ‘\0’ 结尾 */</span>
<span class="kt">char</span> <span class="n">a1</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="sc">&#39;C&#39;</span><span class="p">,</span> <span class="sc">&#39;+&#39;</span><span class="p">,</span> <span class="sc">&#39;+&#39;</span><span class="p">};</span>

<span class="cm">/* 报错, 因为需要长度为 7 的 char数组 */</span>
<span class="kt">char</span> <span class="mi">2</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#34;123456&#34;</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong>数组的名字, 即为第一个元素的指针</strong></p>
</li>
</ul>
<h2 id="智能类型-auto">智能类型 Auto</h2>
<p>可以由编译器转化为任何类型, 而不需要我们定义 :</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/* a is integer , b is double*/</span>
<span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">10.1</span><span class="p">;</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">ci</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cr</span> <span class="o">=</span> <span class="n">ci</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="n">ci</span><span class="p">;</span> <span class="c1">// int 
</span><span class="c1"></span><span class="k">auto</span> <span class="n">c</span> <span class="o">=</span> <span class="n">cr</span><span class="p">;</span> <span class="c1">// 注意此中亦为 int
</span><span class="c1"></span><span class="k">auto</span> <span class="n">d</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">integer</span><span class="p">;</span> <span class="c1">// d is int* pointer
</span><span class="c1"></span><span class="k">auto</span> <span class="n">e</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ci</span><span class="p">;</span>	<span class="c1">// e is const int* pointer 
</span></code></pre></td></tr></table>
</div>
</div><h2 id="new">New</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/* impact */</span>

<span class="o">-</span> <span class="err">使用</span> <span class="k">new</span> <span class="err">关键词</span><span class="p">,</span> <span class="err">会在</span> <span class="n">heap</span> <span class="err">区声明一块内存</span> <span class="p">(</span><span class="err">否则在栈区</span><span class="p">),</span> <span class="err">所以</span> <span class="k">new</span> <span class="err">出来的都需要</span> <span class="err">手动</span> <span class="k">delete</span>


<span class="cm">/* 比如 : 如下情况需要删除 */</span>

	<span class="cm">/* i指向一个int变量 */</span>
 <span class="o">-</span> <span class="kt">int</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">;</span>
   <span class="k">delete</span> <span class="n">i</span><span class="p">;</span>
   
   <span class="cm">/* i指向一个 int数组 */</span> 
 <span class="o">-</span> <span class="kt">int</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
   <span class="k">delete</span> <span class="p">[]</span><span class="n">i</span><span class="p">;</span>
  
 
 <span class="o">-</span> <span class="k">struct</span> <span class="nc">Student</span><span class="p">{</span>
     <span class="kt">char</span> <span class="o">*</span> <span class="n">name</span><span class="p">;</span>
 <span class="p">}</span>
<span class="o">-</span> <span class="n">Student</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Student</span><span class="p">();</span>

	<span class="cm">/* 先删除内部指针 */</span>
   <span class="k">delete</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
   
   <span class="cm">/* 再删除自己 */</span>
   <span class="k">delete</span> <span class="n">t</span>
</code></pre></td></tr></table>
</div>
</div><p>这个关键字在创建一个对象, 且分配空间的同时, <strong>返回一个对象的指针</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/* p 以及被初始化了 */</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">;</span>

<span class="cm">/* new 的时候调用了 person 的构造函数 */</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">personPtr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">person</span><span class="p">(</span><span class="s">&#34;fz&#34;</span><span class="p">);</span>

<span class="err">🌟</span> <span class="cm">/* delete 的时候, 才会调用 person的析构函, 否则在生命期结束, 程序并不会自动调用对象的析构 */</span>
<span class="k">delete</span> <span class="n">personPtr</span><span class="p">;</span>

<span class="cm">/* 不同于 直接定义的对象 */</span>
<span class="err">🌟</span> <span class="cm">/* fz在生命期结束了便调用 析构函数*/</span>
<span class="n">Person</span> <span class="n">fz</span><span class="p">(</span><span class="s">&#34;fz&#34;</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>利用 New 定义的对象, 在其生命周期结束后, 并不自动的调用析构函数 !!!</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">A</span><span class="p">{</span>
    
    <span class="k">public</span> <span class="o">:</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">A</span><span class="p">(</span><span class="kt">int</span> <span class="n">_a</span><span class="p">){</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">_a</span><span class="p">;</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span><span class="s">&#34; say hello world&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="o">~</span><span class="n">A</span><span class="p">(){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span><span class="s">&#34; is being destoried &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span>
<span class="p">{</span>
    <span class="n">A</span> <span class="o">*</span><span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">A</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">A</span> <span class="o">*</span><span class="n">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">A</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">1 say hello world
2 say hello world
</code></pre></td></tr></table>
</div>
</div><h1 id="abstract-data-type">Abstract Data Type</h1>
<h2 id="struct">Struct</h2>
<p>是一种特殊的 class 结构</p>
<ol>
<li>
<p>和 c++ class 的区别仅仅在于, 在不定义成员访问修饰符的情况下 :</p>
<p><strong>Struct 默认为 public</strong></p>
<p><strong>Class 默认为 private</strong></p>
</li>
<li>
<p>当然 struct 也可以拥有成员函数, 但是默认的也是 public. 且定义的方式和 class 一样</p>
</li>
</ol>
<h2 id="union">Union</h2>
<p>union 的定义类似于 struct :</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="k">union</span> <span class="nc">myUnion</span><span class="p">{</span>
   <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
   <span class="kt">float</span> <span class="n">f</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>联合的特点是, 所有的成员变量共享一块内存</strong>, 所以当给 f 赋值的时候, i 的值便会被覆盖.</p>
<p>从而, 一个 union 的大小, 取决于最大的成员变量, 而 struct 的大小为所有的成员变量之和</p>
<h2 id="class">Class</h2>
<h3 id="构造函数-constructor">构造函数 Constructor</h3>
<p>创建一个对象的函数, 无返回值, 如果不自己定义, 则编译器会定义一个默认无参的构造函数</p>
<p>当然也可以 overload 多个构造函数.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/* for example */</span>
<span class="k">class</span> <span class="nc">energyBill</span><span class="p">{</span>
    <span class="k">public</span> <span class="o">:</span> 
    <span class="n">energyBill</span><span class="p">();</span>
    <span class="n">energyBill</span><span class="p">(</span><span class="kt">double</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span> 
    <span class="n">energyBill</span><span class="p">(</span><span class="k">const</span> <span class="n">energyBill</span> <span class="o">&amp;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="析构函数-destructors">析构函数 destructors</h3>
<p>对象被销毁的时候调用, 程序运行到作用域外调用, 无传参, 无return</p>
<p>调用顺序 :</p>
<p><strong>The last created is the first destroyed!</strong> 也就是说, 先创建的对象, 后被销毁 !!!</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">A</span><span class="p">{</span>
    
    <span class="k">public</span> <span class="o">:</span>
    
    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
    
    <span class="n">A</span><span class="p">(</span><span class="kt">int</span> <span class="n">_a</span><span class="p">){</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">_a</span><span class="p">;</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span><span class="s">&#34; say hello world&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="o">~</span><span class="n">A</span><span class="p">(){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span><span class="s">&#34; is being destoried &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span>
<span class="p">{</span>
    <span class="n">A</span> <span class="n">a1</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">A</span> <span class="n">a2</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">1 say hello world
2 say hello world
2 is being destoried 
1 is being destoried 
</code></pre></td></tr></table>
</div>
</div><h3 id="拷贝构造函数-copy-construstor">拷贝构造函数 Copy Construstor</h3>
<p><code>X(X const&amp;);</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/* 以下的情况需要用到 拷贝构造函数*/</span>

<span class="cm">/* 1. 通过一个 object 显示的定义另一个 object */</span>
<span class="n">Point</span> <span class="nf">pointA</span><span class="p">(</span><span class="n">pointB</span><span class="p">);</span>
<span class="cm">/* 注意这里并没有用 = 运算符重载, 因为是直接在类名后面赋值的, 区别见下*/</span>
<span class="n">Point</span> <span class="n">pointA</span> <span class="o">=</span> <span class="n">pointB</span><span class="p">;</span> 

<span class="cm">/* 2. 在函数中按值传递一个object */</span>
<span class="kt">float</span> <span class="nf">getDistance</span><span class="p">(</span><span class="n">point</span> <span class="n">pointA</span><span class="p">);</span>

<span class="cm">/* 3. 在函数中按值返回一个object */</span>
<span class="k">return</span> <span class="n">pointA</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>默认的拷贝构造即就是 一个一个成员的 copy (member by member).</p>
<h3 id="拷贝赋值运算符-重载-copy-assignment-operator">拷贝赋值运算符 重载 Copy assignment operator</h3>
<p>即为 等于号重载</p>
<p><code>X&amp; operator=(const X&amp;);</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/* 不同于之前的构造函数, 赋值拷贝是由返回值的 */</span>
<span class="cm">/* 当在class 中使用 = 号进行赋值的时候, 比如 */</span>

<span class="cm">/* 注意为先定义, 再赋值 */</span>
<span class="n">point</span> <span class="n">pointA</span><span class="p">,</span><span class="n">pointB</span><span class="p">;</span>
<span class="n">pointA</span> <span class="o">=</span> <span class="n">pointB</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="浅拷贝-shallow-copy">浅拷贝 Shallow Copy</h3>
<p>在默认的拷贝构造函数中, 我们是按member. 一个一个复制的.</p>
<p>如果此时的 member 是一个 pointer, 那么复制过去的值会指向那个相同的地址, 从而叫做 <strong>浅拷贝</strong></p>
<h3 id="深拷贝-deep-copy">深拷贝 Deep Copy</h3>
<p>相对于 浅拷贝, <strong>我们深拷贝会先复制一份 pointer 指向的内容, 然后再将指针指向.</strong></p>
<ul>
<li>对于类似 array 的成员变量, 我们便需要 deep copy 去复制我们的 array 成员</li>
</ul>
<h1 id="overload-重载">Overload 重载</h1>
<h2 id="函数重载">函数重载</h2>
<p>相同的函数名, 提供不同的功能. 重载函数要求 :</p>
<ul>
<li>
<p>参数列表 argurment list 不同 :</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">int</span> <span class="nf">getMax</span><span class="p">(</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span> <span class="p">);</span>
<span class="kt">char</span> <span class="nf">getMax</span><span class="p">(</span> <span class="kt">char</span> <span class="n">first</span><span class="p">,</span> <span class="kt">char</span> <span class="n">second</span> <span class="p">);</span> <span class="kt">double</span> <span class="nf">getMax</span><span class="p">(</span> <span class="kt">double</span> <span class="n">red</span><span class="p">,</span> <span class="kt">double</span> <span class="n">blue</span> <span class="p">);</span> 
<span class="n">string</span> <span class="nf">getMax</span><span class="p">(</span> <span class="n">string</span> <span class="n">first</span><span class="p">,</span> <span class="n">string</span> <span class="n">second</span> <span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>❌ 参数列表相同, 返回值不同也不行</p>
</li>
<li>
<p>❌ 参数列表不同, 但是都带有默认值, 也不行</p>
</li>
</ul>
<h2 id="operator-运算符-重载">operator (运算符) 重载</h2>
<p>c ++ 提供运算符重载的功能, 绝大部分 c++ 运算符都可以重载, 例如 : + ,- ,* ,/ ,% ,&gt; ,&lt; , ! , ++ ,&ndash; , &amp; , -&gt; , etc.</p>
<p>**但是以下情况的运算符不能被重载 : **</p>
<ol>
<li>memer access operator : <code>.</code></li>
<li>pointer operatir : <code>*</code></li>
<li>scope resolution operator : <code>::</code></li>
<li>conditional operator : <code>? :</code></li>
<li>不能重载 c++ 没有定义的符号</li>
<li>不能重载 c++ 基础类型的运算符</li>
</ol>
<h3 id="-overload">&lsquo;+&rsquo; overload</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/* 提供两种重载方式 */</span>

<span class="cm">/* 1. class 内部函数重载功能 */</span>
<span class="n">ComplexNumber</span> <span class="n">ComplexNumber</span><span class="o">::</span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">ComplexNumber</span><span class="o">&amp;</span> <span class="n">arg</span><span class="p">)</span> <span class="k">const</span><span class="p">{</span>
 	<span class="c1">// code ... 
</span><span class="c1"></span>    <span class="c1">// 注意此时的 arg 也可以访问它的私有变量, 虽然是以 instance 的形式传递进来的
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/* call */</span>
<span class="n">a</span><span class="p">.</span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>

<span class="cm">/* 2. class 友元重载, 友元函数不是class 成员函数, 但是可以访问class private 变量 */</span>
<span class="k">friend</span> <span class="n">ComplexNumber</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">ComplexNumber</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">ComplexNumber</span><span class="o">&amp;</span><span class="p">){</span>
    <span class="c1">// code ...
</span><span class="c1"></span>    
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/* call */</span>
<span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>

<span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="-overload-1">&lsquo;=&rsquo; overload</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="n">className</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">className</span><span class="o">&amp;</span> <span class="n">_object</span><span class="p">)</span> <span class="k">const</span><span class="p">{</span>
	
    <span class="c1">// ...code
</span><span class="c1"></span>    
    <span class="k">return</span> <span class="n">object</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="-overload---同理">&lsquo;&laquo;&rsquo; overload ( &ldquo;&raquo;&rdquo; 同理)</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/* &lt;&lt; 的重载最好定义为友元函数, 否则看着别扭 */</span>
<span class="k">friend</span> <span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">sOut</span><span class="p">,</span> <span class="k">const</span> <span class="n">className</span> <span class="o">&amp;</span> <span class="n">object</span><span class="p">){</span>
    
	<span class="n">sOut</span> <span class="o">&lt;&lt;</span> <span class="n">object</span><span class="p">.</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="n">end</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">sOut</span><span class="p">;</span>
    
<span class="p">}</span>

<span class="cm">/* call */</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">_object</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="c-oop的相关的概念">C++ OOP的相关的概念</h1>
<h3 id="1-类访问的修饰符">1. 类访问的修饰符</h3>
<ul>
<li>public (C默认情况下)</li>
<li>Private (C++默认情况下)</li>
<li>protected (保护类型的成员, 只能被类内部的函数和友元函数访问)</li>
</ul>
<h3 id="2类的系统函数">2.类的系统函数</h3>
<ul>
<li>构造函数 : 无返回值, 也不返回void, 创建新的对象class 时自动调用</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">//初始化列表的方式给成员赋值
</span><span class="c1"></span><span class="n">Class_name</span><span class="o">::</span><span class="n">Class_name</span><span class="p">(</span><span class="kt">int</span> <span class="n">the_age</span><span class="p">)</span><span class="o">:</span> <span class="n">age</span><span class="p">(</span><span class="n">the_age</span><span class="p">){</span>
    
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>析构函数 : 无返回值, 无传递的参数 ,在删除所创建的对象时执行(对象的生命周期结束时)</li>
<li>拷贝构造函数: 利用一个类之前创建的一个对象, 来初始化一个新对象</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="n">Class_name</span><span class="o">::</span><span class="n">Class_name</span><span class="p">(</span><span class="k">const</span> <span class="n">Class_name</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">){</span>
	<span class="n">code</span><span class="p">...</span>
<span class="p">}</span>
<span class="c1">//e.g. 以下两种情况, 都会调用拷贝构造函数
</span><span class="c1"></span><span class="n">Class_name</span> <span class="n">new_Class</span> <span class="o">=</span> <span class="n">old_Class</span> 
<span class="c1">//or
</span><span class="c1"></span><span class="n">Class_name</span> <span class="n">new_Class</span><span class="p">(</span><span class="n">old_Class</span><span class="p">)</span>   
</code></pre></td></tr></table>
</div>
</div><ul>
<li>赋值运符重载 : 利用赋值运算符 = , 将一个对象赋值给 另一个对象, 注意 , 这两个对象都不是新创建的</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="n">Class_name</span> <span class="o">&amp;</span> <span class="n">Class_name</span><span class="o">::</span><span class="k">operator</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">Class_name</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">){</span>
    <span class="n">code</span> <span class="p">...</span>
<span class="p">}</span>
<span class="c1">//e.g.
</span><span class="c1"></span><span class="n">Class_Name</span> <span class="n">C1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Class_Name</span><span class="p">();</span>
<span class="n">C1</span> <span class="o">=</span> <span class="n">old_one</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="3类的继承">3.类的继承</h3>
<ul>
<li>派生类可以访问基类中的所有非 private 成员</li>
<li>一个派生类继承了所有的基类的方法, 除了, 基类的构造函数, 析构函数, 拷贝构造函数,运算符号重载函数, 友元函数</li>
</ul>
<h3 id="4-c多态">4. C++多态</h3>
<ul>
<li>
<p>C++ 的对象调用成员函数的时候, 会根据调用该成员函数的对象的不同来执行不同的函数.</p>
</li>
<li>
<p>一般的运用场合是在, 两个派生类继承了同一个基类</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="k">class</span> <span class="nc">audi</span> <span class="o">:</span> <span class="k">public</span> <span class="n">car</span><span class="p">{</span>
    <span class="p">...</span>
        <span class="k">public</span> <span class="k">virtual</span> <span class="n">space</span><span class="p">(){</span>
          <span class="n">code</span> <span class="p">...</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">class</span> <span class="nc">bwm</span>  <span class="o">:</span> <span class="k">public</span> <span class="n">car</span><span class="p">{</span>
    <span class="p">...</span>
        <span class="k">public</span> <span class="k">virtual</span> <span class="n">space</span><span class="p">(){</span>
          <span class="n">code</span> <span class="p">...</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">//指向基类的指针, 亦可以指向派生类
</span><span class="c1">//此时一个指针 my_car, 根据指向对象的不同, 导致行为不同
</span><span class="c1"></span><span class="n">car</span> <span class="o">*</span><span class="n">my_car</span><span class="p">;</span>
<span class="n">my_car</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">audi</span><span class="p">;</span>
<span class="n">my_car</span> <span class="o">-&gt;</span> <span class="n">space</span><span class="p">();</span>
<span class="n">my_car</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bwm</span><span class="p">;</span>
<span class="n">my_car</span> <span class="o">-&gt;</span> <span class="n">space</span><span class="p">();</span>
</code></pre></td></tr></table>
</div>
</div><p>注意在需实现多态的函数加入 virtual (虚函数)关键字 : 告诉编译器<strong>不要静态连接</strong>该函数, 从而实现的动态连接</p>
<p><strong>纯虚函数</strong> : 在基类里面便定义某个函数, 基类不去实现它, 而是留给子类去实现.</p>
</li>
</ul>
<h1 id="class-relationships-and-features">Class Relationships and Features</h1>
<h2 id="nested-classes">Nested classes</h2>
<p>类嵌套: 在一个类里面定义一个类</p>
<p>嵌套类拥有外部类的成员所有的访问权限</p>
<h2 id="继承-inheritance--generalisation">继承 Inheritance / Generalisation</h2>
<ol>
<li>
<p>尊从 <strong>is-a</strong> 的类之间关系. 子类叫 : child(derived) class 父类叫 : parent(base) class</p>
</li>
<li>
<p>UML 中利用 <strong>空心三角</strong> 从子类指向父类 :</p>
 <img src='uml1.png' width="400px"/>
</li>
<li>
<p>在声明(instantiation)一个子类的时候 : <code>Customer cust1;</code>
会现调用 <strong>base class 的默认构造函数</strong>, 然后调用 <strong>derived class 的默认构造函数</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>

    <span class="k">private</span> <span class="o">:</span>
    <span class="n">string</span> <span class="n">name</span><span class="p">;</span>

    <span class="k">public</span> <span class="o">:</span>

    <span class="n">A</span><span class="p">(</span><span class="n">string</span> <span class="n">_name</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">_name</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">string</span> <span class="nf">getName</span><span class="p">(){</span>
        <span class="k">return</span> <span class="n">name</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">};</span>

<span class="k">class</span> <span class="nc">B</span> <span class="o">:</span> <span class="k">public</span> <span class="n">A</span> <span class="p">{</span>
    <span class="k">private</span> <span class="o">:</span>
    <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>

    <span class="k">public</span> <span class="o">:</span>
    <span class="cm">/* 如果此时父类的构造函数必须有传递参数, 那么需要用这种方式传递 */</span>
    <span class="n">B</span><span class="p">(</span><span class="kt">int</span> <span class="n">_age</span><span class="p">,</span> <span class="n">string</span> <span class="n">_name</span><span class="p">)</span> <span class="o">:</span> <span class="n">A</span><span class="p">(</span><span class="n">_name</span><span class="p">){</span>
        <span class="n">age</span> <span class="o">=</span> <span class="n">_age</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">B</span> <span class="n">b</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="s">&#34;fz&#34;</span><span class="p">);</span>
    <span class="c1">// cout &lt;&lt; b.name;  compile error, 子类没有对父类 private 成成员的访问权限
</span><span class="c1"></span>	<span class="c1">// 但是可以调用 父类的 getter 函数获得成员变量
</span><span class="c1"></span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">getName</span><span class="p">();</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>🌟 **继承限制, 以下的方法不会被子类继承 : **</p>
<p>构造函数</p>
<p>析构函数</p>
<p>友元函数</p>
<p>重载的 new 操作符</p>
<p>重载的 = 操作符</p>
</li>
<li>
<p>**访问修饰符 : **</p>
<p>列为 base class 的访问修饰符</p>
<p>在子类内部访问父类成员, 只和父类成员修饰符有关. 和继承方法无关.</p>
<table>
<thead>
<tr>
<th></th>
<th>子类内部访问</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td>✅</td>
</tr>
<tr>
<td>protected</td>
<td>✅</td>
</tr>
<tr>
<td>private</td>
<td>❌</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>继承方法</strong></p>
<p><code>class A : public B</code> , <code>class A : protected B</code> , <code>class A : private B</code></p>
<p><img src='acess.png' /></p>
<p>根据继承方法的不同,  会将 base class 转化为不同 权限的成员</p>
</li>
</ol>
<h2 id="polymorphism-多态">polymorphism 多态</h2>
<p>顾名思义, 多态即为多种形态, 一般是一个相同的函数, 根据子类的不同表现出不同行为 :</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt; </span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
 
<span class="k">class</span> <span class="nc">Shape</span> <span class="p">{</span>
   <span class="k">protected</span><span class="o">:</span>
      <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">;</span>
   <span class="k">public</span><span class="o">:</span>
      <span class="n">Shape</span><span class="p">(</span> <span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
      <span class="p">{</span>
         <span class="n">width</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
         <span class="n">height</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="kt">int</span> <span class="nf">area</span><span class="p">()</span>
      <span class="p">{</span>
         <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Parent class area :&#34;</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
         <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
      <span class="p">}</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">Rectangle</span><span class="o">:</span> <span class="k">public</span> <span class="n">Shape</span><span class="p">{</span>
   <span class="k">public</span><span class="o">:</span>
      <span class="n">Rectangle</span><span class="p">(</span> <span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">:</span><span class="n">Shape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
    
      <span class="cm">/* 这种情况实际上是 override base class的 area 函数 */</span>
      <span class="kt">int</span> <span class="nf">area</span> <span class="p">()</span>
      <span class="p">{</span> 
         <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Rectangle class area :&#34;</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
         <span class="k">return</span> <span class="p">(</span><span class="n">width</span> <span class="o">*</span> <span class="n">height</span><span class="p">);</span> 
      <span class="p">}</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">Triangle</span><span class="o">:</span> <span class="k">public</span> <span class="n">Shape</span><span class="p">{</span>
   <span class="k">public</span><span class="o">:</span>
      <span class="n">Triangle</span><span class="p">(</span> <span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">:</span><span class="n">Shape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
    
      <span class="cm">/* 这种情况实际上是 override base class的 area 函数 */</span>
      <span class="kt">int</span> <span class="nf">area</span> <span class="p">()</span>
      <span class="p">{</span> 
         <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Triangle class area :&#34;</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
         <span class="k">return</span> <span class="p">(</span><span class="n">width</span> <span class="o">*</span> <span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span> 
      <span class="p">}</span>
<span class="p">};</span>
<span class="c1">// 程序的主函数
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="n">Shape</span> <span class="o">*</span><span class="n">shape</span><span class="p">;</span>
   <span class="n">Rectangle</span> <span class="n">rec</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">7</span><span class="p">);</span>
   <span class="n">Triangle</span>  <span class="n">tri</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span>
 
   <span class="c1">// 存储矩形的地址
</span><span class="c1"></span>   <span class="n">shape</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rec</span><span class="p">;</span>
   <span class="c1">// 调用矩形的求面积函数 area
</span><span class="c1"></span>   <span class="n">shape</span><span class="o">-&gt;</span><span class="n">area</span><span class="p">();</span>
 
   <span class="c1">// 存储三角形的地址
</span><span class="c1"></span>   <span class="n">shape</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tri</span><span class="p">;</span>
   <span class="c1">// 调用三角形的求面积函数 area
</span><span class="c1"></span>   <span class="n">shape</span><span class="o">-&gt;</span><span class="n">area</span><span class="p">();</span>
   
   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>**注意此时会输出 : **</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Parent class area
Parent class area
</code></pre></td></tr></table>
</div>
</div><p>并不是预期的结果, 是因为在开始的时候, area函数即被绑定 (静态绑定)</p>
<p>导出 **Virtual : ** virtual 的引出, 就是为了解决这个问题.</p>
<p>在函数的前面声明为 virtual 函数 :</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="k">class</span> <span class="nc">Shape</span> <span class="p">{</span>
   <span class="k">protected</span><span class="o">:</span>
      <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">;</span>
   <span class="k">public</span><span class="o">:</span>
      <span class="n">Shape</span><span class="p">(</span> <span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
      <span class="p">{</span>
         <span class="n">width</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
         <span class="n">height</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
      <span class="p">}</span>
	  <span class="cm">/* =0 告诉编译器为纯虚函数 */</span>
      <span class="cm">/* 只有 virture 关键字会展现c++的多态特性 */</span>
      <span class="cm">/* 注意 纯虚函数的类是不能被实例化的 */</span>
      <span class="k">virtual</span> <span class="kt">int</span> <span class="nf">area</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span>
<span class="p">};</span>


<span class="cm">/* 此时再像如上调用, 便可以显出多态特性 */</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>virtual 关键字可以告诉编译器不要静态链接该函数, 而需要在后面进行动态链接 (dynamic, or run-time, binding), 从而实现多态的特性</strong></p>
<p>有以下的几种特性 :</p>
<ul>
<li>
<p>除了构造函数, 任何 non-static 都可以是虚函数</p>
</li>
<li>
<p>Base class 有纯虚函数被继承后, 如果没有被定义,  那么子类也会变成 纯虚类</p>
</li>
<li>
<p><strong>virtual destructor : 通常让子类定义自己的析构函数, 从而可以让子类删除自己的成员 指针, 防止内存 leak</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="cm">/* virtual destructor */</span>
<span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
      <span class="kt">char</span> <span class="o">*</span><span class="n">array</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
<span class="n">Base</span><span class="p">()</span> <span class="p">{</span> <span class="n">array</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span> <span class="p">}</span> <span class="k">virtual</span> <span class="o">~</span><span class="n">Base</span><span class="p">()</span> <span class="p">{</span> <span class="k">delete</span> <span class="p">[]</span> <span class="n">array</span><span class="p">;</span> <span class="p">}</span>
<span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
      <span class="kt">int</span> <span class="o">*</span><span class="n">array</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Derived</span><span class="p">()</span> <span class="p">{</span> <span class="n">array</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">200</span><span class="p">];</span> <span class="p">}</span>
     <span class="o">~</span><span class="n">Derived</span><span class="p">()</span> <span class="p">{</span> <span class="k">delete</span> <span class="p">[]</span> <span class="n">array</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
<span class="n">Base</span> <span class="o">*</span><span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Derived</span><span class="p">;</span> <span class="c1">// . . .
</span><span class="c1"></span><span class="k">delete</span> <span class="n">obj</span><span class="p">;</span> <span class="c1">// both ~Derived and then ~Base are called
</span><span class="c1"></span><span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h2 id="多继承">多继承</h2>
<p>unlike Java, c++ 允许多继承的存在</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="k">class</span> <span class="nc">A</span> <span class="o">:</span> <span class="k">public</span> <span class="n">B</span><span class="p">,</span> <span class="k">public</span> <span class="n">C</span><span class="p">{</span>
	<span class="c1">// code ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>A 同时继承 B 和 C</p>
<p>但是多继承会遇到 <strong>diammaond problem</strong></p>
<h1 id="exception">Exception</h1>
<p>异常就是一个程序不能 deal 的一种情况. c++ 的异常可以抛出. string, int , 以及自定义的对象</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
 
<span class="kt">double</span> <span class="nf">division</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
   <span class="k">if</span><span class="p">(</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>
   <span class="p">{</span>	
      <span class="cm">/* throw a string */</span>
      <span class="cm">/* 同时 throw 的类型可以包括 int, float, 以及自定义class都可以 */</span>
      <span class="k">throw</span> <span class="s">&#34;Division by zero condition!&#34;</span><span class="p">;</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="o">/</span><span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
 
<span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span>
<span class="p">{</span>
   <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>
   <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="kt">double</span> <span class="n">z</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 
   <span class="k">try</span> <span class="p">{</span>
     <span class="n">z</span> <span class="o">=</span> <span class="n">division</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
     <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">z</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
       
   <span class="cm">/* catch 的时候, 要 catch 对应的对象 */</span>
   <span class="p">}</span><span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">msg</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="n">msg</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
   <span class="p">}</span>
 
   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">
/* 抛出类及 catch 方法*/


/* 1. 字符串类型 */
- throw &#34;it is a errror&#34;;
  /* 必须用char* catch */
  catch(const char * s){cout &lt;&lt; s;}


- 
</code></pre></td></tr></table>
</div>
</div><p><strong>当然我们可以自定义一个类抛出 :</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">dividebyzero</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="n">dividebyzero</span><span class="p">();</span>
        <span class="kt">void</span> <span class="nf">printmessage</span><span class="p">();</span>
<span class="k">private</span><span class="o">:</span>
<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">message</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">dividebyzero</span><span class="o">::</span><span class="n">dividebyzero</span><span class="p">()</span> <span class="o">:</span> <span class="n">message</span><span class="p">(</span><span class="s">&#34;Divide by Zero&#34;</span><span class="p">){}</span>
<span class="kt">void</span> <span class="n">dividebyzero</span><span class="o">::</span><span class="n">printmessage</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">message</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">float</span> <span class="nf">quotient</span><span class="p">(</span><span class="kt">int</span> <span class="n">num1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num2</span><span class="p">){</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">num2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="cm">/* 利用这个定义的class 抛出 */</span>
          <span class="k">throw</span> <span class="n">dividebyzero</span><span class="p">();</span>
    <span class="k">return</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span> <span class="n">num1</span> <span class="o">/</span> <span class="n">num2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>我们也可以使用 c++ 的标准异常类 &lt;exception&gt;</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/* 自定义异常, 继承 c++ 标准异常类 */</span>
<span class="k">struct</span> <span class="nc">MyException</span> <span class="o">:</span> <span class="k">public</span> <span class="n">exception</span>
<span class="p">{</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="nf">what</span> <span class="p">()</span> <span class="k">const</span> <span class="k">throw</span> <span class="p">()</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="s">&#34;C++ Exception&#34;</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>对于 c++ 标准异常, 定义如下</strong></p>
<table>
<thead>
<tr>
<th><strong>std::exception</strong></th>
<th>该异常是所有标准 C++ 异常的父类。</th>
</tr>
</thead>
<tbody>
<tr>
<td>std::bad_alloc</td>
<td>使用 new 分配内存失败时候抛出</td>
</tr>
<tr>
<td>std::bad_cast</td>
<td>该异常可以通过 <strong>dynamic_cast</strong> 抛出。</td>
</tr>
<tr>
<td>std::bad_exception</td>
<td>这在处理 C++ 程序中无法预期的异常时非常有用。</td>
</tr>
<tr>
<td>std::bad_typeid</td>
<td>该异常可以通过 <strong>typeid</strong> 抛出。</td>
</tr>
<tr>
<td><strong>std::logic_error</strong></td>
<td>理论上可以通过读取代码来检测到的异常。</td>
</tr>
<tr>
<td>std::domain_error</td>
<td>当使用了一个无效的数学域时，会抛出该异常。</td>
</tr>
<tr>
<td>std::invalid_argument</td>
<td>当使用了无效的参数时，会抛出该异常。</td>
</tr>
<tr>
<td>std::length_error</td>
<td>当创建了太长的 std::string 时，会抛出该异常。</td>
</tr>
<tr>
<td>std::out_of_range</td>
<td>该异常可以通过方法抛出，例如 std::vector 和 std::bitset&lt;&gt;::operator<a href=""></a>。</td>
</tr>
<tr>
<td><strong>std::runtime_error</strong></td>
<td>理论上不可以通过读取代码来检测到的异常。</td>
</tr>
<tr>
<td>std::overflow_error</td>
<td>当发生数学上溢时，会抛出该异常。</td>
</tr>
<tr>
<td>std::range_error</td>
<td>当尝试存储超出范围的值时，会抛出该异常。</td>
</tr>
<tr>
<td>std::underflow_error</td>
<td>当发生数学下溢时，会抛出该异常。</td>
</tr>
</tbody>
</table>
<p><strong>理论上, 每一个 func 都可以抛出异常, 我们也可以在一个函数后显示的定义可能抛出的异常类型 :</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++">
<span class="cm">/* 该函数可能排出 char, double, Employee 类型的异常 */</span>
<span class="kt">int</span> <span class="n">dataEntry</span><span class="p">()</span> <span class="k">throw</span><span class="p">(</span><span class="kt">char</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="n">Employee</span><span class="p">)</span>
    
<span class="cm">/* 以下三种情况函数都表示没有异常抛出 */</span>
<span class="cm">/* 这种形式表示 函数没有异常抛出, 但是在 std=c++11被移除, 直到c++17 回归 */</span>
<span class="kt">int</span> <span class="n">dataEntry</span><span class="p">()</span> <span class="k">throw</span><span class="p">()</span>
<span class="kt">int</span> <span class="n">dataEntry</span><span class="p">()</span> <span class="k">noexcept</span> <span class="cm">/* noexcept(dataEntry()) == true */</span>
<span class="kt">int</span> <span class="n">dataEntry</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>如果 没有 catch 处理函数, 那么这个 program 便会被终止, 为了避免这种情况, 我需要使用一个 default handler 取 捕获所有的 异常</strong></p>
<h1 id="design">Design</h1>
<h2 id="design-patterns">Design Patterns</h2>
<h3 id="singleton-单例">singleton 单例</h3>
<h2 id="design-principle">Design Principle</h2>
<h3 id="coupling-耦合">Coupling 耦合</h3>
<p>is the strength of the connection, or the level of dependency, between two modules.</p>
<p>就是函数或者模块之间的联系程度</p>
<p>松耦合的设计非常有利于代码的扩展, 但是初期开发效率会降低</p>
<h3 id="cohesion-内聚">Cohesion 内聚</h3>
<p>Describes how well the operations in a function relate to one another.</p>
<p>就是一个函数只完成一个任务</p>
<p>where all function operations contribute to the performance of only one task.</p>
<h3 id="observer-and-mutator">observer and mutator</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">/* */
就是 getter , setter 函数

observer =&gt; getter

mutator  =&gt; setter

通过这两个函数对私用变量进行操作
</code></pre></td></tr></table>
</div>
</div><h1 id="泛化-generic">泛化 Generic</h1>
<h2 id="函数模版-function-template">函数模版 function template</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">reverse</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">){</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">x</span><span class="p">;</span>    
<span class="p">}</span>

<span class="cm">/* same as */</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">reverse</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">){</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">x</span><span class="p">;</span>    
<span class="p">}</span>


<span class="cm">/* 模版可以接受多个类 */</span>
<span class="cm">/* T, E 是不同的类*/</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">E</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">,</span> <span class="n">E</span> <span class="n">y</span><span class="p">){</span>
	<span class="c1">// code ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>函数模版是编译期行为  :</p>
<p><img src='template.png' /></p>
<h2 id="类模版-class-template">类模版 class template</h2>
<p>类似于 函数模版</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">Stack</span> <span class="p">{</span> 
        <span class="k">private</span><span class="o">:</span> 
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">elems</span><span class="p">;</span>     <span class="c1">// 元素 
</span><span class="c1"></span>
        <span class="k">public</span><span class="o">:</span> 
        <span class="kt">void</span> <span class="n">push</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">);</span>  <span class="c1">// 入栈
</span><span class="c1"></span>        <span class="kt">void</span> <span class="nf">pop</span><span class="p">();</span>               <span class="c1">// 出栈
</span><span class="c1"></span>        <span class="n">T</span> <span class="nf">top</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>            <span class="c1">// 返回栈顶元素
</span><span class="c1"></span>        <span class="kt">bool</span> <span class="nf">empty</span><span class="p">()</span> <span class="k">const</span><span class="p">{</span>       <span class="c1">// 如果为空则返回真。
</span><span class="c1"></span>            <span class="k">return</span> <span class="n">elems</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span> 
        <span class="p">}</span> 
    <span class="p">};</span> 
</code></pre></td></tr></table>
</div>
</div><h1 id="stl">STL</h1>
<p>The Standard Template Library for C++. STL 包括 <strong>six major kinds of components</strong></p>
<ul>
<li>Containers</li>
<li>Iterators</li>
<li>Generic algorithm</li>
<li>Funcion object</li>
<li>Adaptors</li>
<li>Allocators</li>
</ul>
<h2 id="stl-container">STL container</h2>
<p><strong>Sequential container</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">/* STL Container 可以包含以下 : */

// 动态数组
- vector : lexible-size array. Supports fast random access. Inserting/deleting other than 	at the back may be slow.


// 双端队列 
- deque : Double-ended queue. Supports fast random access. Fast insert/delete at front or back.
  双端队列中的元素可以从两端弹出，相比list增加[]运算符重载
  

// 双向链表
- list : Doubly linked list. Supports only bidirectional sequential access. Fast insert/delete at any point.


/------------------------ 关联容器 (Associative container) ---------------------------/


// 集合/多重集合
- set : 底层实现是一种高效的平衡二叉树，即红黑树（Red-Black Tree）, 其中元素不允许重复, 插入便自动排序

- multset : 和 set 完全类似, 唯一区别就是, 运行重复值


// 散列表

- map : &lt;key, value&gt; 形式存储数据

</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">/* 重要特性 */
/* ----------------------------- vector ------------------------------*/

/* ---- 非成员函数 -----*/
- remove 函数 : 
  template&lt;class ForwardIterator, class T&gt;
  ForwardIterator remove(ForwardIterator first, ForwardIterator last, const T&amp; value);
  * 也就是说, rermove 函数有三个参数, 前两个分别是容器的迭代器表示的区间, 最后表示一个需要被删除的值
  * remove 不会改变容器的长度
  * remove 的作用是, 将需要删除值移动到容器的底部, 然后返回一个新的迭代器终点, 完成逻辑删除
	

- remove_if() 函数 :
  * 三个参数, 前两个为迭代器区间, 最后为一个自定义函数, bool 返回值表示要删除的元素
  * 类似于 remove 函数, 返回一个新的逻辑终点
  
  
  for example : 
  vector&lt;int&gt; charList = {&#39;a&#39;, &#39;A&#39;, &#39;B&#39;};
  
  /* &#34;删除&#34;vector 里面值为&#39;A&#39; 的元素 */
  vector&lt;int&gt;::iterator newEnd = remove_if(charList.begin(), charList.end(), isA);
  
 
  /* 自定义函数 */
  bool isA(const char &amp; obj){

        if(obj == &#39;A&#39;){
            return true;
        }

        return false;
    }


/* ---- 成员函数 -----*/
- earse() 函数 : 
  删除一个元素, 接受一个元素的迭代器
  


- 构造函数
  for exmaple :
  /* one 表示包含了 7 个 &#34;one&#34; 的vector */
  vector&lt;string&gt; one(7, &#34;one&#34;);
  	
  /* two 表示包含 2 个 &#34;one&#34; 的vector */
  vector&lt;string&gt; two(one.begin()+2, one.end()-3);
  
  
  
  

/* ----------------------------- list ------------------------------*/
双向链表, 可以实现快速的插入, 删除操作

/* ---- 成员函数 -----*/

- push_front(T ele)
  向 list 的头插入元素
  
  
- push_back(T ele)
  想 list 尾插入元素
  
  
  
/* ----------------------------- deque ------------------------------*/

/* ---- 非成员函数 -----*/

- front_inserter(container)
  在 container 采用头插法插入元素





/* ---- 成员函数 -----*/

- push_front(T ele);
  双端队列头插入
  
- push_back(T ele);
  双端队列尾插入

- pop_front();

- pop_back();





/* ----------------------------- multiset ------------------------------*/

/* ---- 成员函数 -----*/

- insert(T ele)
  插入一个元素
  
  
- count(T ele)
  统计 multiset 中 ele 的数量

- lower_bound(T ele)
  返回的是第一个大于等于给定元素key的位置

- upper_bound(T ele)
  返回的是第一个大于给定元素key的位置

- equal_range(T ele)
  返回一个 pair 对象 
  其first和second成员都成为迭代器，且分别指向输入序列中所有值等于 val 的元素所组成的子序列的起始及末尾

  即最后一个元素之后的位置 (之后的位置按查找顺序算, 而不是插入顺序)

</code></pre></td></tr></table>
</div>
</div><h2 id="stl-适配器">STL 适配器</h2>
<h3 id="ostream_iterator">ostream_iterator</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">/* def */
- 属于I/O流STL适配器，用于获取一个元素，同时保存在缓冲器中，可以供Cout输出

- 那么在Cout对象当中存在一片用于数据存储的区域。ostream_iterator在STL中一般配合copy函数一起使用


/* 用法 */

// template =&gt; 设置要输出的类型
// 关联cout，设置分隔符, 及输出结果中间将会间隔 &#34; &#34;
ostream_iterator&lt;char&gt; output(cout, &#34; &#34;); 

/* 注意这里的传递参数为迭代器变量 */
copy(ivec.begin(), ivec.end(), output); //元素拷贝到ostream_iterator所指向的对象cout

cout; //显示cout的值
</code></pre></td></tr></table>
</div>
</div><h2 id="stl-迭代器类型">STL 迭代器类型</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">/* STL的迭代器可以做如下的分类 */
/* 不同的container 支持的迭代器类型也有差异 */

- 输入迭代器
  只能向容器读元素, 但是不能写元素

- 输出迭代器
  只能向容器写元素, 但是不能读元素
  

/ ---------------- 常用三个 ------------------- /
/* 下面三类迭代器都对 i/o 跌代器做了整合 */

- 前向迭代器 (forward iterator):
  可以对指向容器多次读写. 但只能前向传播.
  即只能做形如 it++ 的操作, 且一次只能加1
  for exmaple : 单向链表的迭代器

- 双向迭代器 (bidirectional iterator)
  在前向迭代器的功能更近一步, 可以支持 向前, 向后操作
  即可以 it++, it--, 但是一次只能 +, - 1
  for exmaple : 双向链表的迭代器
  
- 随机存取迭代器 (randon access iterator)
  在双向更近一步, 在支持前后的同时, 可以支持随机数值的 +, -
  即可以 : it+=n;
  for exmaple : 动态数组的迭代器

</code></pre></td></tr></table>
</div>
</div><h1 id="io">IO</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">/* 库 */
- c++ 文件操作使用标准lib : &lt;fstream&gt;

/* 常用类型 */

- ofstream : 输出流 

- ifstream : 输入流

🌟 - fstream : 同时具有输出输入的功能 

</code></pre></td></tr></table>
</div>
</div><p>文件打开模式 :</p>
<table>
<thead>
<tr>
<th>模式标志</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ios::app</td>
<td>追加模式。所有写入都追加到文件末尾。</td>
</tr>
<tr>
<td>ios::ate</td>
<td>文件打开后定位到文件末尾。</td>
</tr>
<tr>
<td>ios::in</td>
<td>打开文件用于读取。</td>
</tr>
<tr>
<td>ios::out</td>
<td>打开文件用于写入。</td>
</tr>
<tr>
<td>ios::trunc</td>
<td>如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。</td>
</tr>
<tr>
<td>ios::binary</td>
<td>Binary mode 打开</td>
</tr>
</tbody>
</table>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/* example */</span>
<span class="n">ofstream</span> <span class="n">outfile</span><span class="p">;</span>
<span class="n">outfile</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="s">&#34;file.dat&#34;</span><span class="p">,</span> <span class="n">ios</span><span class="o">::</span><span class="n">out</span> <span class="o">|</span> <span class="n">ios</span><span class="o">::</span><span class="n">trunc</span> <span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/* example */</span>

<span class="c1">// 创建流对象
</span><span class="c1"></span><span class="n">fstream</span> <span class="n">outfile</span><span class="p">;</span>

<span class="c1">// 打开文件
</span><span class="c1">// 传入文件名可以为 char[], 也可以为 string 类型
</span><span class="c1"></span><span class="n">outfile</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="s">&#34;test.dat&#34;</span><span class="p">,</span> <span class="n">ios</span><span class="o">::</span><span class="n">binary</span><span class="p">);</span>

<span class="n">outfile</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;hello world&#34;</span><span class="p">;</span>

<span class="n">outfile</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="转化函数">转化函数</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/* string to char* */</span>	
<span class="kt">char</span> <span class="n">ch</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
<span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&#34;123&#34;</span><span class="p">;</span>
<span class="n">strcpy</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span><span class="n">s</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>

<span class="cm">/* char* to string */</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">ch</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#34;123&#34;</span><span class="p">};</span>
<span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="n">ch</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div>
    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">LYR</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        0001-01-01
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      
      <nav class="post-nav">
        <a class="prev" href="/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/algorithm/%E6%88%91%E7%88%B1%E7%AE%97%E6%B3%95/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default"></span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/10.%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/c&#43;&#43;/readme/">
            <span class="next-text nav-default"></span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:lyr-2000@qq.com" class="iconfont icon-email" title="email"></a>
  <a href="http://doc.lyr-2000.xyz/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021<span class="heart"><i class="iconfont icon-heart"></i></span><span>lyr</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>








</body>
</html>
