---
title: "双指针算法"
date: 2021-08-14T22:42:48+08:00
draft: false
---

### [15\. 三数之和](https://leetcode-cn.com/problems/3sum/)

Difficulty: **中等**


给你一个包含 `n` 个整数的数组 `nums`，判断 `nums` 中是否存在三个元素 _a，b，c ，_使得 _a + b + c =_ 0 ？请你找出所有和为 `0` 且不重复的三元组。

**注意：**答案中不可以包含重复的三元组。

**示例 1：**

```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
```

**示例 2：**

```
输入：nums = []
输出：[]
```

**示例 3：**

```
输入：nums = [0]
输出：[]
```

**提示：**

*   `0 <= nums.length <= 3000`
*   `-10<sup>5</sup> <= nums[i] <= 10<sup>5</sup>`


#### Solution

Language: ****

```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        sort(nums.begin(),nums.end() );
        int n = nums.size();
        //b+c = -a
        //a + b + c = 0;
        // unordered_set<int> in;
        vector< vector<int >> res;
        for(int i=0;i<n ;++i) {
            int a = nums[i];
            int p = i+1, q = n-1;
            if(p>= n || q<= p) break;
            if(i && nums[i] == nums[i-1]) continue;
            
            while(p< q) {
                
                int b = nums[p] , c = nums[q];
                int t  = a+b + c;
                if(t <0) {
                    p++;
                }else if(t > 0) {
                    q--;
                }else {
                    res.push_back({ a, b, c });
                    while(p<q  && nums[q] == nums[q-1]) --q;
                    while(p<q && nums[p] == nums[p+1]) ++p;
                    q--;
                    p++;
                     
                 
                }
            }
        }
        return res;
    }
};
```

### [18\. 四数之和](https://leetcode-cn.com/problems/4sum/)

Difficulty: **中等**


给你一个由 `n` 个整数组成的数组 `nums` ，和一个目标值 `target` 。请你找出并返回满足下述全部条件且不重复的四元组 `[nums[a], nums[b], nums[c], nums[d]]` ：

*   `0 <= a, b, c, d < n`
*   `a`、`b`、`c` 和 `d` **互不相同**
*   `nums[a] + nums[b] + nums[c] + nums[d] == target`

你可以按 **任意顺序** 返回答案 。

**示例 1：**

```
输入：nums = [1,0,-1,0,-2,2], target = 0
输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
```

**示例 2：**

```
输入：nums = [2,2,2,2,2], target = 8
输出：[[2,2,2,2]]
```

**提示：**

*   `1 <= nums.length <= 200`
*   `-10<sup>9</sup> <= nums[i] <= 10<sup>9</sup>`
*   `-10<sup>9</sup> <= target <= 10<sup>9</sup>`


#### Solution

Language: ****

```c++
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        sort(nums.begin(),nums.end());
        //a + b + c + d == target ->
        //d == target - a - b - c - d
        vector<vector<int>> res;
        int n = nums.size();
        for(int i=0;i<n ;++i) {
            int a= nums[i];
            if(i && a == nums[i-1] ) continue;
            for(int j=i+1;j<n;++j) {
                int b = nums[j];
                if(j>i+1 && b == nums[j-1]) continue;
                int p = j+1, q = n-1;
                // if(q<=p) break;
                while(p < q ) {
                   
                    int c = nums[p] , d= nums[q];
                    int t = (long long)a+ b+c+d - target;
                    if(t==0) {
                        res.push_back({a,b,c,d});   
                        while(p<q && nums[p+1] == nums[p]) ++p;
                        while(p<q && nums[q-1] == nums[q]) --q;
                        ++p;
                        --q;
                         
                    }else if(t > 0) {
                        --q;
                    }else {
                        ++p;
                    }
                }
            }
        }
        return res;
    }
};
```

### 早餐组合

小扣在秋日市集选择了一家早餐摊位，一维整型数组 staple 中记录了每种主食的价格，一维整型数组 drinks 中记录了每种饮料的价格。小扣的计划选择一份主食和一款饮料，且花费不超过 x 元。请返回小扣共有多少种购买方案。

注意：答案需要以 1e9 + 7 (1000000007) 为底取模，如：计算初始结果为：1000000008，请返回 1

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/2vYnGI
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



```cpp
const int MOD = 1E9+7;
class Solution {
public:
    int breakfastNumber(vector<int>& staple, vector<int>& drinks, int x) {
        sort(staple.begin(),staple.end());
        sort(drinks.begin(),drinks.end());
        int l=0,r = drinks.size()-1;
        int n = staple.size();
        int res=0;
        long long e=0;
        while(l<n && r>=0) {
            e = staple[l] + drinks[r];
            if( e <= x) {
                res = ( res+r+1 ) % MOD;
                ++l;
            }else if (e > x) {
                r--;

            }
        }
        return res;
    }
};
```





