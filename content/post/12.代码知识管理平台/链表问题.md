---
title: "链表问题"
date: 2021-08-14T22:42:48+08:00
draft: true
---



### [82\. 删除排序链表中的重复元素 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/)

Difficulty: **中等**


存在一个按升序排列的链表，给你这个链表的头节点 `head` ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中 **没有重复出现**的数字。

返回同样按升序排列的结果链表。

**示例 1：**

![](https://assets.leetcode.com/uploads/2021/01/04/linkedlist1.jpg)

```
输入：head = [1,2,3,3,4,4,5]
输出：[1,2,5]
```

**示例 2：**

![](https://assets.leetcode.com/uploads/2021/01/04/linkedlist2.jpg)

```
输入：head = [1,1,1,2,3]
输出：[2,3]
```

**提示：**

*   链表中节点数目在范围 `[0, 300]` 内
*   `-100 <= Node.val <= 100`
*   题目数据保证链表已经按升序排列


#### Solution

Language: ****

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
         ListNode d(-2000) ;
         ListNode* p = &d;
        //  bool init = false;
         while(head) {
             
            if(head && head->next) {
                //判断重复节点
                auto x  = head ,y = head->next;
                if(x->val == y->val) {
                    while (y && x->val ==y->val ) {
                        if(y) y = y->next;
                    }
                    head = y;
                }else {
                    p->next = x;
                    p = x;
                    p->next = NULL;
                    head = y;

                }


            }else {
                p->next = head;
                head  = head->next;
            }
 
         }
         return d.next;




    }
};
```

