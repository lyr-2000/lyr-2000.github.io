---
title: "通信线路"
date: 2021-08-14T22:42:48+08:00
draft: true


---



####  通信线路



在郊区有 N 座通信基站，P  条 **双向** 电缆，第 ii 条电缆连接基站 $ A_i $  和 $B_i$ 。

特别地，1 号基站是通信公司的总站，N  号基站位于一座农场中。

现在，农场主希望对通信线路进行升级，其中升级第 ii 条电缆需要花费 Li。

电话公司正在举行优惠活动。

农产主可以指定一条从 11 号基站到 N  号基站的路径，并指定路径上不超过 K  条电缆，由电话公司免费提供升级服务。

农场主只需要支付在该路径上剩余的电缆中，升级价格最贵的那条电缆的花费即可。

求至少用多少钱可以完成升级。

#### 输入格式

第 11 行：三个整数 N，P，K 。

第 2..P+12..P+1 行：第 i+1i+1 行包含三个整数 Ai,Bi,Li 。

#### 输出格式

包含一个整数表示最少花费。

若 11 号基站与 N  号基站之间不存在路径，则输出 − 1。

#### 数据范围



```
0≤K<N≤1000 ,
1≤P≤10000 ,
1≤Li≤1000000

```



#### 输入样例：

```
5 7 1
1 2 5
3 1 4
2 4 8
3 2 3
5 2 9
3 4 7
4 5 6
```

#### 输出样例：

```
4
```





### 解题代码



```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 1000+100;
int n,m,k;
bool state[MAXN];
int  dist[MAXN];
unordered_map<int,vector<pair<int,int> > > path;

bool check(int x) {
   
    memset(state,0,sizeof state);
    memset(dist,0x3f,sizeof dist);
    dist[1] = 0;
    deque<int> q;
    q.push_back(1);
    while(q.size()) {
        int u = q.front();
        q.pop_front();
        if(state[u]) continue;
        state[u] = 1;
        for(auto p: path[u]) {
            int v= p.first, len = p.second;
            int w = len> x;
            if (dist[v]  > dist[u] + w) {
                dist[v] = dist[u] + w;
                if(!w) q.push_front(v);
                else q.push_back(v);
            }
           
        }
    }
    return dist[n] <= k;
    
}

int main()
{
    cin>> n>>m >>k;
    while(m--) {
        int a,b,c;
        cin>> a>>b>>c;
        path[a].push_back({b,c});
        path[b].push_back({a,c});
    }
    int l=0,r = 1e6 + 1;
    while(l<r) {
        int mid = l+r >>1;
        if(check(mid)) r = mid;
        else  l = mid + 1; //越大越好
    }
    if ( r ==  1e6+1) l = -1;
    cout << l  <<endl;
    
    return 0;
}
```

