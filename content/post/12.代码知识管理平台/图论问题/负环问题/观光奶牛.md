---
title: "观光奶牛"
date: 2021-08-14T22:42:48+08:00
draft: true

---







### 观光奶牛

给定一张 L  个点、 P 条边的有向图，每个点都有一个权值 f[i] ，每条边都有一个权值 t[i] 

求图中的一个环，使“环上各点的权值之和”除以“环上各边的权值之和”最大。

输出这个最大值。

**注意**：数据保证至少存在一个环。

#### 输入格式

第一行包含两个整数 L  和 P 。

接下来 L 行每行一个整数，表示 f[i] 

再接下来 P  行，每行三个整数 a，b，t[i] ，表示点 a 和 b 之间存在一条边，边的权值为 t[i] 。

#### 输出格式

输出一个数表示结果，保留两位小数。

#### 数据范围

2≤L≤1000 
2≤P≤5000 
1≤f[i],t[i]≤1000 

#### 输入样例：

```
5 7
30
10
10
5
10
1 2 3
2 3 2
3 4 5
3 5 2
4 5 5
5 1 3
5 2 2
```

#### 输出样例：

```
6.00
```





## 思路分析




$$
\Sigma {f_i}/ \Sigma{t_i} > MID
$$
等价于：
$$
\Sigma{f_i} - \Sigma{t_i}*MID>0
$$
等价于
$$
\Sigma{ (f_i- t_i*MID) } > 0
$$
听过这个推导，我们就可以  求出每一项的 $f_i - t_i*mid$ 然后加起来 看看是否得到的值最大 【记录最大的那个方案】





 

## 解题代码



```cpp
#include<bits/stdc++.h>
using namespace std;
#define PII pair<int,int>
#define next NEXT
#define x first
#define y second
//01 分布规划问题

int n,m;
unordered_map<int,vector<PII>> g;
const int MAXN = 1200;;
int f[MAXN];
bool vis[MAXN];
int cnt[MAXN];
double dist[MAXN];
bool inline check(double MID) {
    memset(dist,0,sizeof dist);
    memset(cnt,0,sizeof cnt);
    memset(vis,false,sizeof vis);
    queue<int > q;
    for(int i=1;i<=n;++i) {
        vis[i] = true;
        q.push(i);
       
    }
    while(q.size()) {
        int u = q.front() ; q.pop();
        vis[u] = false;
        for(auto next: g[u]) {
            int v = next.first;
            double w = f[u] - MID*next.second;
            if(dist[v] < w + dist[u]) {
                //要求最大，也就是最长路径
                dist[v] = dist[u] +  w;
                cnt[v] = cnt[u] + 1;
                if(cnt[v] >=n) return true;
                //出现负环
                if(!vis[v]  )
                    q.push(v);
                    
            }
        }
    }
    return false;
}

int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;++i)
        cin>>f[i];
    for(int j=0;j<m;++j) {
        int a,b,w;
        cin>> a>>b >>w;
        //t[i] = w
        g[a].push_back({b,w});
        //a->b->c->a  环的权值最大  sum{node_a} / sum{edge_a} 最大
        
       // g[b].push_back({a,w});
    }
    
    double l=0,r = 1e6;
    //double eps = 1e-4;
    while(r-l > 1e-5) {
        double mid  = (l + r)/2;
        if(check(mid)) l = mid;
        else r = mid ;
        
    }
    printf("%.2lf\n",l);
    
    
    return 0;
}
```

