---
title: "糖果"
date: 2021-08-14T22:42:48+08:00
draft: true

---

幼儿园里有 NN 个小朋友，老师现在想要给这些小朋友们分配糖果，要求每个小朋友都要分到糖果。

但是小朋友们也有嫉妒心，总是会提出一些要求，比如小明不希望小红分到的糖果比他的多，于是在分配糖果的时候， 老师需要满足小朋友们的  K 个要求。

幼儿园的糖果总是有限的，老师想知道他至少需要准备多少个糖果，才能使得每个小朋友都能够分到糖果，并且满足小朋友们所有的要求。

#### 输入格式

输入的第一行是两个整数 N,KN,K。

接下来 K  行，表示分配糖果时需要满足的关系，每行  3 个数字 X,A,B 

- 如果 X=1 ．表示第 A  个小朋友分到的糖果必须和第 B  个小朋友分到的糖果一样多。
- 如果 X=2 ，表示第 A  个小朋友分到的糖果必须少于第 B  个小朋友分到的糖果。
- 如果 X=3 ，表示第 A  个小朋友分到的糖果必须不少于第 B  个小朋友分到的糖果。
- 如果 X=4  ，表示第 A  个小朋友分到的糖果必须多于第 B  个小朋友分到的糖果。
- 如果 X=5 ，表示第 A 个小朋友分到的糖果必须不多于第 B 个小朋友分到的糖果。

小朋友编号从  1 到 N 。

#### 输出格式

输出一行，表示老师至少需要准备的糖果数，如果不能满足小朋友们的所有要求，就输出 −1 。

#### 数据范围

$1≤N<10^5$ 
$ 1≤K≤10^5 $ 
$ 1≤X≤5 $ 
$1 ≤A,B≤N $ 

#### 输入样例：

```
5 7
1 1 2
2 3 2
4 4 1
3 4 5
5 4 5
2 3 5
4 5 1
```

#### 输出样例：

```
11
```





### 解题代码



```cpp
#include<bits/stdc++.h>
using namespace std;
//a>=b   ->  dist[a] >= dist[b]
//a>b     -> dist[a] >= dist[b] + 1
// 这样的等式，可以知道
//a >b , b> c, a<c ,是矛盾的，因为
/*
dist[a] = dist[b] + 1
dist[b] = dist[c] + 1
dist[a] = dist[c] -1 , 这个明显矛盾
*/
#define  INFO pair<int,int> 
// unordered_map<int,vector<INFO>> path;

int n,m;
const int MAXN = 1e5+100,MAXM  = 3e6+300;
struct Edge{
    int to,w,next;
    
}listNode[MAXM];
int head[MAXM], id;

void add(int u,int v, int w) {
     ++id;
     //相当于 ListNode * p = new ListNode(id)
     listNode[id].to = v,
     listNode[id].w = w;
     listNode[id].next = head[u];
     head[u] = id;
}
long long dist[MAXN] ;
int cnt[MAXN];
bool state[MAXN];
bool spfa(int u) {
    deque<int> stk;
    stk.push_back(u);
    //我们求出最短路径
    memset(dist,-0x3f,sizeof dist);
    dist[u] = 0;
    while(stk.size()) {
        int u = stk.back();stk.pop_back();
        state[u] = 0;
        for(int j = head[u];j; j = listNode[j].next) {
            int v = listNode[j].to, w = listNode[j].w;
            if(dist[v] < dist[u] + w) {
                dist[v] = dist[u] + w;
                cnt[v] = cnt[u] +1;
                if(cnt[v] >= 1+ n) return false;
                if(!state[v]) {
                    state[v] = 1;
                    stk.push_back(v);
                }
            }
        }
    }
    return true;
}
int main()
{
    
    cin>> n>>m;
    while(m--) {
        int X,a,b;
        cin>> X>> a>>b;
    
        if(X==1)  add(a,b,0),add(b,a,0); //A=B
        else if(X==2) add(a,b,1); //B>=A+1 , a -> 1 -> b
        else if(X==3) add(b,a,0); //a>=b
        else if(X== 4) add(b,a,1); //a>=b+1
        else  add(a,b,0); //b>=a
        
    }
    for(int i=1;i<=n;++i) add(0,i,1); // a[i] >= dist[0] + 1
    if(spfa(0) == 0) puts("-1");
    else {
        long long res= 0;
        for(int i=1;i<=n;++i) res += dist[i];
        cout << res <<endl;
        
    }
    
    
    return 0;
}
```

