---
title: "最短路计数问题1"
date: 2021-08-14T22:42:48+08:00
draft: true

---









给出一个 N  个顶点 M 条边的无向无权图，顶点编号为 1 到 N。

问从顶点 1 开始，到其他每个点的最短路有几条。

#### 输入格式

第一行包含 2  个正整数 N,M 为图的顶点数与边数。

接下来 M 行，每行两个正整数 x,y 表示有一条顶点  x 连向顶点 y 的边，请注意可能有自环与重边。

#### 输出格式

输出 N  行，每行一个非负整数，第 i 行输出从顶点 1 到顶点 i 有多少条不同的最短路，由于答案有可能会很大，你只需要输出对 100003 取模后的结果即可。

如果无法到达顶点 i 则输出 00。

#### 数据范围

$1≤N≤10^5 $ 
$1≤M≤2×10^5 $

 

#### 输入样例：

```
5 7
1 2
1 3
2 4
3 4
2 3
4 5
4 5
```

#### 输出样例：

```
1
1
1
2
4
```



### 解题代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN  = 1e5+10;
int vis[MAXN];
int dist[MAXN];
int cnt[MAXN];
//请注意可能有自环与重边。
#define PII int

queue<int > q;
unordered_map<int,vector<PII>> path;
void bfs(int u) {
    q.push(u);
    memset(dist,0x3f,sizeof dist);
    dist[u] = 0;
    cnt[u] = 1;
    while(q.size()) {
        int t = q.front();q.pop();
        for(auto next: path[t]) {
            if(dist[next  ] > dist[t] +  1) {
                dist[next ] = dist[t] + 1;
                q.push(next);
                cnt[next]= cnt[t];
            }else if(dist[next  ] == dist[t] + 1) {
                cnt[next ] = (cnt[next ] + cnt[t]) % 100003;
            }
        }
    }
}
int main(void)
{
    
    int n,m;
    cin>> n>>m;
    for(int i=0;i<m;++i) {
        int x,y;
        cin>>x>>y;
        path[x].push_back(y);
        path[y].push_back(x);
    }
    
    bfs(1);
    for(int i=1;i<=n;++i) cout << cnt[i] <<endl;
    return 0;
}
```

