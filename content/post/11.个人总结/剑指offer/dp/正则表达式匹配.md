---
title: "正则表达式匹配"
date: 2021-08-17T13:48:22+08:00
draft: false
author: LYR


---

请实现一个函数用来匹配包括`'.'`和`'*'`的正则表达式。

模式中的字符`'.'`表示任意一个字符，而`'*'`表示它**前面的字符可以出现任意次**（含0次）。

在本题中，匹配是指字符串的所有字符匹配整个模式。

例如，字符串`"aaa"`与模式`"a.a"`和`"ab*ac*a"`匹配，但是与`"aa.a"`和`"ab*a"`均不匹配。

#### 样例

```
输入：

s="aa"
p="a*"

输出:true
```



## 解题代码





参考学习视频:

[学习视频](https://www.bilibili.com/video/BV1C54y1s73i?from=search&seid=1070166952728500995&spm_id_from=333.337.0.0)



```cpp
class Solution {
public:
    bool pre_match(string &s,string &p,int i,int j) {
        if(i<0 || j<0 || i>s.size() && j>p.size()) return false;
        return s[i] == p[j] || p[j] =='.';
    }
    bool isMatch(string s, string p) {
        int n =s.size()  , m = p.size()  ;
        //dp[i,j] , 前 i 个字符和 前 j 个字符是否匹配
        vector<vector<int>> dp(n+5,vector<int> (m+5));
        dp[0][0] = 1;
        for(int j=2;j<=m;++j)
        {
            dp[0][j] = p[j-1] =='*' && dp[0][j-2];
        }
        for(int i=0;i<n;++i){
            for(int j=0;j<m;++j) {
                if(p[j] =='*') {
                    dp[i+1][j+1] = dp[i+1][j-1] ||(  pre_match(s,p,i,j-1) && dp[i ][j+1]);
                }else 
                    dp[i+1][j+1] =  pre_match(s,p,i,j) && dp[i][j];
            }
        }
        
        
        return dp[n  ][m ];
    }
};
```







## 记忆化搜索解法



```cpp
class Solution {
public:
    bool isMatch(string _s, string _p) {
        s = _s, p = _p;
        f = vector<vector<int>> (s.size()+1,vector<int>(p.size() +1,-1));
        return dfs(0,0);
    }
    string s,p;
    vector<vector<int>> f;
    bool dfs(int si,int pi) {
        if(f[si][pi] != -1) {
            return f[si][pi];
        }
        if(pi == p.size())
            return f[si][pi] = si == s.size();
        //pi 到达终点了， si也要同时到达终点
        bool pre_match = si < s.size() && (s[si] == p[pi] || p[pi] == '.');
        bool ans = false;
        if(pi+1<p.size() && p[pi+1] =='*' ) {
            // p[pi] 是否匹配 si + 1
            //或者 出现0 次，用 pi + 2 来匹配
            ans = dfs(si ,pi+2) || (pre_match && dfs(si + 1,pi)) ;
            
        }
        else {
            //不等于 *
            ans = pre_match && dfs(si+1,pi+1);
        }
        return f[si][pi] = ans;
    }
};
```





