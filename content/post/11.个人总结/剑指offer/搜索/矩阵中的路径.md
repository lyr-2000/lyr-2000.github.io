---
title: "矩阵中的路径"
date: 2021-08-17T13:48:22+08:00
draft: false
author: LYR
---

请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。

路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。

如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。

**注意：**

- 输入的路径不为空；
- 所有出现的字符均为大写英文字母；

#### 样例

```
matrix=
[
  ["A","B","C","E"],
  ["S","F","C","S"],
  ["A","D","E","E"]
]

str="BCCE" , return "true" 

str="ASAE" , return "false"
```





```cpp
class Solution {
public:
    int n,m;
    int slen;
    bool hasPath(vector<vector<char>>& matrix, string &str) {
        slen = str.size();
        n = matrix.size();
        if(slen ==  0 || n == 0) return false;
        m = matrix[0].size();
        if(m == 0) return false;
        
        for(int i=0;i<n;++i) {
            for(int j=0;j<m;++j) {
                if(dfs(matrix,str,i,j,0)) return true;
            }
        }
        return false;
        
        
    }
    
    bool dfs(vector<vector<char>>& matrix, string &str,int x,int y,int len) {
        if(len >= slen) return true;
        char pre = matrix[x][y];
        if(pre != str[len]) return false;
        
        if(len == slen-1) return true;
        
       
        
        int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};
        bool found = false;
        matrix[x][y] = '+';
        for(int i=0;i<4;++i) {
            int nx = x  + dx[i],
                ny = y  + dy[i];
            if(nx>= 0 && nx <n &&ny >=0  && ny<m) {
                
                found = found || dfs(matrix,str,nx,ny,len + 1);
                if(found) break;
            }
        }
        matrix[x][y] = pre;
        return found;
    }
};
```

