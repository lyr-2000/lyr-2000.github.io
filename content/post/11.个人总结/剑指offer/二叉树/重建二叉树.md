---
title: "重建二叉树"
date: 2021-08-17T13:48:22+08:00
draft: false
author: LYR
---

## 重建二叉树



输入一棵二叉树前序遍历和中序遍历的结果，请重建该二叉树。

**注意**:

- 二叉树中每个节点的值都互不相同；
- 输入的前序遍历和中序遍历一定合法；

#### 样例

```
给定：
前序遍历是：[3, 9, 20, 15, 7]
中序遍历是：[9, 3, 15, 20, 7]

返回：[3, 9, 20, null, null, 15, 7, null, null, null, null]
返回的二叉树如下所示：
    3
   / \
  9  20
    /  \
   15   7
```



## 解题思路



前序： 根左右

中序 ： 左根右

## 解题代码



```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    unordered_map<int,int> mp;
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        int n = inorder.size();
        if(n<=0 || preorder.size() != n) return NULL;
        for(int i=0;i<n;++i) mp[inorder[i]] = i;
        
        return dfs(preorder,inorder,0,n-1,0,n-1);
        
    }
    
    TreeNode *dfs(vector<int>&p,vector<int> &i, int pl,int pr,int il,int ir) {
        //root value
        if(pl > pr|| il > ir) return NULL;
        #define Node TreeNode
        Node *root = new Node(p[pl]);
        // 中序： 左根右
        int mid = mp[root->val];
        int SIZE = mid - il;
        root->left = dfs(p,i,pl+1,pl+ SIZE, il,mid - 1);
        root->right = dfs(p,i,pl+SIZE+1,pr, mid + 1, ir);
        return root;
        
        
    }
    
    
};
```

