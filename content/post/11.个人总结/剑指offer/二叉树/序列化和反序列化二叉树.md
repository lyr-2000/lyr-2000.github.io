---
title: "序列化二叉树"
date: 2021-08-17T13:48:22+08:00
draft: false
author: LYR
---

 ## 序列化二叉树



请实现两个函数，分别用来序列化和反序列化二叉树。

您需要确保二叉树可以序列化为字符串，并且可以将此字符串反序列化为原始树结构。

#### 样例

```
你可以序列化如下的二叉树
    8
   / \
  12  2
     / \
    6   4

为："[8, 12, 2, null, null, 6, 4, null, null, null, null]"
```

**注意**:

-  你不必一定按照此格式，所以可以设计出一些新的构造方式。



## 解题代码



```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:

    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        string s;
        toS(root,s);
        return s;
    }
    #define Node TreeNode
    void toS(Node*p,string &s) {
        if(p==NULL) {
            s += "n,";
            return;
            
        }
        s+= to_string(p->val)+",";
        toS(p->left,s);
        toS(p->right,s);
        
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
       // cout << data<<endl;
        //return NULL;
        int f=0;
        return toNode(data,f);
    }
    
    Node* toNode(string &p,int &i) {
        if(i >= (int)p.size()) return NULL;
        if(p[i]==',')++i;
        int t = i;
        while(p[t]!=',') t++;
        
        if(p[i]=='n') {
            i = t+1;
            //null 值
            return NULL;
        }
        int val = 0,flag = 1;
        if(p[i]==',')++i;
        if(p[i]=='-') ++i,flag = -1;
        for(int k=i;k<t;++k) {
            val = val*10 + (p[k]-'0');
        }
        val = val*flag;
        Node*cur = new Node(val);
        i = t+1;
        cur->left = toNode(p,i);
        cur->right=toNode(p,i);
        return cur;
        
    }
};
```





