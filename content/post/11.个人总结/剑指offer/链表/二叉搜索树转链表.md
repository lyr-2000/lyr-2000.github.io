---
title: "二叉搜索树转链表"
date: 2021-08-17T13:48:22+08:00
draft: false
author: LYR
---

## 二叉搜索树转链表



输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。

要求不能创建任何新的结点，只能调整树中结点指针的指向。

**注意**：

- 需要返回双向链表最左侧的节点。

例如，输入下图中左边的二叉搜索树，则输出右边的排序双向链表。

![https://www.acwing.com/media/article/image/2018/12/02/19_23bee494f5-QQ%25E6%2588%25AA%25E5%259B%25BE20181202052830.png](https://www.acwing.com/media/article/image/2018/12/02/19_23bee494f5-QQ%E6%88%AA%E5%9B%BE20181202052830.png)



## 代码



```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* convert(TreeNode* root) {
        if(!root) return NULL;
        auto f = dfs(root);
        return f.first;
    }
    
    #define Node TreeNode
    pair<Node*,Node*> dfs(Node* p) {
        if(p==NULL) return {NULL,NULL};
        if(p->left==NULL && p->right==NULL) return {p,p};
        
        if(p->left && p->right) {
            auto l = dfs(p->left) ,r = dfs(p->right) ;
            l.second->right = p, p->left = l.second;
            r.first->left = p,p->right = r.first;
            return {l.first,r.second};
        } 
        if(p->left) {
            auto l = dfs(p->left)  ;
            l.second->right = p, p->left = l.second;
            //r.first->left = p,p->right = r.first
            return {l.first, p};
        }
        if(p->right) {
            auto  r = dfs(p->right) ;
            //l.second->right = p, p->left = l.second;
            r.first->left = p,p->right = r.first;
            return {p,r.second};
        }
        return {p,p};
        
        
    }
};
```

