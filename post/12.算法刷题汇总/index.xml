<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>12.算法刷题汇总 on 凌冬的个人博客</title>
    <link>https://lyr-2000.github.io/post/12.%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E6%B1%87%E6%80%BB/</link>
    <description>Recent content in 12.算法刷题汇总 on 凌冬的个人博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>LYR</copyright>
    <lastBuildDate>Sat, 14 Aug 2021 22:42:48 +0800</lastBuildDate>
    
	<atom:link href="https://lyr-2000.github.io/post/12.%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E6%B1%87%E6%80%BB/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>ac自动机</title>
      <link>https://lyr-2000.github.io/post/12.%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E6%B1%87%E6%80%BB/ac%E8%87%AA%E5%8A%A8%E6%9C%BA/</link>
      <pubDate>Sat, 14 Aug 2021 22:42:48 +0800</pubDate>
      
      <guid>https://lyr-2000.github.io/post/12.%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E6%B1%87%E6%80%BB/ac%E8%87%AA%E5%8A%A8%E6%9C%BA/</guid>
      <description>ac自动机算法 ac自动机图示 KMP 算法原理 #include &amp;lt;bits/stdc++.h&amp;gt;#define next abcdefg using namespace std; const int MAXN = 1E6+10; int next[MAXN]; int n,m; //string p,q; char p[MAXN],q[MAXN]; void kmp() { for(int i=2;i&amp;lt;=n;++i) { //0 int j = next[i-1]; //前面相等，后面不相等 while(j &amp;amp;&amp;amp; p[i] != p[j+1]) j=next[j]; if(p[i] ==</description>
    </item>
    
    <item>
      <title>tarjan算法</title>
      <link>https://lyr-2000.github.io/post/12.%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E6%B1%87%E6%80%BB/tarjan%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sat, 14 Aug 2021 22:42:48 +0800</pubDate>
      
      <guid>https://lyr-2000.github.io/post/12.%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E6%B1%87%E6%80%BB/tarjan%E7%AE%97%E6%B3%95/</guid>
      <description>tarjan 算法 原理： 向上标记法 o(N) 倍增算法 fa[i,j] 表示从i开始，向上走 $2^j$ 步， 能走到的节点， $0&amp;lt;=j &amp;lt;= logN$ $ depth[i] $ 表示深度 哨兵： 从i 开始跳 $2^j$ 步会跳到根节点，那么 $ fa[i,j] = 0</description>
    </item>
    
    <item>
      <title>全排列算法</title>
      <link>https://lyr-2000.github.io/post/12.%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E6%B1%87%E6%80%BB/%E5%85%A8%E6%8E%92%E5%88%97%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sat, 14 Aug 2021 22:42:48 +0800</pubDate>
      
      <guid>https://lyr-2000.github.io/post/12.%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E6%B1%87%E6%80%BB/%E5%85%A8%E6%8E%92%E5%88%97%E7%AE%97%E6%B3%95/</guid>
      <description>class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; permuteUnique(vector&amp;lt;int&amp;gt;&amp;amp; nums) { sort(nums.begin(),nums.end()); s = nums; visited = vector&amp;lt;bool&amp;gt; (s.size(),false); dfs(0); return res; } vector&amp;lt;int&amp;gt; s; vector&amp;lt;int&amp;gt; path; vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; vector&amp;lt;bool&amp;gt; visited; void dfs(int cur) { if(path.size() &amp;gt;= s.size()) { res.push_back(path); return; } int len= s.size(); for(int i=0;i&amp;lt;len;++i) { //因为上一轮已经全部搜索过了，没必要重复走一遍 if</description>
    </item>
    
    <item>
      <title>动态规划使用场景总结</title>
      <link>https://lyr-2000.github.io/post/12.%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E6%B1%87%E6%80%BB/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sat, 14 Aug 2021 22:42:48 +0800</pubDate>
      
      <guid>https://lyr-2000.github.io/post/12.%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E6%B1%87%E6%80%BB/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E6%80%BB%E7%BB%93/</guid>
      <description>动态规划使用场景 数据不可交换 数据不可排序 dp[i] = max{ dp[i-1]+1【a[i]&amp;gt;a[i-1]】 ,1 }</description>
    </item>
    
    <item>
      <title>快速排序算法</title>
      <link>https://lyr-2000.github.io/post/12.%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E6%B1%87%E6%80%BB/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sat, 14 Aug 2021 22:42:48 +0800</pubDate>
      
      <guid>https://lyr-2000.github.io/post/12.%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E6%B1%87%E6%80%BB/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</guid>
      <description>快速排序算法的基本原理 #include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std; vector&amp;lt;int&amp;gt; arr = {3,4,8,1,2,3}; void quicksort(int l ,int r) { if(l&amp;gt;=r) return; int i = l-1,j = r+1; int pivot = arr[(i+j)/2]; while(i&amp;lt;j) { do ++i; while(i&amp;lt;=r &amp;amp;&amp;amp; arr[i] &amp;lt;pivot ); do --j; while(j&amp;gt;=l &amp;amp;&amp;amp; arr[j] &amp;gt; pivot); if(i&amp;lt;j) { swap(arr[i],arr[j]); } } quicksort(l,j); quicksort(j+1,r); } int main(void) { quicksort(0,arr.size()-1); for(int x: arr) {</description>
    </item>
    
    <item>
      <title>枚举_日期类题</title>
      <link>https://lyr-2000.github.io/post/12.%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E6%B1%87%E6%80%BB/%E6%9E%9A%E4%B8%BE_%E6%97%A5%E6%9C%9F%E7%B1%BB%E9%A2%98/</link>
      <pubDate>Sat, 14 Aug 2021 22:42:48 +0800</pubDate>
      
      <guid>https://lyr-2000.github.io/post/12.%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E6%B1%87%E6%80%BB/%E6%9E%9A%E4%B8%BE_%E6%97%A5%E6%9C%9F%E7%B1%BB%E9%A2%98/</guid>
      <description>已知 11 年 11 月 11 日是星期一。 现在给定一个日期，请你判断是星期几。 注意闰年的 22 月有 2929 天。 满足下面条件之一的是闰年： 年份是 44 的整数倍，而且不是 100100 的</description>
    </item>
    
    <item>
      <title>树状数组算法</title>
      <link>https://lyr-2000.github.io/post/12.%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E6%B1%87%E6%80%BB/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</link>
      <pubDate>Sat, 14 Aug 2021 22:42:48 +0800</pubDate>
      
      <guid>https://lyr-2000.github.io/post/12.%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E6%B1%87%E6%80%BB/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</guid>
      <description>有 nn 头奶牛，已知它们的身高为 1∼n1∼n 且各不相同，但不知道每头奶牛的具体身高。 现在这 nn 头奶牛站成一列，已知第 ii 头牛前面有 AiAi 头牛比它低，求每</description>
    </item>
    
    <item>
      <title>笔试面试常考总结</title>
      <link>https://lyr-2000.github.io/post/12.%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E6%B1%87%E6%80%BB/%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%80%83%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sat, 14 Aug 2021 22:42:48 +0800</pubDate>
      
      <guid>https://lyr-2000.github.io/post/12.%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E6%B1%87%E6%80%BB/%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%80%83%E6%80%BB%E7%BB%93/</guid>
      <description>笔试面试常考总结</description>
    </item>
    
    <item>
      <title>链表问题</title>
      <link>https://lyr-2000.github.io/post/12.%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E6%B1%87%E6%80%BB/%E9%93%BE%E8%A1%A8%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sat, 14 Aug 2021 22:42:48 +0800</pubDate>
      
      <guid>https://lyr-2000.github.io/post/12.%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E6%B1%87%E6%80%BB/%E9%93%BE%E8%A1%A8%E9%97%AE%E9%A2%98/</guid>
      <description>82. 删除排序链表中的重复元素 II Difficulty: 中等 存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表</description>
    </item>
    
  </channel>
</rss>