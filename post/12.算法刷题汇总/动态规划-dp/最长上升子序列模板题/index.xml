<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>最长上升子序列变题 on 凌冬的个人博客</title>
    <link>https://lyr-2000.github.io/post/12.%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E6%B1%87%E6%80%BB/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-dp/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E6%A8%A1%E6%9D%BF%E9%A2%98/</link>
    <description>Recent content in 最长上升子序列变题 on 凌冬的个人博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>LYR</copyright>
    <lastBuildDate>Mon, 14 Mar 2022 22:44:48 +0800</lastBuildDate>
    <atom:link href="https://lyr-2000.github.io/post/12.%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E6%B1%87%E6%80%BB/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-dp/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E6%A8%A1%E6%9D%BF%E9%A2%98/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>最长上升子序列</title>
      <link>https://lyr-2000.github.io/post/12.%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E6%B1%87%E6%80%BB/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-dp/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E6%A8%A1%E6%9D%BF%E9%A2%98/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</link>
      <pubDate>Mon, 14 Mar 2022 22:44:48 +0800</pubDate>
      <guid>https://lyr-2000.github.io/post/12.%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E6%B1%87%E6%80%BB/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-dp/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E6%A8%A1%E6%9D%BF%E9%A2%98/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</guid>
      <description>最长上升子序列 ​ 练习题 解题代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public: /** * 代码中的类名、方法名、参数名已经指定</description>
    </item>
    <item>
      <title>最长上升子序列</title>
      <link>https://lyr-2000.github.io/post/12.%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E6%B1%87%E6%80%BB/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-dp/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E6%A8%A1%E6%9D%BF%E9%A2%98/easy/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</link>
      <pubDate>Fri, 18 Feb 2022 22:42:48 +0800</pubDate>
      <guid>https://lyr-2000.github.io/post/12.%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E6%B1%87%E6%80%BB/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-dp/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E6%A8%A1%E6%9D%BF%E9%A2%98/easy/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</guid>
      <description>最长上升子序列 给定一个长度为 N 的数列，求数值严格单调递增的子序列的长度最长是多少。 输入格式 第一行包含整数 N 。 第二行包含 N 个整数，表示完整序列</description>
    </item>
    <item>
      <title>lc.1964.找出到每个位置为止最长的有效障碍赛跑路线</title>
      <link>https://lyr-2000.github.io/post/12.%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E6%B1%87%E6%80%BB/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-dp/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E6%A8%A1%E6%9D%BF%E9%A2%98/hard/lc.1964.%E6%89%BE%E5%87%BA%E5%88%B0%E6%AF%8F%E4%B8%AA%E4%BD%8D%E7%BD%AE%E4%B8%BA%E6%AD%A2%E6%9C%80%E9%95%BF%E7%9A%84%E6%9C%89%E6%95%88%E9%9A%9C%E7%A2%8D%E8%B5%9B%E8%B7%91%E8%B7%AF%E7%BA%BF/</link>
      <pubDate>Sat, 14 Aug 2021 22:42:48 +0800</pubDate>
      <guid>https://lyr-2000.github.io/post/12.%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E6%B1%87%E6%80%BB/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-dp/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E6%A8%A1%E6%9D%BF%E9%A2%98/hard/lc.1964.%E6%89%BE%E5%87%BA%E5%88%B0%E6%AF%8F%E4%B8%AA%E4%BD%8D%E7%BD%AE%E4%B8%BA%E6%AD%A2%E6%9C%80%E9%95%BF%E7%9A%84%E6%9C%89%E6%95%88%E9%9A%9C%E7%A2%8D%E8%B5%9B%E8%B7%91%E8%B7%AF%E7%BA%BF/</guid>
      <description>1964. 找出到每个位置为止最长的有效障碍赛跑路线 Difficulty: **你打算构建一些障碍赛跑路线。给你一个 下标从 0 开始 的整数数组 obstacles ，数组长度为 n ，其中 obstacles[i] 表示第 i 个</description>
    </item>
    <item>
      <title>lc.354.俄罗斯套娃信封问题</title>
      <link>https://lyr-2000.github.io/post/12.%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E6%B1%87%E6%80%BB/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-dp/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E6%A8%A1%E6%9D%BF%E9%A2%98/lc.354.%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83%E4%BF%A1%E5%B0%81%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sat, 14 Aug 2021 22:42:48 +0800</pubDate>
      <guid>https://lyr-2000.github.io/post/12.%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E6%B1%87%E6%80%BB/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-dp/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E6%A8%A1%E6%9D%BF%E9%A2%98/lc.354.%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83%E4%BF%A1%E5%B0%81%E9%97%AE%E9%A2%98/</guid>
      <description>354. 俄罗斯套娃信封问题 Difficulty: 困难 给你一个二维整数数组 envelopes ，其中 envelopes[i] = [w&amp;lt;sub style=&amp;quot;display: inline;&amp;quot;&amp;gt;i&amp;lt;/sub&amp;gt;, h&amp;lt;sub style=&amp;quot;display: inline;&amp;quot;&amp;gt;i&amp;lt;/sub&amp;gt;] ，表示第 i 个信封的宽度和高度。 当另一个信封的宽度和高度都比这个信封大的</description>
    </item>
    <item>
      <title>lc.368.最大整除子集</title>
      <link>https://lyr-2000.github.io/post/12.%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E6%B1%87%E6%80%BB/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-dp/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E6%A8%A1%E6%9D%BF%E9%A2%98/lc.368.%E6%9C%80%E5%A4%A7%E6%95%B4%E9%99%A4%E5%AD%90%E9%9B%86/</link>
      <pubDate>Sat, 14 Aug 2021 22:42:48 +0800</pubDate>
      <guid>https://lyr-2000.github.io/post/12.%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E6%B1%87%E6%80%BB/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-dp/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E6%A8%A1%E6%9D%BF%E9%A2%98/lc.368.%E6%9C%80%E5%A4%A7%E6%95%B4%E9%99%A4%E5%AD%90%E9%9B%86/</guid>
      <description>368. 最大整除子集 Difficulty: 中等 给你一个由 无重复 正整数组成的集合 nums ，请你找出并返回其中最大的整除子集 answer ，子集中每一元素对 (answer[i], answer[j]) 都应当满足： answer[i] % answer[j] == 0 ，或 answer[j]</description>
    </item>
    <item>
      <title>lc.673.最长上升子序列个数</title>
      <link>https://lyr-2000.github.io/post/12.%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E6%B1%87%E6%80%BB/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-dp/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E6%A8%A1%E6%9D%BF%E9%A2%98/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%E4%B8%AA%E6%95%B0/</link>
      <pubDate>Sat, 14 Aug 2021 22:42:48 +0800</pubDate>
      <guid>https://lyr-2000.github.io/post/12.%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E6%B1%87%E6%80%BB/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-dp/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E6%A8%A1%E6%9D%BF%E9%A2%98/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%E4%B8%AA%E6%95%B0/</guid>
      <description>最长上升子序列个数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public: int findNumberOfLIS(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int n = nums.size(); vector&amp;lt;int&amp;gt; dp(n,1),cnt(n,1); int maxLen = 1; for(int i=1;i&amp;lt;n;++i) { for(int j=0;j&amp;lt;i;++j) { if(nums[j]&amp;lt; nums[i]) { if(dp[j] + 1&amp;gt; dp[i]) {</description>
    </item>
    <item>
      <title>等差数列划分 II -子序列</title>
      <link>https://lyr-2000.github.io/post/12.%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E6%B1%87%E6%80%BB/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-dp/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E6%A8%A1%E6%9D%BF%E9%A2%98/%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%88%92%E5%88%86ii-%E5%AD%90%E5%BA%8F%E5%88%97/</link>
      <pubDate>Sat, 14 Aug 2021 22:42:48 +0800</pubDate>
      <guid>https://lyr-2000.github.io/post/12.%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E6%B1%87%E6%80%BB/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-dp/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E6%A8%A1%E6%9D%BF%E9%A2%98/%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%88%92%E5%88%86ii-%E5%AD%90%E5%BA%8F%E5%88%97/</guid>
      <description>446. 等差数列划分 II - 子序列 Difficulty: 困难 给你一个整数数组 nums ，返回 nums 中所有 等差子序列 的数目。 如果一个序列中 至少有三个元素 ，并且任意两个相邻元素之差相同，</description>
    </item>
  </channel>
</rss>
