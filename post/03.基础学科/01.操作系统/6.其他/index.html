<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>其他 - 凌冬的个人博客</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="LYR" /><meta name="description" content="操作系统相关 冯诺伊曼体系 该思想约定了用二进制进行计算和存储，还定义计算机基本结构为 5 个部分，分别是中央处理器（CPU）、内存、输入设备、输出" /><meta name="keywords" content="凌冬的博客, LYR的个人博客, 二次元技术宅" />






<meta name="generator" content="Hugo 0.74.2 with theme even" />


<link rel="canonical" href="https://lyr-2000.github.io/post/03.%E5%9F%BA%E7%A1%80%E5%AD%A6%E7%A7%91/01.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6.%E5%85%B6%E4%BB%96/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<link href="/sass/main.min.4d31fe93a248bf2a033aec98b3dca0e0e3f55453ad76230e57f190d60450d008.css" rel="stylesheet"> 

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="其他" />
<meta property="og:description" content="操作系统相关 冯诺伊曼体系 该思想约定了用二进制进行计算和存储，还定义计算机基本结构为 5 个部分，分别是中央处理器（CPU）、内存、输入设备、输出" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://lyr-2000.github.io/post/03.%E5%9F%BA%E7%A1%80%E5%AD%A6%E7%A7%91/01.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6.%E5%85%B6%E4%BB%96/" />
<meta property="article:published_time" content="2021-03-23T22:38:16+00:00" />
<meta property="article:modified_time" content="2021-03-23T22:38:16+00:00" />
<meta itemprop="name" content="其他">
<meta itemprop="description" content="操作系统相关 冯诺伊曼体系 该思想约定了用二进制进行计算和存储，还定义计算机基本结构为 5 个部分，分别是中央处理器（CPU）、内存、输入设备、输出">
<meta itemprop="datePublished" content="2021-03-23T22:38:16&#43;00:00" />
<meta itemprop="dateModified" content="2021-03-23T22:38:16&#43;00:00" />
<meta itemprop="wordCount" content="7310">



<meta itemprop="keywords" content="," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="其他"/>
<meta name="twitter:description" content="操作系统相关 冯诺伊曼体系 该思想约定了用二进制进行计算和存储，还定义计算机基本结构为 5 个部分，分别是中央处理器（CPU）、内存、输入设备、输出"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css">

</head>
<body>
  <div>
    <button class="button pink back">back</button>
    <button class="button pink go">go</button>
    <button class="button pink topUrl">top</button>
    
  </div>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">凌冬的博客</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><li style="display:inline-block;margin-right:10px;">
			<input type="search" class="mob-docsearch-input" placeholder="Search" />
		</li><a href="/">
        <li class="mobile-menu-item">首页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档页</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a><a href="/friends">
        <li class="mobile-menu-item">友人帐</li>
      </a>
	
	
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">凌冬的博客</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">首页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/friends">友人帐</a>
      </li><li  style="list-style: none;position: relative;left: 360px;bottom: 32px;">
		<input type="search" class="docsearch-input PC_MARK1" placeholder="Search" />
	  </li></ul>
</nav>
<link rel="stylesheet" href="/custom/css/post.css">

<style>
  .mob-docsearch-input {
	border: 1px solid #ccc;
	padding: 6px 0px;
	border-radius: 3px;
	padding-left:5px;
	position: relative;
    vertical-align: top;
    width: 93%;
    margin: auto;
    margin-left: 7px;
  
  }
  input.PC_MARK1{
	border: 1px solid #ccc;
	padding: 6px 0px;
	border-radius: 3px;
	padding-left:5px;
	-webkit-box-shadow: inset 0 1px 1px rgba(0,0,0,.075);
	box-shadow: inset 0 1px 1px rgba(0,0,0,.075);
	-webkit-transition: border-color ease-in-out .15s,-webkit-box-shadow ease-in-out .15s;
	-o-transition: border-color ease-in-out .15s,box-shadow ease-in-out .15s;
	transition: border-color ease-in-out .15s,box-shadow ease-in-out .15s
}
input.PC_MARK1:focus{
		border-color: #66afe9;
		outline: 0;
		-webkit-box-shadow: inset 0 1px 1px rgba(0,0,0,.075),0 0 8px rgba(102,175,233,.6);
		box-shadow: inset 0 1px 1px rgba(0,0,0,.075),0 0 8px rgba(102,175,233,.6)
}
</style>

    </header>
	
	

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">其他</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-03-23 </span>
        <div class="post-category">
            <a href="/categories/%E5%9F%BA%E7%A1%80%E5%AD%A6%E7%A7%91/"> 基础学科 </a>
            <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"> 操作系统 </a>
            </div>
          <span class="more-meta"> 约 7310 字 </span>
          <span class="more-meta"> 预计阅读 15 分钟 </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 次阅读 </span>
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#操作系统相关">操作系统相关</a>
          <ul>
            <li><a href="#冯诺伊曼体系">冯诺伊曼体系</a></li>
          </ul>
        </li>
        <li><a href="#文件相关">文件相关</a>
          <ul>
            <li><a href="#文件组成">文件组成</a></li>
            <li><a href="#文件类型">文件类型</a></li>
            <li><a href="#文件和目录的区别">文件和目录的区别</a></li>
          </ul>
        </li>
        <li><a href="#cap理论">CAP理论</a>
          <ul>
            <li><a href="#一致性consistency">一致性（Consistency）</a></li>
            <li><a href="#可用性availability">可用性（Availability）</a></li>
            <li><a href="#分区容错性partition-tolerance">分区容错性（Partition tolerance）</a></li>
            <li><a href="#cap权衡">CAP权衡</a></li>
          </ul>
        </li>
        <li><a href="#系统调用">系统调用</a></li>
        <li><a href="#socket编程网络编程">Socket编程（网络编程）</a>
          <ul>
            <li></li>
          </ul>
        </li>
        <li><a href="#程序编译执行流程">程序编译执行流程</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>

    <div class="post-content">
      <h2 id="操作系统相关">操作系统相关</h2>
<h3 id="冯诺伊曼体系">冯诺伊曼体系</h3>
<p>该思想约定了用二进制进行计算和存储，还定义计算机基本结构为 5 个部分，分别是<strong>中央处理器（CPU）、内存、输入设备、输出设备、总线</strong>。</p>
<h2 id="文件相关">文件相关</h2>
<h3 id="文件组成">文件组成</h3>
<p>以Linux系统为例，在Linux系统中一切皆文件，Linux文件系统会为每个文件分配<code>索引节点 inode</code>跟<code>目录项directory entry</code>来记录文件内容跟目录层次结构。</p>
<h3 id="文件类型">文件类型</h3>
<p>划分文件类型的目的是为了更好地管理文件，按照不同的分类，可以将文件类型进行不同的划分</p>
<ul>
<li>按照用途划分
<ul>
<li>系统文件</li>
<li>用户文件</li>
<li>库文件</li>
</ul>
</li>
<li>按照文件中数据的形式划分
<ul>
<li>源文件</li>
<li>目标文件</li>
<li>可执行文件</li>
</ul>
</li>
<li>按照存取控制权限划分
<ul>
<li>只执行文件</li>
<li>只读文件</li>
<li>读写文件</li>
</ul>
</li>
<li>按照组织形式和处理方式划分
<ul>
<li>普通文件</li>
<li>二进制文件</li>
<li>特殊文件</li>
</ul>
</li>
</ul>
<p><a href="https://www.jianshu.com/p/de35926643d3">操作系统基础之文件管理 - 简书 (jianshu.com)</a></p>
<h3 id="文件和目录的区别">文件和目录的区别</h3>
<p>文件权限一般可认为是0 123 456 789，一共十位，0：表示该文件的文件类型。在Linux中文件类型只有以下这几种：</p>
<ul>
<li>-，普通文件。</li>
<li>d，目录文件，d是directory的简写。</li>
<li>l，软连接文件，亦称符号链接文件，s是soft或者symbolic的简写。</li>
<li>b，块文件，是设备文件的一种（还有另一种），b是block的简写。</li>
<li>c，字符文件，也是设备文件的一种（这就是第二种），c是character的文件。</li>
</ul>
<p>Linux系统最原始的也只有这五种，所以第0位，只能是以上五者之一。</p>
<p>为什么硬连接没有类型表示？答案：硬连接和软连接，名字上虽然只差一个字，本质完全不同，硬连接也是文件。其类型是普通文件。</p>
<p>那么我们如何找到某个文件呢？使用inode号，我们的目录本质上就是一张表，里面会存储Innodb和文件的映射关系，比如下面这种的。</p>
<p><strong>体现在本质上</strong></p>
<p>普通文件：存储普通数据，一般就是字符串。
目录文件：存储了一张表，该表就是该目录文件下，所有文件名和inode的映射关系。
从父目录中获得本文件的inode号&mdash;-&gt;找到inode-table表中找到这个inode号对应的数据域中的起点以及其他信息&mdash;-&gt;去这个数据域中读取该文件的内容（普通文件的内容一般是字符串，目录文件的内容是一张表）</p>
<p><strong>体现在命令上：</strong></p>
<p>对于普通文件来说，rwx的意义是：
r：可以获得这个普通文件的名字和内容。
w：可以修改这个文件的内容和文件名。可以删除该文件，但是用户会得到是否删除写保护文件的prompt。</p>
<p>x：该文件是否具有被执行的权限。</p>
<p>对于目录文件来说，rwx的意义是：
r-x：可以进入cd该目录，可以获得该目录下存储情况，但是不能修改这个目录内部存储的文件（目录）的名字，也不能在该目录下新建文件和目录
-wx：可以进入cd该目录，但是看不到该目录下的存储情况（ls不可用），可以往该目录下添加、修改、删除文件。可以通过cat来读取该目录下的文件or目录的内容，由于得不到该目录下存储了那些文件，在不知情的情况下只能通过猜，cat + 文件名获得文件内容，所以这样依然不保密。
&ndash;x：可以进入cd该目录，看不到存储情况，也不能往该目录下添加、修改、删除文件。但是依然可以通过cat + xx（猜）来获得该目录下的文件的内容。</p>
<p>rw-：不能进入cd该目录，用ls仅仅可以获得文件名和目录名，因为获取不到这些文件的inode号，当然也不能获得该目录下的文件的内容。不能往该目录下添加、修改、删除文件。</p>
<p>最后总结一下吧：
1.目录文件虽然是文件（唉，谁叫Linux的核心理念就是Everything is file），但是存储内容的只是一张表而已，关于文件名和inode号的映射关系。
2.文件的扩展名和文件类型之间，没一毛钱关系。
3.文件的文件名和文件实际存储内容之间，没一毛钱关系。
4.要知道如何查找到一个文件内容的过程。
5.为什么同一个文件系统移动文件要比跨文件系统快？</p>
<p>答：因为只需要修改某个目录中路径和inode对应关系即可，不需要重新写一遍数据域。
6.什么是买来的500G的硬盘，格式化完后总是少了达不到500G？</p>
<p>答：从本文可知，inode-table也是需要占用存储空间的，所以缺少的一部分中inode-table占用了不少。</p>
<p><a href="https://blog.csdn.net/Com_ma/article/details/72801127">linux的文件和目录的区别和联系_Faith的博客-CSDN博客_linux文件和目录的区别</a></p>
<h2 id="cap理论">CAP理论</h2>
<p><strong>一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项</strong>。</p>
<h3 id="一致性consistency">一致性（Consistency）</h3>
<p>一致性指“<code>all nodes see the same data at the same time</code>”，即所有节点在同一时间的数据完全一致。</p>
<p>一致性是因为多个数据拷贝下并发读写才有的问题，因此理解时一定要注意结合考虑多个数据拷贝下并发读写的场景。</p>
<h3 id="可用性availability">可用性（Availability）</h3>
<p>可用性指“<code>Reads and writes always succeed</code>”，即服务在正常响应时间内一直可用。</p>
<p>好的可用性主要是指系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。可用性通常情况下可用性和分布式数据冗余，负载均衡等有着很大的关联。</p>
<h3 id="分区容错性partition-tolerance">分区容错性（Partition tolerance）</h3>
<p>分区容错性指“<code>the system continues to operate despite arbitrary message loss or failure of part of the system</code>”，即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性或可用性的服务。</p>
<h3 id="cap权衡">CAP权衡</h3>
<p>CA without P：如果不要求P（不允许分区），则C（强一致性）和A（可用性）是可以保证的。但其实分区不是你想不想的问题，而是始终会存在，因此CA的系统更多的是允许分区后各子系统依然保持CA。
CP without A：如果不要求A（可用），相当于每个请求都需要在Server之间强一致，而P（分区）会导致同步时间无限延长，如此CP也是可以保证的。很多传统的数据库分布式事务都属于这种模式。
AP wihtout C：要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。现在众多的NoSQL都属于此类。</p>
<p>对于多数大型互联网应用的场景，主机众多、部署分散，而且现在的集群规模越来越大，所以节点故障、网络故障是常态，而且要保证服务可用性达到N个9，即保证P和A，舍弃C（退而求其次保证最终一致性）。虽然某些地方会影响客户体验，但没达到造成用户流程的严重程度。</p>
<p>对于涉及到钱财这样不能有一丝让步的场景，C必须保证。网络发生故障宁可停止服务，这是保证CA，舍弃P。貌似这几年国内银行业发生了不下10起事故，但影响面不大，报道也不多，广大群众知道的少。还有一种是保证CP，舍弃A。例如网络故障事只读不写。</p>
<p>孰优孰略，没有定论，只能根据场景定夺，适合的才是最好的。</p>
<p>参考：</p>
<p><a href="https://zhuanlan.zhihu.com/p/33999708">谈谈分布式系统的CAP理论 - 知乎 (zhihu.com)</a></p>
<h2 id="系统调用">系统调用</h2>
<p>Linux内核中设置了一组用于实现各种系统功能的子程序，称为系统调用。用户可以通过系统调用命令在自己的应用程序中调用它们。从某种角度来看，系统调用和普通的函数调用非常相似。区别仅仅在于，系统调用由操作系统核心提供，运行于核心态;而普通的函数调用由函数库或用户自己提供，运行于用户态。</p>
<p>随Linux核心还提供了一些C语言函数库，这些库对系统调用进行了一些包装和扩展，因为这些库函数与系统调用的关系非常紧密，所以习惯上把这些函数也称为系统调用。</p>
<p>主要分为以下几大类</p>
<ul>
<li>
<p>进程控制</p>
</li>
<li>
<p>文件系统控制</p>
<ul>
<li>文件读写</li>
<li>文件系统操作</li>
</ul>
</li>
<li>
<p>系统控制</p>
</li>
<li>
<p>内存管理</p>
</li>
<li>
<p>网络管理</p>
</li>
<li>
<p>socket控制</p>
</li>
<li>
<p>用户管理</p>
</li>
<li>
<p>进程间通信</p>
<ul>
<li>信号</li>
<li>消息</li>
<li>管道</li>
<li>信号量</li>
<li>共享内存</li>
</ul>
</li>
</ul>
<p><a href="https://blog.csdn.net/gatieme/article/details/50779184">Linux系统调用详解（实现机制分析）&ndash;linux内核剖析（六）_OSKernelLAB-CSDN博客_linux系统调用</a></p>
<p><a href="https://www.huaweicloud.com/articles/3aa84d6af3129d6798168a162d5124c8.html">什么是系统调用?为什么要用系统调用? - 华为云 (huaweicloud.com)</a></p>
<p>库函数调用和系统调用的区别</p>
<table>
<thead>
<tr>
<th align="left"><strong>函数</strong>库<strong>调用</strong></th>
<th align="left"><strong>系统调用</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">与用户程序相联系</td>
<td align="left">是操作<strong>系统</strong>的一个入口点</td>
</tr>
<tr>
<td align="left">在用户地址空间执行</td>
<td align="left">在内核地址空间执行</td>
</tr>
<tr>
<td align="left">它的运行时间属于“用户时间”</td>
<td align="left">它的运行时间属于“<strong>系统</strong>”时间</td>
</tr>
</tbody>
</table>
<h2 id="socket编程网络编程">Socket编程（网络编程）</h2>
<p>基于 TCP 的网络编程开发分为服务器端和客户端两部分，常见的核心步骤和流程如下：</p>
<p><img src="https://img.xiaoyou66.com/2021/04/12/8c3c74a6f808e.png" alt="image.png"></p>
<h4 id="socket函数">socket()函数</h4>
<p>socket函数对应于普通文件的打开操作。普通文件的打开操作返回一个文件描述字，而 <strong>socket()</strong> 用于创建一个socket描述符（socket descriptor），它唯一标识一个socket。这个socket描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。函数定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">int</span> <span class="nf">socket</span><span class="p">(</span><span class="kt">int</span> <span class="n">domain</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">protocol</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>domain：即协议域，又称为协议族（family）。常用的协议族有，AF_INET、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。</li>
<li>type：指定socket类型。常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等（socket的类型有哪些？）。</li>
<li>protocol：故名思意，就是指定协议。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议。</li>
</ul>
<p>注意：并不是上面的type和protocol可以随意组合的，如SOCK_STREAM不可以跟IPPROTO_UDP组合。当protocol为0时，会自动选择type类型对应的默认协议。</p>
<p>当我们调用<strong>socket</strong>创建一个socket时，返回的socket描述字它存在于协议族（address family，AF_XXX）空间中，但没有一个具体的地址。如果想要给它赋值一个地址，就必须调用bind()函数，否则就当调用connect()、listen()时系统会自动随机分配一个端口。</p>
<h4 id="bind函数">bind()函数</h4>
<p>正如上面所说bind()函数把一个地址族中的特定地址赋给socket。例如对应AF_INET、AF_INET6就是把一个ipv4或ipv6地址和端口号组合赋给socket。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">int</span> <span class="nf">bind</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="nc">sockaddr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">socklen_t</span> <span class="n">addrlen</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>sockfd：即socket描述字，它是通过socket()函数创建了，唯一标识一个socket。bind()函数就是将给这个描述字绑定一个名字。</li>
<li>addr：一个const struct sockaddr *指针，指向要绑定给sockfd的协议地址。这个地址结构根据地址创建socket时的地址协议族的不同而不同</li>
<li>addrlen：对应的是地址的长度。</li>
</ul>
<p>通常服务器在启动的时候都会绑定一个众所周知的地址（如ip地址+端口号），用于提供服务，客户就可以通过它来接连服务器；而客户端就不用指定，有系统自动分配一个端口号和自身的ip地址组合。这就是为什么通常服务器端在listen之前会调用bind()，而客户端就不会调用，而是在connect()时由系统随机生成一个。</p>
<h4 id="connect函数">connect()函数</h4>
<p>对于客户端的 connect() 函数，该函数的功能为客户端主动连接服务器，建立连接是通过<a href="http://blog.csdn.net/tennysonsky/article/details/45622395">三次握手</a>，而<strong>这个连接的过程是由内核完成</strong>，不是这个函数完成的，这个函数的作用仅仅是通知 Linux 内核，让 Linux 内核自动完成 <a href="http://blog.csdn.net/tennysonsky/article/details/45622395">TCP 三次握手</a>连接（<a href="http://blog.csdn.net/tennysonsky/article/details/45622395">三次握手详情，请看《浅谈 TCP 三次握手》</a>），最后把连接的结果返回给这个函数的返回值（成功连接为0， 失败为-1）。</p>
<p>通常的情况，客户端的 connect() 函数默认会一直阻塞，直到<a href="http://blog.csdn.net/tennysonsky/article/details/45622395">三次握手</a>成功或超时失败才返回（正常的情况，这个过程很快完成）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">int</span> <span class="nf">connect</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="nc">sockaddr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">socklen_t</span> <span class="n">addrlen</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>connect函数的第一个参数即为客户端的socket描述字，第二参数为服务器的socket地址，第三个参数为socket地址的长度。客户端通过调用connect函数来建立与TCP服务器的连接。</p>
<h4 id="listen函数">listen()函数</h4>
<p>对于服务器，它是被动连接的。举一个生活中的例子，通常的情况下，移动的客服（相当于服务器）是等待着客户（相当于客户端）电话的到来。而这个过程，需要调用listen()函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#include</span><span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">listen</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">backlog</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>listen() 函数的主要作用就是将套接字( sockfd )变成被动的连接监听套接字（被动等待客户端的连接），至于参数 backlog 的作用是设置内核中连接队列的长度， <code>TCP 三次握手也不是由这个函数完成，listen()的作用仅仅告诉内核一些信息。</code></p>
<p>第二个参数（ backlog）的作用：告诉内核连接队列的长度。</p>
<p>为了更好的理解 backlog 参数，我们必须认识到内核为任何一个给定的监听套接口维护两个队列：</p>
<p>1、未完成连接队列（incomplete connection queue），每个这样的 SYN 分节对应其中一项：已由某个客户发出并到达服务器，而服务器正在等待完成相应的 TCP <a href="http://blog.csdn.net/tennysonsky/article/details/45622395">三次握手</a>过程。这些套接口处于 SYN_RCVD 状态。</p>
<p>2、已完成连接队列（completed connection queue），每个已完成 TCP <a href="http://blog.csdn.net/tennysonsky/article/details/45622395">三次握手</a>过程的客户对应其中一项。这些套接口处于 ESTABLISHED 状态。</p>
<p>当来自客户的 SYN 到达时，TCP 在未完成连接队列中创建一个新项，然后响应以三次握手的第二个分节：服务器的 SYN 响应，其中稍带对客户 SYN 的 ACK（即SYN+ACK），这一项一直保留在未完成连接队列中，直到三次握手的第三个分节（客户对服务器 SYN 的 ACK ）到达或者该项超时为止（曾经源自Berkeley的实现为这些未完成连接的项设置的超时值为75秒）。</p>
<p>如果三次握手正常完成，该项就从未完成连接队列移到已完成连接队列的队尾。</p>
<p><strong>这里需要注意的是</strong> listen()函数不会阻塞，它主要做的事情为，将该套接字和套接字对应的连接队列长度告诉 Linux 内核，然后，listen()函数就结束。</p>
<p>这样的话，当有一个客户端主动连接（connect()），Linux 内核就自动完成<a href="http://blog.csdn.net/tennysonsky/article/details/45622395">TCP 三次握手</a>，将建立好的链接自动存储到队列中，如此重复。</p>
<p>所以，只要 TCP 服务器调用了 listen()，客户端就可以通过 connect() 和服务器建立连接，而 <strong>这个连接的过程是由内核完成</strong>。</p>
<h4 id="accept函数">accept()函数</h4>
<p>accept()函数功能是，从处于 established 状态的连接队列头部取出一个已经完成的连接，如果这个队列没有已经完成的连接，accept()函数就会阻塞，直到取出队列中已完成的用户连接为止。</p>
<p>如果，服务器不能及时调用 accept() 取走队列中已完成的连接，队列满掉后会怎样呢？UNP（《unix网络编程》）告诉我们，服务器的连接队列满掉后，服务器不会对再对建立新连接的syn进行应答，所以客户端的 connect 就会返回 ETIMEDOUT。<strong>但实际上Linux的并不是这样的！</strong></p>
<p><strong>TCP 的连接队列满后，Linux 不会如书中所说的拒绝连接</strong>，只是有些会延时连接，<strong>而且</strong>accept()未必能把已经建立好的连接全部取出来（如：当队列的长度指定为 0 ），写程序时服务器的 listen() 的第二个参数最好还是根据需要填写，写太大不好（具体可以看cat /proc/sys/net/core/somaxconn，默认最大值限制是 128），浪费资源，写太小也不好，延时建立连接。</p>
<h4 id="readwrite等函数">read()、write()等函数</h4>
<p>万事具备只欠东风，至此服务器与客户已经建立好连接了。可以调用网络I/O进行读写操作了，即实现了网咯中不同进程之间的通信！网络I/O操作有下面几组：</p>
<ul>
<li>read()/write()</li>
<li>recv()/send()</li>
<li>readv()/writev()</li>
<li>recvmsg()/sendmsg()</li>
<li>recvfrom()/sendto()</li>
</ul>
<p>read函数是负责从fd中读取内容.当读成功时，read返回实际所读的字节数，如果返回的值是0表示已经读到文件的结束了，小于0表示出现了错误。如果错误为EINTR说明读是由中断引起的，如果是ECONNREST表示网络连接出了问题。</p>
<p>write函数将buf中的nbytes字节内容写入文件描述符fd.成功时返回写的字节数。失败时返回-1，并设置errno变量。 在网络程序中，当我们向套接字文件描述符写时有俩种可能。1)write的返回值大于0，表示写了部分或者是全部的数据。2)返回的值小于0，此时出现了错误。我们要根据错误类型来处理。如果错误为EINTR表示在写的时候出现了中断错误。如果为EPIPE表示网络连接出现了问题(对方已经关闭了连接)。</p>
<p><strong>close函数</strong></p>
<p>在服务器与客户端建立连接之后，会进行一些读写操作，完成了读写操作就要关闭相应的socket描述字，好比操作完打开的文件要调用fclose关闭打开的文件。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">int</span> <span class="nf">close</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>close一个TCP socket的缺省行为时把该socket标记为以关闭，然后立即返回到调用进程。该描述字不能再由调用进程使用，也就是说不能再作为read或write的第一个参数。</p>
<p>注意：close操作只是使相应socket描述字的引用计数-1，只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求。</p>
<p><a href="https://blog.csdn.net/tennysonsky/article/details/45621341">TCP网络编程中connect()、listen()和accept()三者之间的关系_秋叶原 &amp;&amp; Mike || 麦克-CSDN博客</a></p>
<p><a href="https://www.cnblogs.com/skynet/archive/2010/12/12/1903949.html">Linux Socket编程（不限Linux） - 吴秦 - 博客园 (cnblogs.com)</a></p>
<h2 id="程序编译执行流程">程序编译执行流程</h2>
<p><strong>编译流程</strong></p>
<p>构建C程序需要4个步骤，分别使用4个工具完成： preprocessor, compiler, assembler, and linker.四步完成后生成一个可执行文件。</p>
<ol>
<li>第一步，预处理. 这一步处理 头文件、条件编译指令和宏定义。</li>
<li>第二步，编译. 将第一步产生的文件连同其他源文件一起编译成汇编代码。</li>
<li>第三步，汇编。将第二步产生的汇编源码转换为 object file.</li>
<li>第四步，链接. 将第三步产生的一些object file 链接成一个可执行的文件。</li>
</ol>
<p><strong>执行流程</strong></p>
<ol>
<li>将编译后的程序加载到操作系统的执行内存中。</li>
<li>操作系统把加载到内存中的数据进行人为的分区，大致分为:</li>
</ol>
<ul>
<li>.data区：常量区，存放程序中的所有静态常量，相当于java中的public static 的常量,在C语言中则是通过宏定义(define)声明的常量。</li>
<li>.code区：方法区，存放funcation编译后的声明和实现的描述(其实也是0101).</li>
<li>栈(Stack)空间：程序运行时存放变量的空间，大小由操作系统指定，是一块连续的内存空间，访问速度和效率比Heap要高一些。</li>
<li>堆(Heap)空间：存放对象的一块不连续的内存空间，访问、存储效率比栈稍低。</li>
</ul>
<ol>
<li>划分好区域并将对应的数据加载到各自分区后，各个内存分区开始配合工作，举例：</li>
</ol>
<p>参考：</p>
<ol>
<li><a href="https://blog.csdn.net/bdss58/article/details/78981212">程序的编译与执行过程_bdss58的专栏-CSDN博客_程序编译执行步骤</a></li>
<li><a href="https://www.jianshu.com/p/bcf6656149ea">4.C语言程序执行的流程 - 简书 (jianshu.com)</a></li>
</ol>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">LYR</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2021-03-23
        
    </span>
  </p>
  
  
</div>
<div class="post-reward">
  <input type="checkbox" name="reward" id="reward" hidden />
  <label class="reward-button" for="reward">赞赏支持</label>
  <div class="qr-code">
    
    <label class="qr-code-image" for="reward">
        <img class="image" src="/img/reward/wechat.jpg">
        <span>微信打赏</span>
      </label>
    <label class="qr-code-image" for="reward">
        <img class="image" src="/img/reward/alipay.jpg">
        <span>支付宝打赏</span>
      </label>
  </div>
</div><footer class="post-footer">
      <div class="post-tags">
          <a href="/tags//"></a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/03.%E5%9F%BA%E7%A1%80%E5%AD%A6%E7%A7%91/01.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/7.%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">面试问题整理</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/03.%E5%9F%BA%E7%A1%80%E5%AD%A6%E7%A7%91/01.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5.io%E7%AE%A1%E7%90%86/">
            <span class="next-text nav-default">IO管理</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>

  
  
        </div>
        <div id="gitalk-container"></div>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js" crossorigin="anonymous"></script>
    <script type="text/javascript">
      var gitalk = new Gitalk({
        id: '2021-03-23 22:38:16 \u002b0000 UTC',
        title: '其他',
        clientID: '604ae0a4eff099135503',
        clientSecret: '403ff7c3a3ff6a91d905110c91eb1651219b7233',
        repo: 'lyr-2000.github.io',
        owner: 'lyr-2000',
        admin: ['lyr-2000'],
        body: decodeURI(location.href)
      });
      gitalk.render('gitalk-container');
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/gitalk/gitalk">comments powered by gitalk.</a></noscript>

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:lyr-2000@qq.com" class="iconfont icon-email" title="email"></a>
  <a href="" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> 本站总访问量 <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 次 </span>
      <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> 本站总访客数 <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 人 </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2021-08-01 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span>LYR</span>
  </span>
</div>



<script 
 
    src="https://cdn.jsdelivr.net/gh/lyr-2000/live2d-widget@latest/autoload.js"></script>








    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script><script></script><script src="https://cdn.jsdelivr.net/npm/raphael@2.2.7/raphael.min.js" integrity="sha256-67By+NpOtm9ka1R6xpUefeGOY8kWWHHRAKlvaTJ7ONI=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/flowchart.js@1.8.0/release/flowchart.min.js" integrity="sha256-zNGWjubXoY6rb5MnmpBNefO0RgoVYfle9p0tvOQM+6k=" crossorigin="anonymous"></script><script></script><script src="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.js" integrity="sha256-4O4pS1SH31ZqrSO2A/2QJTVjTPqVe+jnYgOWUVr7EEc=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/snapsvg@0.5.1/dist/snap.svg-min.js" integrity="sha256-oI+elz+sIm+jpn8F/qEspKoKveTc5uKeFHNNVexe6d8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/underscore@1.8.3/underscore-min.js" integrity="sha256-obZACiHd7gkOk9iIL/pimWMTJ4W/pBsKu+oZnSeBIek=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/gh/bramp/js-sequence-diagrams@2.0.1/dist/sequence-diagram-min.js" integrity="sha384-8748Vn52gHJYJI0XEuPB2QlPVNUkJlJn9tHqKec6J3q2r9l8fvRxrgn/E5ZHV0sP" crossorigin="anonymous"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/bramp/js-sequence-diagrams@2.0.1/dist/sequence-diagram-min.css" integrity="sha384-6QbLKJMz5dS3adWSeINZe74uSydBGFbnzaAYmp+tKyq60S7H2p6V7g1TysM5lAaF" crossorigin="anonymous">



<script type="text/javascript" src="/js/main.min.997ae6d980b0d253afd76f324409f121745697345cd7aa95647153ea145416fa.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        },
	  options: {
		ignoreHtmlClass:'mathjax_ignore',
	  }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>






<script defer="defer" async src="/js/custom/docsearch.min.js" ></script>
<script defer="defer" async>
 
  window.addEventListener('load',function() {
  
	docsearch({
		apiKey: "2991187e127fb95e62db841ea946bc06",
		indexName: "blog",
		appId: "UVGAU2QDTQ",
		inputSelector: '.docsearch-input',
		debug: false,
    });
    docsearch({
	 apiKey: "2991187e127fb95e62db841ea946bc06",
	 indexName: "blog",
	 appId: "UVGAU2QDTQ",
	 inputSelector: '.mob-docsearch-input',
	 debug: false,
    });
  });
 
</script>
  
  <script  src="/custom/img/lazyload.min.js"></script>
  <script defer="defer" async src="/custom/post/back_btn.js"></script>
  

</body>
</html>
