<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>语言基础 - 凌冬的个人博客</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="LYR" /><meta name="description" content="函数调用 这里面涉及的东西其实挺深的，所以等我后面又时间再去研究 Go 中函数传参仅有值传递一种方式； slice、map、channel都是引用类型" /><meta name="keywords" content="凌冬的博客, LYR的个人博客, even" />






<meta name="generator" content="Hugo 0.74.2 with theme even" />


<link rel="canonical" href="https://lyr-2000.github.io/post/01.%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/01.go/3.%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.8963a0cb46404a2c7f30f461e9a04aad32051004a9f78e2ca478263e3a85569d.css" rel="stylesheet"> 

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="语言基础" />
<meta property="og:description" content="函数调用 这里面涉及的东西其实挺深的，所以等我后面又时间再去研究 Go 中函数传参仅有值传递一种方式； slice、map、channel都是引用类型" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://lyr-2000.github.io/post/01.%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/01.go/3.%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/" />
<meta property="article:published_time" content="2021-03-20T15:46:19+00:00" />
<meta property="article:modified_time" content="2021-03-20T15:46:19+00:00" />
<meta itemprop="name" content="语言基础">
<meta itemprop="description" content="函数调用 这里面涉及的东西其实挺深的，所以等我后面又时间再去研究 Go 中函数传参仅有值传递一种方式； slice、map、channel都是引用类型">
<meta itemprop="datePublished" content="2021-03-20T15:46:19&#43;00:00" />
<meta itemprop="dateModified" content="2021-03-20T15:46:19&#43;00:00" />
<meta itemprop="wordCount" content="4584">



<meta itemprop="keywords" content="," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="语言基础"/>
<meta name="twitter:description" content="函数调用 这里面涉及的东西其实挺深的，所以等我后面又时间再去研究 Go 中函数传参仅有值传递一种方式； slice、map、channel都是引用类型"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css">

</head>
<body>
  <div>
    <button class="button pink back">back</button>
    <button class="button pink go">go</button>
  </div>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">凌冬的博客</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><li style="display:inline-block;margin-right:10px;">
			<input type="search" class="mob-docsearch-input" placeholder="Search" />
		</li><a href="/">
        <li class="mobile-menu-item">首页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档页</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a><a href="/friends">
        <li class="mobile-menu-item">大佬</li>
      </a>
	
	
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">凌冬的博客</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">首页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/friends">大佬</a>
      </li><li  style="list-style: none;position: relative;left: 360px;bottom: 32px;">
		<input type="search" class="docsearch-input PC_MARK1" placeholder="Search" />
	  </li></ul>
</nav>
<link rel="stylesheet" href="/custom/css/post.css">

<style>
  .mob-docsearch-input {
	border: 1px solid #ccc;
	padding: 6px 0px;
	border-radius: 3px;
	padding-left:5px;
	position: relative;
    vertical-align: top;
    width: 93%;
    margin: auto;
    margin-left: 7px;
  
  }
  input.PC_MARK1{
	border: 1px solid #ccc;
	padding: 6px 0px;
	border-radius: 3px;
	padding-left:5px;
	-webkit-box-shadow: inset 0 1px 1px rgba(0,0,0,.075);
	box-shadow: inset 0 1px 1px rgba(0,0,0,.075);
	-webkit-transition: border-color ease-in-out .15s,-webkit-box-shadow ease-in-out .15s;
	-o-transition: border-color ease-in-out .15s,box-shadow ease-in-out .15s;
	transition: border-color ease-in-out .15s,box-shadow ease-in-out .15s
}
input.PC_MARK1:focus{
		border-color: #66afe9;
		outline: 0;
		-webkit-box-shadow: inset 0 1px 1px rgba(0,0,0,.075),0 0 8px rgba(102,175,233,.6);
		box-shadow: inset 0 1px 1px rgba(0,0,0,.075),0 0 8px rgba(102,175,233,.6)
}
</style>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">语言基础</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-03-20 </span>
        <div class="post-category">
            <a href="/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"> 程序语言 </a>
            <a href="/categories/go/"> Go </a>
            </div>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#函数调用">函数调用</a>
          <ul>
            <li><a href="#匿名函数">匿名函数</a></li>
            <li><a href="#闭包">闭包</a></li>
            <li><a href="#go的main函数">go的main函数</a></li>
          </ul>
        </li>
        <li><a href="#接口">接口</a>
          <ul>
            <li><a href="#值接收者和指针接收者">值接收者和指针接收者</a></li>
            <li><a href="#底层实现">底层实现</a></li>
          </ul>
        </li>
        <li><a href="#反射">反射</a>
          <ul>
            <li><a href="#反射的三大法则">反射的三大法则</a></li>
            <li><a href="#反射的底层与原理">反射的底层与原理</a></li>
          </ul>
        </li>
        <li><a href="#指针">指针</a></li>
        <li><a href="#nil类型">nil类型</a></li>
        <li><a href="#-操作符">&hellip; 操作符</a></li>
        <li><a href="#常量">常量</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>

    <div class="post-content">
      <h2 id="函数调用">函数调用</h2>
<p>这里面涉及的东西其实挺深的，所以等我后面又时间再去研究</p>
<ul>
<li>Go 中函数传参仅有值传递一种方式；</li>
<li><strong>slice</strong>、<strong>map</strong>、<strong>channel</strong>都是引用类型，但是跟c++的不同；</li>
<li><strong>slice</strong>能够通过函数传参后，修改对应的数组值，是因为 slice 内部保存了引用数组的指针，并不是因为引用传递。</li>
</ul>
<p><a href="https://segmentfault.com/a/1190000015246182">Golang中函数传参存在引用传递吗？ - SegmentFault 思否</a></p>
<h3 id="匿名函数">匿名函数</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 这个是带返回值的 
</span><span class="c1"></span><span class="nx">f</span><span class="o">:=</span><span class="kd">func</span><span class="p">()</span><span class="kt">string</span><span class="p">{</span>
      <span class="k">return</span> <span class="s">&#34;hello world&#34;</span>
 <span class="p">}</span>
 <span class="nx">a</span><span class="o">:=</span><span class="nf">f</span><span class="p">()</span>
<span class="c1">// 当然我们可以直接调用
</span><span class="c1"></span><span class="kd">func</span><span class="p">(</span><span class="nx">a</span> <span class="kt">int</span><span class="p">)</span><span class="kt">string</span><span class="p">{</span>
      <span class="k">return</span> <span class="s">&#34;hello world&#34;</span>
 <span class="p">}(</span><span class="mi">4</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="闭包">闭包</h3>
<p>什么是闭包？ <strong>闭包是由函数和与其相关的引用环境组合而成的实体。</strong></p>
<h4 id="函数变量函数值">函数变量（函数值）</h4>
<p>在 Go 语言中，函数被看作是<strong>第一类值</strong>，这意味着函数像变量一样，有类型、有值，其他普通变量能做的事它也可以。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">square</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nb">println</span><span class="p">(</span><span class="nx">x</span> <span class="o">*</span> <span class="nx">x</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>直接调用：<code>square(1)</code></li>
<li>把函数当成变量一样赋值：<code>s := square</code>；接着可以调用这个函数变量：<code>s(1)</code>。 <strong>注意：这里 <code>square</code> 后面没有圆括号，调用才有。</strong></li>
</ol>
<ul>
<li>调用 <code>nil</code> 的函数变量会导致 panic。</li>
<li>函数变量的零值是 <code>nil</code>，这意味着它可以跟 <code>nil</code> 比较，但两个函数变量之间不能比较。</li>
</ul>
<h4 id="什么是闭包">什么是闭包</h4>
<p>先看一下这个函数，函数叫incr()，返回值为func() int</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">incr</span><span class="p">()</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">x</span> <span class="kt">int</span>
	<span class="k">return</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
		<span class="nx">x</span><span class="o">++</span>
		<span class="k">return</span> <span class="nx">x</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>调用这个函数会返回一个函数变量。下面是一段演示代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">incr</span><span class="p">()</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">x</span> <span class="kt">int</span>
	<span class="k">return</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
		<span class="nx">x</span><span class="o">++</span>
		<span class="k">return</span> <span class="nx">x</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// 获取闭包
</span><span class="c1"></span>	<span class="nx">i</span><span class="o">:=</span><span class="nf">incr</span><span class="p">()</span>
	<span class="c1">// 打印闭包
</span><span class="c1"></span>	<span class="nb">println</span><span class="p">(</span><span class="nf">i</span><span class="p">())</span> <span class="c1">// 1
</span><span class="c1"></span>	<span class="nb">println</span><span class="p">(</span><span class="nf">i</span><span class="p">())</span> <span class="c1">// 2
</span><span class="c1"></span>	<span class="nb">println</span><span class="p">(</span><span class="nf">i</span><span class="p">())</span> <span class="c1">// 3
</span><span class="c1"></span>	<span class="c1">// 下面返回了三个闭包
</span><span class="c1"></span>	<span class="nb">println</span><span class="p">(</span><span class="nf">incr</span><span class="p">()())</span> <span class="c1">// 1
</span><span class="c1"></span>	<span class="nb">println</span><span class="p">(</span><span class="nf">incr</span><span class="p">()())</span> <span class="c1">// 1
</span><span class="c1"></span>	<span class="nb">println</span><span class="p">(</span><span class="nf">incr</span><span class="p">()())</span> <span class="c1">// 1
</span><span class="c1"></span><span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>首先是逃逸问题</p>
<p><code>i := incr()</code>：通过把这个函数变量赋值给 <code>i</code>，<code>i</code> 就成为了一个<strong>闭包</strong>。</p>
<p>所以 <code>i</code> 保存着对 <code>x</code> 的引用，可以想象 <strong>i 中有着一个指针指向 x</strong> 或 <strong>i 中有 x 的地址</strong>。</p>
<p>由于 <code>i</code> 有着指向 <code>x</code> 的指针，所以可以修改 <code>x</code>，我们可以说且保持着状态所以会出现每次打印递增的情况。此时我们可以说</p>
<p>那么为什么下面打印结果都是一样的呢。这是因为这里调用了三次 <code>incr()</code>，返回了三个闭包，这三个闭包引用着三个不同的 <code>x</code>，它们的状态是各自独立的。</p>
<h4 id="闭包会产生的问题">闭包会产生的问题</h4>
<p>现在开始通过例子来说明由闭包引用产生的问题：</p>
<p><strong>地址引用的问题</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">x := 1
f := func() {
	println(x)
}
x = 2
x = 3
f() // 3
</code></pre></td></tr></table>
</div>
</div><p>因为闭包对外层词法域变量是<strong>引用</strong>的，所以这段代码会输出 <strong>3</strong>。可以想象 <code>f</code> 中保存着 <code>x</code> 的地址，它使用 <code>x</code> 时会直接解引用，所以 <code>x</code> 的值改变了会导致 <code>f</code> 解引用得到的值也会改变。</p>
<p>但是下面这段代码会返回1，因为我们的函数是提前调用的，所以此时已经把结果打印出来了，所以后面修改不会影响</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">x</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
	<span class="nb">println</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="c1">// 1
</span><span class="c1"></span><span class="p">}()</span>
<span class="nx">x</span> <span class="p">=</span> <span class="mi">2</span>
<span class="nx">x</span> <span class="p">=</span> <span class="mi">3</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>循环闭包引用问题</strong></p>
<p>每次迭代后都对 <code>i</code> 进行了解引用并使用得到的值且不再使用，所以下面这段代码会正常输出。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
	<span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nb">println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="c1">// 0, 1, 2
</span><span class="c1"></span>	<span class="p">}()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>然而下面这段代码会输出3</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">dummy</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span>
<span class="kd">var</span> <span class="nx">f</span> <span class="kd">func</span><span class="p">()</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">dummy</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
	<span class="nx">f</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nb">println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="nf">f</span><span class="p">()</span> <span class="c1">// 3
</span></code></pre></td></tr></table>
</div>
</div><p>为啥是3呢，其实是因为i加到3才会跳出循环，此时我们打印的是i的地址，所以会打印3，但是如果我们用for range来实现，结果又不同了</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">dummy</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span>
<span class="kd">var</span> <span class="nx">f</span> <span class="kd">func</span><span class="p">()</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dummy</span> <span class="p">{</span>
	<span class="nx">f</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nb">println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="nf">f</span><span class="p">()</span> <span class="c1">// 2
</span></code></pre></td></tr></table>
</div>
</div><p>这是因为 <code>for range</code> 和 <code>for</code> 底层实现上的不同。还有下面这个例子</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">funcSlice</span> <span class="p">[]</span><span class="kd">func</span><span class="p">()</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
	<span class="nx">funcSlice</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">funcSlice</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nb">println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
	<span class="p">})</span>

<span class="p">}</span>
<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
	<span class="nx">funcSlice</span><span class="p">[</span><span class="nx">j</span><span class="p">]()</span> <span class="c1">// 3, 3, 3
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>输出序列为 <strong>3, 3, 3</strong>。</p>
<p><strong>怎么解决上面的问题呢</strong></p>
<p><strong>1. 声明新变量：</strong></p>
<ul>
<li>声明新变量：<code>j := i</code>，且把之后对 <code>i</code> 的操作改为对 <code>j</code> 操作。</li>
<li>声明新同名变量：<code>i := i</code>。<strong>注意：这里短声明右边是外层作用域的 <code>i</code>，左边是新声明的作用域在这一层的 <code>i</code></strong>。原理同上。</li>
</ul>
<p>这相当于为这三个函数各声明一个变量，一共三个，这三个变量初始值分别对应循环中的 <code>i</code> 并且之后不会再改变。</p>
<p><strong>2. 声明新匿名函数并传参：</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">var funcSlice []func()
for i := 0; i &lt; 3; i++ {
	func(i int) {
		funcSlice = append(funcSlice, func() {
			println(i)
		})
	}(i)

}
for j := 0; j &lt; 3; j++ {
	funcSlice[j]() // 0, 1, 2
}
</code></pre></td></tr></table>
</div>
</div><p>现在 <code>println(i)</code> 使用的 <code>i</code> 是通过函数参数传递进来的，并且 Go 语言的函数参数是按值传递的。</p>
<p>所以相当于在这个新的匿名函数内声明了三个变量，被三个闭包函数独立引用。原理跟第一种方法是一样的。</p>
<p>这里的解决方法可以用在大多数跟闭包引用有关的问题上，不局限于第三个例子。</p>
<p>参考：</p>
<p><a href="https://juejin.cn/post/6844903793771937805">Go 语言闭包详解 (juejin.cn)</a></p>
<h3 id="go的main函数">go的main函数</h3>
<ol>
<li>main函数不能带参数</li>
<li>main函数不能定义返回值</li>
<li>main函数所在的包必须为main包</li>
<li>main函数中可以使用flag包来获取和解析命令行参数</li>
</ol>
<h2 id="接口">接口</h2>
<p>接口的本质是引入一个新的中间层，调用方可以通过接口与具体实现分离，解除上下游的耦合，上层的模块不再需要依赖下层的具体模块，只需要依赖一个约定好的接口。</p>
<p><img src="https://img.xiaoyou66.com/2021/03/26/1e5f5bbdd096b.png" alt="golang-interface"></p>
<p>我们可以使用结构体指针或者结构体来实现接口，但是默认情况下，还是推荐使用指针</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Cat</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">Duck</span> <span class="kd">interface</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span>  <span class="nx">Cat</span><span class="p">)</span> <span class="nx">Quack</span> <span class="p">{}</span>  <span class="c1">// 使用结构体实现接口
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Cat</span><span class="p">)</span> <span class="nx">Quack</span> <span class="p">{}</span>  <span class="c1">// 使用结构体指针实现接口
</span><span class="c1"></span>
<span class="kd">var</span> <span class="nx">d</span> <span class="nx">Duck</span> <span class="p">=</span> <span class="nx">Cat</span><span class="p">{}</span>      <span class="c1">// 使用结构体初始化变量
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">d</span> <span class="nx">Duck</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">Cat</span><span class="p">{}</span>     <span class="c1">// 使用结构体指针初始化变量
</span></code></pre></td></tr></table>
</div>
</div><table>
<thead>
<tr>
<th align="center">结构体实现接口</th>
<th align="center">结构体指针实现接口</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">结构体初始化变量</td>
<td align="center">通过</td>
<td>不通过</td>
</tr>
<tr>
<td align="center">结构体指针初始化变量</td>
<td align="center">通过</td>
<td>通过</td>
</tr>
</tbody>
</table>
<p>后面一些东西过于底层，所以先暂时跳过</p>
<h3 id="值接收者和指针接收者">值接收者和指针接收者</h3>
<p>其实就是初始化结构体的两种方式，在调用方法的时候，值类型既可以调用值接收者的方法，也可以调用指针接收者的方法；指针类型既可以调用指针接收者的方法，也可以调用值接收者的方法。也就是说，不管方法的接收者是什么类型，该类型的值和指针都可以调用，不必严格符合接收者的类型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>
<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
<span class="kd">type</span> <span class="nx">Person</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">age</span> <span class="kt">int</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">Person</span><span class="p">)</span> <span class="nf">Elegance</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">p</span><span class="p">.</span><span class="nx">age</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Person</span><span class="p">)</span> <span class="nf">GetAge</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">p</span><span class="p">.</span><span class="nx">age</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// p1 是值类型
</span><span class="c1"></span>    <span class="nx">p</span> <span class="o">:=</span> <span class="nx">Person</span><span class="p">{</span><span class="nx">age</span><span class="p">:</span> <span class="mi">18</span><span class="p">}</span>
    <span class="c1">// 值类型 调用接收者也是值类型的方法
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nf">howOld</span><span class="p">())</span>
    <span class="c1">// 值类型 调用接收者是指针类型的方法
</span><span class="c1"></span>    <span class="nx">p</span><span class="p">.</span><span class="nf">GetAge</span><span class="p">()</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nf">GetAge</span><span class="p">())</span>

    <span class="c1">// ----------------------
</span><span class="c1"></span>    <span class="c1">// p2 是指针类型
</span><span class="c1"></span>    <span class="nx">p2</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Person</span><span class="p">{</span><span class="nx">age</span><span class="p">:</span> <span class="mi">100</span><span class="p">}</span>
    <span class="c1">// 指针类型 调用接收者是值类型的方法
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">p2</span><span class="p">.</span><span class="nf">GetAge</span><span class="p">())</span>
    <span class="c1">// 指针类型 调用接收者也是指针类型的方法
</span><span class="c1"></span>    <span class="nx">p2</span><span class="p">.</span><span class="nf">GetAge</span><span class="p">()</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">p2</span><span class="p">.</span><span class="nf">GetAge</span><span class="p">())</span>
<span class="p">}</span>
<span class="cm">/**
</span><span class="cm">18
</span><span class="cm">19
</span><span class="cm">100
</span><span class="cm">101
</span><span class="cm">**/</span>
</code></pre></td></tr></table>
</div>
</div><table>
<thead>
<tr>
<th>函数和方法</th>
<th>值接收者</th>
<th>指针接收者</th>
</tr>
</thead>
<tbody>
<tr>
<td>值类型调用者</td>
<td>方法会使用调用者的一个副本，类似于“传值”</td>
<td>使用值的引用来调用方法，上例中，p1.GetAge() 实际上是 (&amp;p1).GetAge().</td>
</tr>
<tr>
<td>指针类型调用者</td>
<td>指针被解引用为值，上例中，p2.GetAge()实际上是 (*p1).GetAge()</td>
<td>实际上也是“传值”，方法里的操作会影响到调用者，类似于指针传参，拷贝了一份指针</td>
</tr>
</tbody>
</table>
<p>如果实现了接收者是值类型的方法，会隐含地也实现了接收者是指针类型的方法。</p>
<p>如果方法的接收者是值类型，无论调用者是对象还是对象指针，修改的都是对象的副本，不影响调用者；如果方法的接收者是指针类型，则调用者修改的是指针指向的对象本身。</p>
<p>通常我们使用指针作为方法的接收者的理由：</p>
<ul>
<li>使用指针方法能够修改接收者指向的值。</li>
<li>可以避免在每次调用方法时复制该值，在值的类型为大型结构体时，这样做会更加高效。</li>
</ul>
<p>因而呢,我们是使用值接收者还是指针接收者，不是由该方法是否修改了调用者（也就是接收者）来决定，而是应该基于该类型的本质。</p>
<p>如果类型具备“原始的本质”，也就是说它的成员都是由 Go 语言里内置的原始类型，如字符串，整型值等，那就定义值接收者类型的方法。像内置的引用类型，如 slice，map，interface，channel，这些类型比较特殊，声明他们的时候，实际上是创建了一个 header， 对于他们也是直接定义值接收者类型的方法。这样，调用函数时，是直接 copy 了这些类型的 header，而 header 本身就是为复制设计的。</p>
<p>如果类型具备非原始的本质，不能被安全地复制，这种类型总是应该被共享，那就定义指针接收者的方法。比如 go 源码里的文件结构体（struct File）就不应该被复制，应该只有一份实体。</p>
<p>接口值的零值是指动态类型和动态值都为 nil。当仅且当这两部分的值都为 nil 的情况下，这个接口值就才会被认为 接口值 == nil。</p>
<h3 id="底层实现">底层实现</h3>
<p>go的底层主要包括下面这两部分组成</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">iface</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">tab</span>  <span class="o">*</span><span class="nx">itab</span>
	<span class="nx">data</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>tab 中存放的是类型、方法等信息。data 指针指向的 iface 绑定对象的原始数据的副本。这里同样遵循 Go 的统一规则，值传递。tab 是 itab 类型的指针。</p>
<p>itab 中包含 5 个字段。inner 存的是 interface 自己的静态类型。_ type 存的是 interface 对应具体对象的类型。itab 中的 _type 和 iface 中的 data 能简要描述一个变量。 _type 是这个变量对应的类型，data 是这个变量的值。这里的 hash 字段和 _type 中存的 hash 字段是完全一致的，这么做的目的是为了类型断言(下文会提到)。fun 是一个函数指针，它指向的是具体类型的函数方法。虽然这里只有一个函数指针，但是它可以调用很多方法。在这个指针对应内存地址的后面依次存储了多个方法，利用指针偏移便可以找到它们。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">itab</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">inter</span> <span class="o">*</span><span class="nx">interfacetype</span>
	<span class="nx">_type</span> <span class="o">*</span><span class="nx">_type</span>
	<span class="nx">hash</span>  <span class="kt">uint32</span> <span class="c1">// copy of _type.hash. Used for type switches.
</span><span class="c1"></span>	<span class="nx">_</span>     <span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="kt">byte</span>
	<span class="nx">fun</span>   <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="kt">uintptr</span> <span class="c1">// variable sized. fun[0]==0 means _type does not implement inter.
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="空-interface-数据结构">空 interface 数据结构</h4>
<p>空的 inferface{} 是没有方法集的接口。所以不需要 itab 数据结构。它只需要存类型和类型对应的值即可。对应的数据结构如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">eface</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">_type</span> <span class="o">*</span><span class="nx">_type</span>
	<span class="nx">data</span>  <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>从这个数据结构可以看出，只有当 2 个字段都为 nil，空接口才为 nil。空接口的主要目的有 2 个，一是实现“泛型”，二是使用反射。</p>
<p>。。。。后面的大佬直接啃到汇编去了，打扰了。。。</p>
<p><a href="https://halfrost.com/go_interface/">深入研究 Go interface 底层实现 (halfrost.com)</a></p>
<h2 id="反射">反射</h2>
<p><a href="https://golang.org/pkg/reflect/"><code>reflect</code></a> 实现了运行时的反射能力，包括动态修改变量、判断类型是否实现了某些接口以及动态调用方法等功能。能够让程序操作不同类型的对象<a href="https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-reflect/#fn:1">1</a>。反射包中有两对非常重要的函数和类型，两个函数分别是：</p>
<ul>
<li><a href="https://draveness.me/golang/tree/reflect.TypeOf"><code>reflect.TypeOf</code></a> 能获取类型信息；</li>
<li><a href="https://draveness.me/golang/tree/reflect.ValueOf"><code>reflect.ValueOf</code></a> 能获取数据的运行时表示；</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Test_question</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
   <span class="nx">a</span><span class="o">:=</span><span class="mi">456</span>
   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nf">TypeOf</span><span class="p">(</span><span class="nx">a</span><span class="p">))</span>
   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="nx">a</span><span class="p">))</span>
   <span class="cm">/*
</span><span class="cm">   * int
</span><span class="cm">   * 456
</span><span class="cm">   */</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="反射的三大法则">反射的三大法则</h3>
<ol>
<li>从 <code>interface{}</code> 变量可以反射出反射对象；</li>
<li>从反射对象可以获取 <code>interface{}</code> 变量；</li>
<li>要修改反射对象，其值必须可设置；</li>
</ol>
<h3 id="反射的底层与原理">反射的底层与原理</h3>
<p>数据interface中保存有结构数据，只要想办法拿到该数据对应的内存地址，然后把该数据转成interface，通过查看interface中的类型结构，就可以知道该数据的结构了</p>
<p><img src="https://img.xiaoyou66.com/2021/03/29/47e462c1c4106.png" alt="img"></p>
<p>参考:</p>
<ol>
<li><a href="https://i6448038.github.io/2020/02/15/golang-reflection/">图解go反射实现原理 - 菜刚RyuGou的博客 (i6448038.github.io)</a></li>
</ol>
<h2 id="指针">指针</h2>
<p>go通过指针变量p访问成员变量的时候，有下面这两种方式来访问</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">p.name
(*p).name
</code></pre></td></tr></table>
</div>
</div><p>为什么-&gt;不行呢，因为这个符号是用来操作管道的</p>
<ul>
<li>go其实是可以自动解引的，所以我们可以不使用*来获取指针，但是go解引能力有限，只能解除一次引用</li>
<li>&amp;是取地址符，放到变量前使用，就会返回相应变量的内存地址。</li>
<li>*用于来获取指针的内容，指针变量可以使用这个符号来获取内容</li>
<li>结构体指针，使用 &ldquo;.&rdquo; 操作符来访问结构体成员</li>
<li>go的指针是属于引用类型，是复合类型中的一种</li>
<li>go语言的指针不支持指针运算</li>
</ul>
<h2 id="nil类型">nil类型</h2>
<p>Go语言中的引用类型只有五个：</p>
<p><strong>切片</strong> <strong>映射</strong> <strong>函数</strong> <strong>方法</strong> <strong>通道</strong></p>
<p>nil只能赋值给上面五种通道类型的变量以及指针变量。</p>
<h2 id="-操作符">&hellip; 操作符</h2>
<p>有两个用法，一个用于函数里面 <strong>多参数</strong> ，一个是append里面 <strong>合并</strong> 切片</p>
<p>这个一般用于函数拥有多个参数的情况下</p>
<p><img src="https://img.xiaoyou66.com/images/2020/11/22/V4qOP.png" alt="img"></p>
<p>下面这种方式调用是没有问题的</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nf">add</span><span class="p">([]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">}</span><span class="o">...</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p><img src="https://img.xiaoyou66.com/images/2020/11/22/V4upr.png" alt="img"></p>
<p><img src="https://img.xiaoyou66.com/images/2020/11/22/V48iQ.png" alt="img"></p>
<h2 id="常量">常量</h2>
<p>单个声明</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">显式类型定义</span><span class="err">：</span> <span class="kd">const</span> <span class="nx">b</span> <span class="kt">string</span> <span class="p">=</span> <span class="s">&#34;abc&#34;</span>
<span class="nx">隐式类型定义</span><span class="err">：</span> <span class="kd">const</span> <span class="nx">b</span> <span class="p">=</span> <span class="s">&#34;abc&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>常量枚举</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
    <span class="nx">Unknown</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="nx">Female</span> <span class="p">=</span> <span class="mi">1</span>
    <span class="nx">Male</span> <span class="p">=</span> <span class="mi">2</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>常量可以用len(), cap(), unsafe.Sizeof()函数计算表达式的值。常量表达式中，函数必须是内置函数</p>
</blockquote>
<p><strong>特殊常量</strong></p>
<p>iota，特殊常量，可以认为是一个可以被编译器修改的常量。</p>
<p>iota 在 const关键字出现时将被重置为 0(const 内部的第一行之前)，const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
    <span class="nx">a</span> <span class="p">=</span> <span class="kc">iota</span>
    <span class="nx">b</span> <span class="p">=</span> <span class="kc">iota</span>
    <span class="nx">c</span> <span class="p">=</span> <span class="kc">iota</span>
<span class="p">)</span>
<span class="c1">// 第一个 iota 等于 0，每当 iota 在新的一行被使用时，它的值都会自动加 1；所以 a=0, b=1, c=2 可以简写为如下形式：
</span><span class="c1"></span><span class="kd">const</span> <span class="p">(</span>
    <span class="nx">a</span> <span class="p">=</span> <span class="kc">iota</span>
    <span class="nx">b</span>
    <span class="nx">c</span>
<span class="p">)</span>
<span class="c1">// 甚至可以这样用
</span><span class="c1"></span><span class="kd">const</span> <span class="p">(</span>
    <span class="nx">a</span> <span class="p">=</span> <span class="kc">iota</span>   <span class="c1">//0
</span><span class="c1"></span>    <span class="nx">b</span>          <span class="c1">//1
</span><span class="c1"></span>    <span class="nx">c</span>          <span class="c1">//2
</span><span class="c1"></span>    <span class="nx">d</span> <span class="p">=</span> <span class="s">&#34;ha&#34;</span>   <span class="c1">//独立值，iota += 1
</span><span class="c1"></span>    <span class="nx">e</span>          <span class="c1">//&#34;ha&#34;   iota += 1
</span><span class="c1"></span>    <span class="nx">f</span> <span class="p">=</span> <span class="mi">100</span>    <span class="c1">//iota +=1
</span><span class="c1"></span>    <span class="nx">g</span>          <span class="c1">//100  iota +=1
</span><span class="c1"></span>    <span class="nx">h</span> <span class="p">=</span> <span class="kc">iota</span>   <span class="c1">//7,恢复计数
</span><span class="c1"></span>    <span class="nx">i</span>          <span class="c1">//8
</span><span class="c1"></span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">,</span><span class="nx">c</span><span class="p">,</span><span class="nx">d</span><span class="p">,</span><span class="nx">e</span><span class="p">,</span><span class="nx">f</span><span class="p">,</span><span class="nx">g</span><span class="p">,</span><span class="nx">h</span><span class="p">,</span><span class="nx">i</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div>
    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">LYR</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2021-03-20
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags//"></a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/01.%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/01.go/1.%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">编译原理</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        
      </nav>
    </footer>
  </article>

  
  
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:lyr-2000@qq.com" class="iconfont icon-email" title="email"></a>
  <a href="" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span>lyr</span>
  </span>
</div>



<script 
 
    src="https://cdn.jsdelivr.net/gh/lyr-2000/live2d-widget@latest/autoload.js"></script>



    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c12618f9a600c40bd024996677e951e64d3487006775aeb22e200c990006c5c7.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>






<script src="/js//custom/latex_plugin.js"></script>
<script src="/js/custom/docsearch.min.js" ></script>
<script>
 
  docsearch({
    apiKey: "2991187e127fb95e62db841ea946bc06",
    indexName: "blog",
    appId: "UVGAU2QDTQ",
    inputSelector: '.docsearch-input',
    debug: false,
  });
  docsearch({
    apiKey: "2991187e127fb95e62db841ea946bc06",
    indexName: "blog",
    appId: "UVGAU2QDTQ",
    inputSelector: '.mob-docsearch-input',
    debug: false,
  });
 
</script>

  <script src="/custom/post/back_btn.js"></script>
</body>
</html>
