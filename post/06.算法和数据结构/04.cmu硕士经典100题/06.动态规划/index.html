<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>动态规划 - 凌冬的个人博客</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="LYR" /><meta name="description" content="算法解释 这里我们引用一下维基百科的描述：“动态规划（Dynamic Programming, DP）在查找有很多 重叠子问题的情况的最优解时有效。它将问题重新组合成子问" /><meta name="keywords" content="凌冬的博客, LYR的个人博客, even" />






<meta name="generator" content="Hugo 0.74.2 with theme even" />


<link rel="canonical" href="https://lyr-2000.github.io/post/06.%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/04.cmu%E7%A1%95%E5%A3%AB%E7%BB%8F%E5%85%B8100%E9%A2%98/06.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.8963a0cb46404a2c7f30f461e9a04aad32051004a9f78e2ca478263e3a85569d.css" rel="stylesheet"> 

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="动态规划" />
<meta property="og:description" content="算法解释 这里我们引用一下维基百科的描述：“动态规划（Dynamic Programming, DP）在查找有很多 重叠子问题的情况的最优解时有效。它将问题重新组合成子问" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://lyr-2000.github.io/post/06.%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/04.cmu%E7%A1%95%E5%A3%AB%E7%BB%8F%E5%85%B8100%E9%A2%98/06.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" />
<meta property="article:published_time" content="2021-03-24T21:46:28+00:00" />
<meta property="article:modified_time" content="2021-03-24T21:46:28+00:00" />
<meta itemprop="name" content="动态规划">
<meta itemprop="description" content="算法解释 这里我们引用一下维基百科的描述：“动态规划（Dynamic Programming, DP）在查找有很多 重叠子问题的情况的最优解时有效。它将问题重新组合成子问">
<meta itemprop="datePublished" content="2021-03-24T21:46:28&#43;00:00" />
<meta itemprop="dateModified" content="2021-03-24T21:46:28&#43;00:00" />
<meta itemprop="wordCount" content="5712">



<meta itemprop="keywords" content="," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="动态规划"/>
<meta name="twitter:description" content="算法解释 这里我们引用一下维基百科的描述：“动态规划（Dynamic Programming, DP）在查找有很多 重叠子问题的情况的最优解时有效。它将问题重新组合成子问"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css">

</head>
<body>
  <div>
    <button class="button pink back">back</button>
    <button class="button pink go">go</button>
  </div>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">凌冬的博客</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><li style="display:inline-block;margin-right:10px;">
			<input type="search" class="mob-docsearch-input" placeholder="Search" />
		</li><a href="/">
        <li class="mobile-menu-item">首页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档页</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a><a href="/friends">
        <li class="mobile-menu-item">大佬</li>
      </a>
	
	
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">凌冬的博客</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">首页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/friends">大佬</a>
      </li><li  style="list-style: none;position: relative;left: 360px;bottom: 32px;">
		<input type="search" class="docsearch-input PC_MARK1" placeholder="Search" />
	  </li></ul>
</nav>
<link rel="stylesheet" href="/custom/css/post.css">

<style>
  .mob-docsearch-input {
	border: 1px solid #ccc;
	padding: 6px 0px;
	border-radius: 3px;
	padding-left:5px;
	position: relative;
    vertical-align: top;
    width: 93%;
    margin: auto;
    margin-left: 7px;
  
  }
  input.PC_MARK1{
	border: 1px solid #ccc;
	padding: 6px 0px;
	border-radius: 3px;
	padding-left:5px;
	-webkit-box-shadow: inset 0 1px 1px rgba(0,0,0,.075);
	box-shadow: inset 0 1px 1px rgba(0,0,0,.075);
	-webkit-transition: border-color ease-in-out .15s,-webkit-box-shadow ease-in-out .15s;
	-o-transition: border-color ease-in-out .15s,box-shadow ease-in-out .15s;
	transition: border-color ease-in-out .15s,box-shadow ease-in-out .15s
}
input.PC_MARK1:focus{
		border-color: #66afe9;
		outline: 0;
		-webkit-box-shadow: inset 0 1px 1px rgba(0,0,0,.075),0 0 8px rgba(102,175,233,.6);
		box-shadow: inset 0 1px 1px rgba(0,0,0,.075),0 0 8px rgba(102,175,233,.6)
}
</style>

    </header>
	
	

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">动态规划</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-03-24 </span>
        <div class="post-category">
            <a href="/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"> 算法和数据结构 </a>
            <a href="/categories/cmu%E7%A1%95%E5%A3%AB%E7%BB%8F%E5%85%B8100%E9%A2%98/"> CMU硕士经典100题 </a>
            </div>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#算法解释">算法解释</a></li>
        <li><a href="#基本动态规划-一维">基本动态规划 一维</a>
          <ul>
            <li><a href="#爬楼梯">爬楼梯</a></li>
            <li><a href="#打家劫舍">打家劫舍</a></li>
            <li><a href="#等差数列划分看起来简单就是不知道原理">等差数列划分（看起来简单，就是不知道原理）</a></li>
          </ul>
        </li>
        <li><a href="#基本动态规划--二维">基本动态规划  二维</a>
          <ul>
            <li><a href="#最小路径和">最小路径和</a></li>
            <li><a href="#01矩阵">01矩阵</a></li>
            <li><a href="#最大正方形待做">最大正方形（待做）</a></li>
          </ul>
        </li>
        <li><a href="#分割类型题">分割类型题</a>
          <ul>
            <li><a href="#完全平方数">完全平方数</a></li>
            <li><a href="#解码方法待做">解码方法（待做）</a></li>
            <li><a href="#单词拆分待做">单词拆分（待做）</a></li>
          </ul>
        </li>
        <li><a href="#子序列问题">子序列问题</a>
          <ul>
            <li><a href="#最长递增子序列">最长递增子序列</a></li>
            <li><a href="#最长公共子序列待做">最长公共子序列（待做）</a></li>
          </ul>
        </li>
        <li><a href="#背包问题">背包问题</a>
          <ul>
            <li><a href="#分割等和子集">分割等和子集</a></li>
            <li><a href="#一和零待做">一和零（待做）</a></li>
            <li><a href="#零钱兑换待做">零钱兑换（待做）</a></li>
          </ul>
        </li>
        <li><a href="#字符串编辑">字符串编辑</a>
          <ul>
            <li><a href="#编辑距离">编辑距离</a></li>
            <li><a href="#两个键的键盘待做">两个键的键盘（待做）</a></li>
            <li><a href="#正则表达式匹配待做">正则表达式匹配（待做）</a></li>
          </ul>
        </li>
        <li><a href="#股票交易">股票交易</a>
          <ul>
            <li><a href="#买卖股票的最佳时机">买卖股票的最佳时机</a></li>
            <li><a href="#买卖股票的最佳时机-iv">买卖股票的最佳时机 IV</a></li>
            <li><a href="#最佳买卖股票时机含冷冻期">最佳买卖股票时机含冷冻期</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>

    <div class="post-content">
      <h2 id="算法解释">算法解释</h2>
<p>这里我们引用一下维基百科的描述：“动态规划（Dynamic Programming, DP）在查找有很多 <strong>重叠子问题</strong>的情况的最优解时有效。它将问题重新组合成子问题。为了避免多次解决这些子问 题，它们的结果都逐渐被计算并被保存，从简单的问题直到整个问题都被解决。因此，动态规划 保存递归时的结果，因而不会在解决同样的问题时花费时间 · · · · · · 动态规划只能应用于有<strong>最优子结构的问题</strong>。最优子结构的意思是局部最优解能决定全局最优解（对有些问题这个要求并不能 完全满足，故有时需要引入一定的近似）。简单地说，问题能够分解成子问题来解决。”</p>
<p>通俗一点来讲，动态规划和其它遍历算法（如深/广度优先搜索）都是将原问题拆成多个子问 题然后求解，他们之间最本质的区别是，动态规划<strong>保存子问题的解，避免重复计算</strong>。解决动态规 划问题的关键是找到<strong>状态转移方程</strong>，这样我们可以通过计算和储存子问题的解来求解最终问题。 同时，我们也可以对动态规划进行<strong>空间压缩</strong>，起到节省空间消耗的效果。这一技巧笔者将在 之后的题目中介绍。</p>
<p>在一些情况下，动态规划可以看成是带有<strong>状态记录</strong>（memoization）的优先搜索。状态记录的 意思为，如果一个子问题在优先搜索时已经计算过一次，我们可以把它的结果储存下来，之后遍 历到该子问题的时候可以直接返回储存的结果。动态规划是自下而上的，即先解决子问题，再解 决父问题；而用带有状态记录的优先搜索是自上而下的，即从父问题搜索到子问题，若重复搜索 到同一个子问题则进行状态记录，防止重复计算。如果题目需求的是最终状态，那么使用动态搜 索比较方便；如果题目需要输出所有的路径，那么使用带有状态记录的优先搜索会比较方便。</p>
<h2 id="基本动态规划-一维">基本动态规划 一维</h2>
<h3 id="爬楼梯">爬楼梯</h3>
<p><a href="https://leetcode-cn.com/problems/climbing-stairs/">70. 爬楼梯 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<p><img src="https://img.xiaoyou66.com/2021/03/24/e2c17de10b22c.png" alt="image-20210317191207204"></p>
<p>动态规划难就难在如何找出状态方程。</p>
<p>这里我们每次可走一步或者两步，所以我们每阶的方法数其实就是i-1阶和i-2阶的方法数相加。所以我们的状态转移方程为 dp[i] = dp[i-1] + dp[i-2]</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">climbStairs</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
   <span class="c1">// 如果步数小于等于2，那么我们直接返回n
</span><span class="c1"></span>   <span class="k">if</span> <span class="nx">n</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">n</span>
   <span class="p">}</span>
   <span class="c1">// 初始化dp数组并全部赋值为1
</span><span class="c1"></span>   <span class="nx">dp</span><span class="o">:=</span><span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="nx">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
   <span class="k">for</span> <span class="nx">k</span><span class="o">:=</span><span class="k">range</span> <span class="nx">dp</span><span class="p">{</span>
      <span class="nx">dp</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>
   <span class="p">}</span>
   <span class="c1">// 这里我们计算每集阶楼梯所需要的步数
</span><span class="c1"></span>   <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
      <span class="c1">// 这个就是关键了，我们需要列出状态方程
</span><span class="c1"></span>      <span class="c1">// 因为我们的状态方程是第 i-1 或 i-2这两层的方法数
</span><span class="c1"></span>      <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>不过实际上我们不需要专门搞一个数组，可以直接简化为三个边量就可以了</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">climbStairs</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
   <span class="k">if</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="mi">2</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">n</span>
   <span class="p">}</span>
   <span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">,</span><span class="nx">c</span><span class="o">:=</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span>
   <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">2</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;=</span><span class="nx">n</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
      <span class="nx">a</span> <span class="p">=</span> <span class="nx">b</span> <span class="o">+</span> <span class="nx">c</span>
      <span class="nx">c</span> <span class="p">=</span> <span class="nx">b</span>
      <span class="nx">b</span> <span class="p">=</span> <span class="nx">a</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="nx">a</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="打家劫舍">打家劫舍</h3>
<p><a href="https://leetcode-cn.com/problems/house-robber/">198. 打家劫舍 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<p><img src="https://img.xiaoyou66.com/2021/03/24/200f3f3c26e5a.png" alt="image-20210317193401418"></p>
<p>动态规划问题的难点就在于如何计算出状态转移方程，这里我看了一下题解，知道了状态转移方程却还是搞不懂，到后面看了代码才发生是自己思考的方式有问题，既然多个问题很难想，那我们就假设只有一家，那么结果很简单，然后我们的房子一步步加，我们可以得到这样一个规律，如果我们打劫上一家的总收益比打劫这家和上第二家的收益大的话，那么我们这家不打劫就可以了</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">rob</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
   <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span> <span class="p">{</span>
      <span class="k">return</span> <span class="mi">0</span>
   <span class="p">}</span>
   <span class="nx">n</span><span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span>
   <span class="nx">dp</span><span class="o">:=</span><span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="nx">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
   <span class="c1">// 当我们只抢劫一个房子时，结果就是num[0]
</span><span class="c1"></span>   <span class="nx">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="nx">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
   <span class="c1">// 这个dp就是当有n个房子时的最大收益，我们分别开始计算
</span><span class="c1"></span>   <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
      <span class="c1">// 最大收益计算的关键部分就在这里了，当[i-1] 大于 num[i-1]+dp[i-2]时
</span><span class="c1"></span>      <span class="c1">// 也就是当我们打劫前一家的收益比打劫当前这家和前第二家的收益更大时，这家我们就不打劫
</span><span class="c1"></span>      <span class="k">if</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">&gt;</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="p">{</span>
         <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
         <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
      <span class="p">}</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>当然，我们也可以进行压缩，不使用数组</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">rob</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
   <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
      <span class="k">return</span> <span class="mi">0</span>
   <span class="p">}</span>
   <span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">,</span><span class="nx">c</span><span class="o">:=</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span>
   <span class="nx">n</span><span class="o">:=</span><span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span>
   <span class="c1">// 这里我们直接从0开始计算
</span><span class="c1"></span>   <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nx">n</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
      <span class="k">if</span> <span class="nx">b</span> <span class="p">&gt;</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">+</span><span class="nx">c</span> <span class="p">{</span>
         <span class="nx">a</span><span class="p">=</span><span class="nx">b</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
         <span class="nx">a</span><span class="p">=</span><span class="nx">c</span><span class="o">+</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
      <span class="p">}</span>
      <span class="nx">c</span><span class="p">=</span><span class="nx">b</span><span class="p">;</span><span class="nx">b</span><span class="p">=</span><span class="nx">a</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="nx">a</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="等差数列划分看起来简单就是不知道原理">等差数列划分（看起来简单，就是不知道原理）</h3>
<p><a href="https://leetcode-cn.com/problems/arithmetic-slices/">413. 等差数列划分 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<p><img src="https://img.xiaoyou66.com/2021/03/24/5eb6ea2dc891d.png" alt="image-20210319102103711"></p>
<p>这题目一言难尽。。。。先暂时跳过。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">numberOfArithmeticSlices</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
   <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="p">&lt;</span> <span class="mi">3</span> <span class="p">{</span>
      <span class="k">return</span> <span class="mi">0</span>
   <span class="p">}</span>
   <span class="c1">// 初始化dp数组
</span><span class="c1"></span>   <span class="nx">dp</span><span class="o">:=</span><span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">))</span>
   <span class="c1">// 遍历我们的nums，来计算dp数组
</span><span class="c1"></span>   <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
      <span class="c1">// 当前位置是否符合等差数列的定义
</span><span class="c1"></span>      <span class="k">if</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">-</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="p">{</span>
         <span class="c1">// 如果满足，那么dp就为上个dp+1
</span><span class="c1"></span>         <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span>
      <span class="p">}</span>
   <span class="p">}</span>
   <span class="nx">sum</span><span class="o">:=</span><span class="mi">0</span>
   <span class="c1">// 计算dp数组和
</span><span class="c1"></span>   <span class="k">for</span> <span class="nx">_</span><span class="p">,</span><span class="nx">v</span><span class="o">:=</span><span class="k">range</span> <span class="nx">dp</span><span class="p">{</span>
      <span class="nx">sum</span><span class="o">+=</span><span class="nx">v</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="nx">sum</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>我来通俗·地解释下，dp[i]中i即为以i结尾的等差数列的个数，原问题可以拆分为原数列中以i结尾的等差数列之和。观察和分析可知，如果一个满足条件A[i] - A[i - 1] == A[i - 1] - A[i - 2]则证明i和之前的数列构成新的等差数列，如果之前以i-1结尾的等差数列为dp[i-1]个，那么以i结尾的等差数列的个数为dp[i -1] + 1，递推表达式得出则原问题解决。</p>
<h2 id="基本动态规划--二维">基本动态规划  二维</h2>
<h3 id="最小路径和">最小路径和</h3>
<p><img src="https://img.xiaoyou66.com/2021/03/24/e60be0b424243.png" alt="image-20210319112635319"></p>
<p>这个题目的难点还是在于状态方程，首先明确一点，我们的路径是只能向下或者向右，所以我们可以知道第一列和第一行的值肯定是前面的累加，后面任意一个点的和其实就是上面或者右边中任意一个较小的值，下面这个gif很形象也很好理解</p>
<p><img src="https://img.xiaoyou66.com/2021/03/24/12b6da4f41460.gif" alt="test"></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">minPathSum</span><span class="p">(</span><span class="nx">grid</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">m</span><span class="p">,</span><span class="nx">n</span><span class="o">:=</span><span class="nb">len</span><span class="p">(</span><span class="nx">grid</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="nx">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
	<span class="c1">// 首先我们可以计算第一行和第一列
</span><span class="c1"></span>	<span class="c1">// 因为我们只能向下或者向右移动所以这一行和第一列是前面的累加
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">m</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">grid</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="nx">grid</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nx">i</span><span class="p">]</span> <span class="o">+=</span> <span class="nx">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="c1">// 遍历计算后面的dp值
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">m</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="c1">// 第i和j的位置最小值其实就是上面或者左边 中选一个最小的
</span><span class="c1"></span>			<span class="nx">grid</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nf">min</span><span class="p">(</span><span class="nx">grid</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">j</span><span class="p">],</span><span class="nx">grid</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">grid</span><span class="p">[</span><span class="nx">m</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">min</span><span class="p">(</span><span class="nx">a</span> <span class="kt">int</span><span class="p">,</span><span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>  <span class="p">{</span>
	<span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">b</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">a</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="01矩阵">01矩阵</h3>
<p><a href="https://leetcode-cn.com/problems/01-matrix/">542. 01 矩阵 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<p><img src="https://img.xiaoyou66.com/2021/03/24/34e7f06a1f740.png" alt="image-20210319190322041"></p>
<p>这题的状态转移方程我想出来了，但是代码没写出来一开始我是同时比较上下左右，但是没有意识到当我们第一扫描时，只能确定上和左，所以扫描下和右是没用的，还会造成错误答案。</p>
<p>第二次我意识到了要扫描两次，但是我居然还同时判断上左同时满足条件，实际上我们要分开判断，而且还必须和自身进行比较，因为我们第一次扫描的 时候可能已经是最优值了，没有必要从其他两个方向选最小的</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">updateMatrix</span><span class="p">(</span><span class="nx">matrix</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
   <span class="nx">m</span><span class="p">,</span><span class="nx">n</span><span class="o">:=</span><span class="nb">len</span><span class="p">(</span><span class="nx">matrix</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="nx">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
   <span class="c1">// 初始化数组
</span><span class="c1"></span>   <span class="nx">dp</span><span class="o">:=</span><span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span><span class="nx">m</span><span class="p">)</span>
   <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nx">m</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
      <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="nx">n</span><span class="p">)</span>
   <span class="p">}</span>
   <span class="c1">// 为了方便，我们先把所有的都设为int的最大值，方便后面比较
</span><span class="c1"></span>   <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nx">m</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
      <span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
         <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">MaxInt32</span>
      <span class="p">}</span>
   <span class="p">}</span>
   <span class="c1">// 这个东西的状态转移方程比较简单就是从上下左右四个反向中找到一个最小的
</span><span class="c1"></span>   <span class="c1">// 不过我们第一次遍历是从左上扫描到右下，所以这里我们只能获取上和左这两个方向
</span><span class="c1"></span>   <span class="c1">// 所以我们这里需要扫描两次，完成上下左右这四个方向
</span><span class="c1"></span>   <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nx">m</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
      <span class="k">for</span> <span class="nx">j</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">j</span><span class="p">&lt;</span><span class="nx">n</span><span class="p">;</span><span class="nx">j</span><span class="o">++</span><span class="p">{</span>
         <span class="c1">// 如果当前位置为0，那么结果就是0
</span><span class="c1"></span>         <span class="k">if</span> <span class="nx">matrix</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span>
         <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// 在确定最小值时我们先确保上和左可以访问并和自身比较
</span><span class="c1"></span>            <span class="c1">// 这里为什么要和自身比较呢，因为一开始我们dp值就是最大的
</span><span class="c1"></span>            <span class="c1">// 然后这里我们是分别比较了上和左，所以我们需要使用dp[i][j]来临时存储最小的值
</span><span class="c1"></span>            <span class="c1">// 最后就是我们第二次扫描时，可能第一次扫描时当前值已经是最小的了，所以我们就没有必要非要从另外两个方向比较
</span><span class="c1"></span>            <span class="k">if</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
               <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nf">min</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">],</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="nx">j</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
               <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nf">min</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">],</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="p">}</span>
         <span class="p">}</span>
      <span class="p">}</span>
   <span class="p">}</span>
   <span class="c1">// 下面这个就是从右下扫描到左上，找出下和右中最小的值
</span><span class="c1"></span>   <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="nx">m</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="nx">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="o">--</span><span class="p">{</span>
      <span class="k">for</span> <span class="nx">j</span><span class="o">:=</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="nx">j</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span><span class="nx">j</span><span class="o">--</span><span class="p">{</span>
         <span class="c1">// 因为我们第一次扫描的时候已经知道0了，所以这里没有必要再次比较
</span><span class="c1"></span>         <span class="k">if</span> <span class="nx">matrix</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nx">i</span><span class="o">+</span><span class="mi">1</span> <span class="p">&lt;</span> <span class="nx">m</span> <span class="p">{</span>
               <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nf">min</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">])</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="nx">j</span><span class="o">+</span><span class="mi">1</span> <span class="p">&lt;</span> <span class="nx">n</span> <span class="p">{</span>
               <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nf">min</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">],</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="p">}</span>
         <span class="p">}</span>
      <span class="p">}</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="nx">dp</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">min</span><span class="p">(</span><span class="nx">a</span> <span class="kt">int</span><span class="p">,</span><span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
   <span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">b</span>
   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">a</span>
   <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="最大正方形待做">最大正方形（待做）</h3>
<p><a href="https://leetcode-cn.com/problems/maximal-square/">221. 最大正方形 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<h2 id="分割类型题">分割类型题</h2>
<h3 id="完全平方数">完全平方数</h3>
<p><a href="https://leetcode-cn.com/problems/perfect-squares/">279. 完全平方数 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<p><img src="https://img.xiaoyou66.com/2021/03/24/1465959328011.png" alt="image-20210319194959574"></p>
<p>这题目告诉我们千万不要使用思维定势来解题，我一直以为状态方程比较的是相邻的位置，但是实际上我们不止是比较相邻的位置，我们还可以比较i-k^2的位置，比如这里我们的状态转移方程实际上就是dp[i]=1 + min(dp[i-1], dp[i-4], dp[i-9] · · · )</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">numSquares</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
   <span class="nx">dp</span><span class="o">:=</span><span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="nx">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
   <span class="k">for</span> <span class="nx">k</span><span class="o">:=</span><span class="k">range</span> <span class="nx">dp</span><span class="p">{</span>
      <span class="nx">dp</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span> <span class="p">=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">MaxInt32</span>
   <span class="p">}</span>
   <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span>
   <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
      <span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span><span class="o">*</span><span class="nx">j</span> <span class="o">&lt;=</span> <span class="nx">i</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
         <span class="c1">// 这个状态转移方程比的不是相邻的而是比i-k^2的位置
</span><span class="c1"></span>         <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nf">Min</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="nx">j</span><span class="o">*</span><span class="nx">j</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
      <span class="p">}</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Min</span><span class="p">(</span><span class="nx">a</span> <span class="kt">int</span><span class="p">,</span><span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
   <span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">b</span>
   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">a</span>
   <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="解码方法待做">解码方法（待做）</h3>
<p><a href="https://leetcode-cn.com/problems/decode-ways/">91. 解码方法 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<h3 id="单词拆分待做">单词拆分（待做）</h3>
<p><a href="https://leetcode-cn.com/problems/word-break/">139. 单词拆分 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<h2 id="子序列问题">子序列问题</h2>
<h3 id="最长递增子序列">最长递增子序列</h3>
<p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">300. 最长递增子序列 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<p><img src="https://img.xiaoyou66.com/2021/03/24/e7b4ae937c6c7.png" alt="image-20210320101359782"></p>
<p>这题目其实还算是简单的，只要理解了原理之后。。。</p>
<p>这个和前面的完全平方数不同，这里的动态规划实际上是需要重新遍历一次的，因为我们只要满足递增子序列，我们就必须算进去，所以我们需要进行双层for循环，第二层是从头开始继续遍历，只要满足条件并且长度比当前的长，我们就计算进去。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">lengthOfLIS</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
   <span class="nx">max</span><span class="p">,</span><span class="nx">n</span><span class="o">:=</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span>
   <span class="k">if</span> <span class="nx">n</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">n</span>
   <span class="p">}</span>
   <span class="c1">// 初始情况，我们设置所有dp的数组为1
</span><span class="c1"></span>   <span class="nx">dp</span><span class="o">:=</span><span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="nx">n</span><span class="p">)</span>
   <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="k">range</span> <span class="nx">dp</span><span class="p">{</span>
      <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>
   <span class="p">}</span>
   <span class="c1">// 这里我们需要使用两层循环来进行遍历
</span><span class="c1"></span>   <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
      <span class="c1">// 这里一层for循环是以为我们这个是求递增的子序列
</span><span class="c1"></span>      <span class="c1">// 为了获取到所有情况，所以我们这里使用dp数组来实现
</span><span class="c1"></span>      <span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nx">i</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
         <span class="c1">// 只要i的值大于j，这个时候我们就可以说序列是递增的
</span><span class="c1"></span>         <span class="k">if</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">&gt;</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">{</span>
            <span class="c1">// 然后我们只需要比较一下，找出最大的一个就可以了
</span><span class="c1"></span>            <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nf">Max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span><span class="nx">dp</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
         <span class="p">}</span>
      <span class="p">}</span>
      <span class="c1">// 这里我们实时更新一下max的值
</span><span class="c1"></span>      <span class="nx">max</span> <span class="p">=</span> <span class="nf">Max</span><span class="p">(</span><span class="nx">max</span><span class="p">,</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="nx">max</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Max</span><span class="p">(</span><span class="nx">a</span> <span class="kt">int</span><span class="p">,</span><span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>  <span class="p">{</span>
   <span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">a</span>
   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">b</span>
   <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="最长公共子序列待做">最长公共子序列（待做）</h3>
<p><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">1143. 最长公共子序列 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<h2 id="背包问题">背包问题</h2>
<p>背包问题是一种组合优化的 NP 完全问题：有 N 个物品和容量为 W 的背包，每个物品都有 自己的体积 w 和价值 v，求拿哪些物品可以使得背包所装下物品的总价值最大。<strong>如果限定每种物 品只能选择 0 个或 1 个，则问题称为 0-1 背包问题</strong>；如果<strong>不限定每种物品的数量，则问题称为无界背包问题或完全背包问题</strong>。</p>
<h3 id="分割等和子集">分割等和子集</h3>
<p><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">416. 分割等和子集 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<p><img src="https://img.xiaoyou66.com/2021/03/24/15fa76c978353.png" alt="image-20210320111220891"></p>
<p>这题目不是很好解释，等我把大概算法过一遍再来整理</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">canPartition</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
   <span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span>
   <span class="k">if</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="mi">2</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">false</span>
   <span class="p">}</span>
   <span class="nx">sum</span><span class="p">,</span> <span class="nx">max</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
   <span class="c1">// 这里我们计算总数的时候还需要顺便计算最大值
</span><span class="c1"></span>   <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">nums</span> <span class="p">{</span>
      <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">v</span>
      <span class="k">if</span> <span class="nx">v</span> <span class="p">&gt;</span> <span class="nx">max</span> <span class="p">{</span>
         <span class="nx">max</span> <span class="p">=</span> <span class="nx">v</span>
      <span class="p">}</span>
   <span class="p">}</span>
   <span class="c1">// 判断是否可以平分为两部分
</span><span class="c1"></span>   <span class="k">if</span> <span class="nx">sum</span><span class="o">%</span><span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">false</span>
   <span class="p">}</span>
   <span class="c1">// 计算我们的目标值
</span><span class="c1"></span>   <span class="nx">target</span> <span class="o">:=</span> <span class="nx">sum</span> <span class="o">/</span> <span class="mi">2</span>
   <span class="c1">// 当最大值大于目标值时，一定是不能再分的
</span><span class="c1"></span>   <span class="k">if</span> <span class="nx">max</span> <span class="p">&gt;</span> <span class="nx">target</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">false</span>
   <span class="p">}</span>
   <span class="c1">// 初始化一个dp数组，一维对应数组的个数，二维对应我们背包问题的目标值
</span><span class="c1"></span>   <span class="nx">dp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">bool</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
   <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dp</span> <span class="p">{</span>
      <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">bool</span><span class="p">,</span> <span class="nx">target</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
   <span class="p">}</span>
   <span class="c1">// 默认情况下，当我们的目标值为0时，一定可以满足
</span><span class="c1"></span>   <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
      <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
   <span class="p">}</span>
   <span class="c1">// 然后就是当i为0时，我们只能存放nums[0]这个元素，此时当我们的目标值为num[0]时，也满足条件
</span><span class="c1"></span>   <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nx">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="p">=</span> <span class="kc">true</span>
   <span class="c1">// 这里我们开始计算dp数组（注意0已经计算好了，我们从1开始）
</span><span class="c1"></span>   <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
      <span class="c1">// 获取当前的值
</span><span class="c1"></span>      <span class="nx">v</span> <span class="o">:=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
      <span class="c1">// 从1开始挨个计算目标值为j的情况下，放i个元素可能的结果
</span><span class="c1"></span>      <span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;=</span> <span class="nx">target</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
         <span class="c1">// 当我们目标值大于i当前值时
</span><span class="c1"></span>         <span class="k">if</span> <span class="nx">j</span> <span class="o">&gt;=</span> <span class="nx">v</span> <span class="p">{</span>
            <span class="c1">// 我们可以判断一下如果i小于1，是否可以满足条件
</span><span class="c1"></span>            <span class="c1">// 或者前面一个恰好放入v时满足条件
</span><span class="c1"></span>            <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">||</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">j</span><span class="o">-</span><span class="nx">v</span><span class="p">]</span>
         <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span>
         <span class="p">}</span>
      <span class="p">}</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">target</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="一和零待做">一和零（待做）</h3>
<p><a href="https://leetcode-cn.com/problems/ones-and-zeroes/">474. 一和零 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<h3 id="零钱兑换待做">零钱兑换（待做）</h3>
<p><a href="https://leetcode-cn.com/problems/coin-change/">322. 零钱兑换 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<h2 id="字符串编辑">字符串编辑</h2>
<h3 id="编辑距离">编辑距离</h3>
<p><a href="https://leetcode-cn.com/problems/edit-distance/">72. 编辑距离 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<p><img src="https://img.xiaoyou66.com/2021/03/25/811e9c37addc1.png" alt="image-20210325102550453"></p>
<p>这题个人感觉难点就在于如何理解动态规划，比如我们这里使用一个二维数组，一维就是第一个字符串，二维是第二个字符串，我们要做的就是把dp数组给填完。</p>
<p>如果要修改这么多字符串肯定很难，我们可以从最简单的开始，首先我们第一个字符串从只有一位开始，然后我们第二个字符也是从第一位逐次加到全部，在遍历的过程中，有下面这三种情况</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">1.当我们选择修改时，需要修改的次数是dp[i-1][j-1]（这个自己理解吧）
2.当我们选择插入 j 位置/删除 i 位置时，需要修改的次数为 dp[i-1][j] + 1
3.当我们选择插入 i 位置/删除 j 位置时，需要修改的次数为 dp[i][j-1] + 1
</code></pre></td></tr></table>
</div>
</div><p>然后就是从这三个操作中找出代价最小的那一个，就是当前的最优解</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">func minDistance(word1 string, word2 string) int {
	m,n := len(word1),len(word2)
	// 创建dp数组一维表示第一个字符串，二维表示第二个字符串
	dp:=make([][]int,m+1)
	for i := 0; i &lt;=m; i++ {
		dp[i] = make([]int,n+1)
	}
	// 准备计算
	for i := 0; i &lt;= m; i++ {
		for j := 0; j &lt;= n; j++ {
			// 当i等于0时，表示第一个字符串没有内容
			// 所以我们如果想转换为第二个字符串时，需要操作j次（此时第二个字符串长度为j）
			if i == 0 {
				dp[i][j] = j
			} else if j == 0 {
				// 当j等于0时，表示第二个字符串为空
				// 如果我们需要转为第二个字符串，需要操作i次（就是删除i次，第一个字符串长度为i）
				dp[i][j] = i
			} else {
				var eq int
				// 判断当前位置的字符串是否相同(注意，数组的长度从0开始，所以我们要-1)
				if word1[i-1] == word2[j-1] {
					eq = 0
				} else {
					eq = 1
				}
				// 这里我们需要考虑三种情况
				// 1.当我们选择修改时，需要修改的次数是dp[i-1][j-1]（这个自己理解吧）
				// 2.当我们选择插入 j 位置/删除 i 位置时，需要修改的次数为 dp[i-1][j] + 1
				// 3.当我们选择插入 i 位置/删除 j 位置时，需要修改的次数为 dp[i][j-1] + 1
				dp[i][j] = min(dp[i-1][j-1]+eq,min(dp[i-1][j]+1,dp[i][j-1]+1))
			}
		}
	}
	return dp[m][n]
}
func min(a int,b int) int {
	if a &gt; b {
		return b
	} else {
		return a
	}
}
</code></pre></td></tr></table>
</div>
</div><h3 id="两个键的键盘待做">两个键的键盘（待做）</h3>
<p><a href="https://leetcode-cn.com/problems/2-keys-keyboard/">650. 只有两个键的键盘 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<h3 id="正则表达式匹配待做">正则表达式匹配（待做）</h3>
<p><a href="https://leetcode-cn.com/problems/regular-expression-matching/comments/">10. 正则表达式匹配 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<h2 id="股票交易">股票交易</h2>
<p>股票交易类问题通常可以用动态规划来解决。对于稍微复杂一些的股票交易类问题，比如需 要冷却时间或者交易费用，则可以用通过动态规划实现的状态机来解决。</p>
<h3 id="买卖股票的最佳时机">买卖股票的最佳时机</h3>
<p><img src="https://img.xiaoyou66.com/2021/03/25/56a8a59272f3c.png" alt="image-20210325133858483"></p>
<p>额。。。我服了，我还以为这题用动态规划来解，还一直在研究怎么用动态规划（最后看了一下别人的代码，当场自闭）。</p>
<p>这题其实非常简单，就是首先要找出一个最低价股票然后买入，最后我们依次判断当前价格卖出得到的结果是不是最高的，如果是设置一下最大值，然后继续往下直到遍历整个数组。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">maxProfit</span><span class="p">(</span><span class="nx">prices</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
   <span class="c1">// sell表示利润
</span><span class="c1"></span>   <span class="nx">sell</span><span class="o">:=</span><span class="mi">0</span>
   <span class="c1">// buy表示我们买入的价格，这里我们取负，后面计算利润可以直接相加即可
</span><span class="c1"></span>   <span class="nx">buy</span><span class="o">:=</span><span class="nx">math</span><span class="p">.</span><span class="nx">MinInt32</span>
   <span class="c1">// 遍历整个数组
</span><span class="c1"></span>   <span class="k">for</span> <span class="nx">_</span><span class="p">,</span><span class="nx">v</span><span class="o">:=</span><span class="k">range</span> <span class="nx">prices</span><span class="p">{</span>
      <span class="c1">// 首先找到一个最低价格买入
</span><span class="c1"></span>      <span class="nx">buy</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="nx">buy</span><span class="p">,</span><span class="o">-</span><span class="nx">v</span><span class="p">)</span>
      <span class="c1">// 判断当前卖出是否可以获得最大利润
</span><span class="c1"></span>      <span class="nx">sell</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="nx">sell</span><span class="p">,</span><span class="nx">buy</span><span class="o">+</span><span class="nx">v</span><span class="p">)</span>
   <span class="p">}</span>
   <span class="c1">// 返回最大利润
</span><span class="c1"></span>   <span class="k">return</span> <span class="nx">sell</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">max</span><span class="p">(</span><span class="nx">a</span> <span class="kt">int</span><span class="p">,</span><span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
   <span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">a</span>
   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">b</span>
   <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="买卖股票的最佳时机-iv">买卖股票的最佳时机 IV</h3>
<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">188. 买卖股票的最佳时机 IV - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<h3 id="最佳买卖股票时机含冷冻期">最佳买卖股票时机含冷冻期</h3>
<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. 最佳买卖股票时机含冷冻期 - 力扣（LeetCode） (leetcode-cn.com)</a></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">LYR</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2021-03-24
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags//"></a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/06.%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/04.cmu%E7%A1%95%E5%A3%AB%E7%BB%8F%E5%85%B8100%E9%A2%98/03.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">二分查找</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/06.%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/04.cmu%E7%A1%95%E5%A3%AB%E7%BB%8F%E5%85%B8100%E9%A2%98/02.%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95/">
            <span class="next-text nav-default">双指针法</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>

  
  
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:lyr-2000@qq.com" class="iconfont icon-email" title="email"></a>
  <a href="" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span>lyr</span>
  </span>
</div>



<script 
 
    src="https://cdn.jsdelivr.net/gh/lyr-2000/live2d-widget@latest/autoload.js"></script>



    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c12618f9a600c40bd024996677e951e64d3487006775aeb22e200c990006c5c7.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>






<script defer="defer" async src="/js/custom/docsearch.min.js" ></script>
<script defer="defer" async>
 
  window.addEventListener('load',function() {
  
	docsearch({
		apiKey: "2991187e127fb95e62db841ea946bc06",
		indexName: "blog",
		appId: "UVGAU2QDTQ",
		inputSelector: '.docsearch-input',
		debug: false,
    });
    docsearch({
	 apiKey: "2991187e127fb95e62db841ea946bc06",
	 indexName: "blog",
	 appId: "UVGAU2QDTQ",
	 inputSelector: '.mob-docsearch-input',
	 debug: false,
    });
  });
 
</script>
  <script  src="/custom/img/lazyload.min.js"></script>
  <script defer="defer" async src="/custom/post/back_btn.js"></script>
  
</body>
</html>
