<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>各种搜索 - 凌冬的个人博客</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="LYR" /><meta name="description" content="解释 深度优先搜索和广度优先搜索是两种最常见的优先搜索方法，它们被广泛地运用在图和树等 结构中进行搜索。 深度优先搜索 深度优先搜索（depth-f" /><meta name="keywords" content="凌冬的博客, LYR的个人博客, even" />






<meta name="generator" content="Hugo 0.74.2 with theme even" />


<link rel="canonical" href="https://lyr-2000.github.io/post/06.%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/04.cmu%E7%A1%95%E5%A3%AB%E7%BB%8F%E5%85%B8100%E9%A2%98/05.%E5%90%84%E7%A7%8D%E6%90%9C%E7%B4%A2/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.8963a0cb46404a2c7f30f461e9a04aad32051004a9f78e2ca478263e3a85569d.css" rel="stylesheet"> 

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="各种搜索" />
<meta property="og:description" content="解释 深度优先搜索和广度优先搜索是两种最常见的优先搜索方法，它们被广泛地运用在图和树等 结构中进行搜索。 深度优先搜索 深度优先搜索（depth-f" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://lyr-2000.github.io/post/06.%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/04.cmu%E7%A1%95%E5%A3%AB%E7%BB%8F%E5%85%B8100%E9%A2%98/05.%E5%90%84%E7%A7%8D%E6%90%9C%E7%B4%A2/" />
<meta property="article:published_time" content="2021-03-24T21:46:28+00:00" />
<meta property="article:modified_time" content="2021-03-24T21:46:28+00:00" />
<meta itemprop="name" content="各种搜索">
<meta itemprop="description" content="解释 深度优先搜索和广度优先搜索是两种最常见的优先搜索方法，它们被广泛地运用在图和树等 结构中进行搜索。 深度优先搜索 深度优先搜索（depth-f">
<meta itemprop="datePublished" content="2021-03-24T21:46:28&#43;00:00" />
<meta itemprop="dateModified" content="2021-03-24T21:46:28&#43;00:00" />
<meta itemprop="wordCount" content="4962">



<meta itemprop="keywords" content="," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="各种搜索"/>
<meta name="twitter:description" content="解释 深度优先搜索和广度优先搜索是两种最常见的优先搜索方法，它们被广泛地运用在图和树等 结构中进行搜索。 深度优先搜索 深度优先搜索（depth-f"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css">

</head>
<body>
  <div>
    <button class="button pink back">back</button>
    <button class="button pink go">go</button>
  </div>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">凌冬的博客</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><li style="display:inline-block;margin-right:10px;">
			<input type="search" class="mob-docsearch-input" placeholder="Search" />
		</li><a href="/">
        <li class="mobile-menu-item">首页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档页</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a><a href="/friends">
        <li class="mobile-menu-item">大佬</li>
      </a>
	
	
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">凌冬的博客</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">首页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/friends">大佬</a>
      </li><li  style="list-style: none;position: relative;left: 360px;bottom: 32px;">
		<input type="search" class="docsearch-input PC_MARK1" placeholder="Search" />
	  </li></ul>
</nav>
<link rel="stylesheet" href="/custom/css/post.css">

<style>
  .mob-docsearch-input {
	border: 1px solid #ccc;
	padding: 6px 0px;
	border-radius: 3px;
	padding-left:5px;
	position: relative;
    vertical-align: top;
    width: 93%;
    margin: auto;
    margin-left: 7px;
  
  }
  input.PC_MARK1{
	border: 1px solid #ccc;
	padding: 6px 0px;
	border-radius: 3px;
	padding-left:5px;
	-webkit-box-shadow: inset 0 1px 1px rgba(0,0,0,.075);
	box-shadow: inset 0 1px 1px rgba(0,0,0,.075);
	-webkit-transition: border-color ease-in-out .15s,-webkit-box-shadow ease-in-out .15s;
	-o-transition: border-color ease-in-out .15s,box-shadow ease-in-out .15s;
	transition: border-color ease-in-out .15s,box-shadow ease-in-out .15s
}
input.PC_MARK1:focus{
		border-color: #66afe9;
		outline: 0;
		-webkit-box-shadow: inset 0 1px 1px rgba(0,0,0,.075),0 0 8px rgba(102,175,233,.6);
		box-shadow: inset 0 1px 1px rgba(0,0,0,.075),0 0 8px rgba(102,175,233,.6)
}
</style>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">各种搜索</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-03-24 </span>
        <div class="post-category">
            <a href="/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"> 算法和数据结构 </a>
            <a href="/categories/cmu%E7%A1%95%E5%A3%AB%E7%BB%8F%E5%85%B8100%E9%A2%98/"> CMU硕士经典100题 </a>
            </div>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#解释">解释</a></li>
        <li><a href="#深度优先搜索">深度优先搜索</a>
          <ul>
            <li><a href="#岛屿最大面积">岛屿最大面积</a></li>
            <li><a href="#省份的数量">省份的数量</a></li>
            <li><a href="#太平洋大西洋流水问题">太平洋，大西洋流水问题</a></li>
          </ul>
        </li>
        <li><a href="#回溯法">回溯法</a>
          <ul>
            <li><a href="#全排列">全排列</a></li>
            <li><a href="#组合">组合</a></li>
            <li><a href="#单词搜索待做">单词搜索（待做）</a></li>
            <li><a href="#n皇后问题待做">N皇后问题（待做）</a></li>
          </ul>
        </li>
        <li><a href="#广度优先搜索">广度优先搜索</a>
          <ul>
            <li><a href="#最短的桥待做">最短的桥（待做）</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>

    <div class="post-content">
      <h2 id="解释">解释</h2>
<p>深度优先搜索和广度优先搜索是两种最常见的优先搜索方法，它们被广泛地运用在图和树等 结构中进行搜索。</p>
<h2 id="深度优先搜索">深度优先搜索</h2>
<p>深度优先搜索（depth-first seach，DFS）在搜索到一个新的节点时，立即对该新节点进行遍 历；因此遍历需要用先入后出的栈来实现，也可以通过与栈等价的递归来实现。对于树结构而言， 由于总是对新节点调用遍历，因此看起来是向着“深”的方向前进。 考虑如下一颗简单的树。我们从 1 号节点开始遍历，假如遍历顺序是从左子节点到右子节点， 那么按照优先向着“深”的方向前进的策略，假如我们使用递归实现，我们的遍历过程为 1（起 始节点）-&gt;2（遍历更深一层的左子节点）-&gt;4（遍历更深一层的左子节点）-&gt;2（无子节点，返回 父结点）-&gt;1（子节点均已完成遍历，返回父结点）-&gt;3（遍历更深一层的右子节点）-&gt;1（无子节 点，返回父结点）-&gt; 结束程序（子节点均已完成遍历）。如果我们使用栈实现，我们的栈顶元素 的变化过程为 1-&gt;2-&gt;4-&gt;3。</p>
<p><img src="https://img.xiaoyou66.com/2021/03/24/eec3322582436.png" alt="image-20210316113706503"></p>
<p>深度优先搜索也可以用来检测环路：记录每个遍历过的节点的父节点，若一个节点被再次遍 历且父节点不同，则说明有环。我们也可以用之后会讲到的拓扑排序判断是否有环路，若最后存 在入度不为零的点，则说明有环。 有时我们可能会需要对已经搜索过的节点进行标记，以防止在遍历时重复搜索某个节点，这 种做法叫做状态记录或记忆化（memoization）。</p>
<h3 id="岛屿最大面积">岛屿最大面积</h3>
<p><a href="https://leetcode-cn.com/problems/max-area-of-island/">695. 岛屿的最大面积 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<p><img src="https://img.xiaoyou66.com/2021/03/24/90babd891c5be.png" alt="image-20210316113910603"></p>
<p>思路一：使用栈，因为这个题目其实就是要我们遍历整个二维数组，比如我们遇到一个点，那么我们就可以把这个点放入栈中，然后把这点置为空。然后我们对当前点进行上下左右判断，如果为1，就把值放入栈中，并把这个点置为0。我们一直遍历直到栈为空为止，这里我们用到了一个技巧，对于四个方向的遍历，我们可以创造一个数组[-1,0,1,0,-1]每相邻两个就是上下左右这四个方向</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">direction</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">}</span>
<span class="c1">// 使用栈的写法
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">maxAreaOfIsland</span><span class="p">(</span><span class="nx">grid</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">m</span><span class="o">:=</span><span class="nb">len</span><span class="p">(</span><span class="nx">grid</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">m</span><span class="o">==</span><span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="nx">n</span><span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
	<span class="nx">area</span><span class="p">,</span> <span class="nx">localArea</span> <span class="o">:=</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span>
	<span class="kd">var</span> <span class="nx">x</span><span class="p">,</span><span class="nx">y</span> <span class="kt">int</span>
	<span class="c1">// 遍历数组
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">m</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="c1">// 如果当前节点为1，我们就可以进行遍历了
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">grid</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">==</span><span class="mi">1</span> <span class="p">{</span>
				<span class="nx">localArea</span> <span class="p">=</span> <span class="mi">1</span>
				<span class="nx">grid</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span>
				<span class="c1">// 自己定义一个栈
</span><span class="c1"></span>				<span class="nx">island</span><span class="o">:=</span><span class="nx">Stack</span><span class="p">{}</span>
				<span class="c1">// 把当前值放入栈中
</span><span class="c1"></span>				<span class="nx">island</span><span class="p">.</span><span class="nf">Push</span><span class="p">([]</span><span class="kt">int</span><span class="p">{</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">})</span>
				<span class="c1">// 遍历直到栈为空位置
</span><span class="c1"></span>				<span class="k">for</span> <span class="p">!</span><span class="nx">island</span><span class="p">.</span><span class="nf">Empty</span><span class="p">()</span> <span class="p">{</span>
					<span class="c1">// 获取当前栈顶的值
</span><span class="c1"></span>					<span class="nx">r</span><span class="p">,</span><span class="nx">c</span><span class="o">:=</span><span class="nx">island</span><span class="p">.</span><span class="nf">Pop</span><span class="p">()</span>
					<span class="c1">// 我们分别依次判断当前值的上下左右是否为空
</span><span class="c1"></span>					<span class="k">for</span> <span class="nx">k</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">k</span> <span class="p">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="nx">k</span><span class="o">++</span> <span class="p">{</span>
						<span class="c1">// 这里我们使用了一个小技巧，每相邻两位即为上下左右四个方向之一
</span><span class="c1"></span>						<span class="nx">x</span> <span class="p">=</span><span class="nx">r</span><span class="o">+</span> <span class="nx">direction</span><span class="p">[</span><span class="nx">k</span><span class="p">];</span><span class="nx">y</span> <span class="p">=</span> <span class="nx">c</span><span class="o">+</span><span class="nx">direction</span><span class="p">[</span><span class="nx">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
						<span class="c1">// 这里我们还需要判断一下x，y的范围是否在矩形内，以免越界
</span><span class="c1"></span>						<span class="k">if</span> <span class="nx">x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">x</span> <span class="p">&lt;</span> <span class="nx">m</span> <span class="o">&amp;&amp;</span> <span class="nx">y</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">y</span> <span class="p">&lt;</span> <span class="nx">n</span> <span class="o">&amp;&amp;</span> <span class="nx">grid</span><span class="p">[</span><span class="nx">x</span><span class="p">][</span><span class="nx">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
							<span class="c1">// 这里我们就把grid置为0，然后把这个点放入栈中
</span><span class="c1"></span>							<span class="nx">grid</span><span class="p">[</span><span class="nx">x</span><span class="p">][</span><span class="nx">y</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span>
							<span class="nx">localArea</span><span class="o">++</span>
							<span class="nx">island</span><span class="p">.</span><span class="nf">Push</span><span class="p">([]</span><span class="kt">int</span><span class="p">{</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">})</span>
						<span class="p">}</span>
					<span class="p">}</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="nx">localArea</span> <span class="p">&gt;</span> <span class="nx">area</span> <span class="p">{</span>
					<span class="nx">area</span><span class="p">=</span> <span class="nx">localArea</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">area</span>
<span class="p">}</span>

<span class="c1">// 自己定义一个简单的栈
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Stack</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">i</span> 	 <span class="kt">int</span>
	<span class="nx">data</span> <span class="p">[][]</span><span class="kt">int</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Stack</span><span class="p">)</span> <span class="nf">Push</span><span class="p">(</span><span class="nx">k</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span>  <span class="p">{</span>
	<span class="nx">s</span><span class="p">.</span><span class="nx">data</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">data</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span>
	<span class="nx">s</span><span class="p">.</span><span class="nx">i</span> <span class="p">=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">data</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Stack</span><span class="p">)</span> <span class="nf">Pop</span><span class="p">()</span> <span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">,</span><span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">x</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">data</span><span class="p">[</span><span class="nx">s</span><span class="p">.</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
	<span class="nx">y</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">data</span><span class="p">[</span><span class="nx">s</span><span class="p">.</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
	<span class="nx">s</span><span class="p">.</span><span class="nx">i</span><span class="o">--</span>
	<span class="k">return</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Stack</span><span class="p">)</span> <span class="nf">Empty</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">0</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>使用递归的方法也很简单，我简单看了一下别人的代码，然后把辅助函数写出来了哈哈</p>
<p>原理很简单，我们同样遍历整个矩阵，如果当前节点的值不为0，那么我们就可以对当前节点进行dfs操作，获取当前这个节点的区域值。然后dfs的代码也很简单，直接使用我们上个的栈的方法，我们同样对当前点的上下左右进行递归操作，最后就可以得出结果，关键部分在于理解dfs函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">direction</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">}</span>
<span class="c1">// 使用递归的写法
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">maxAreaOfIsland</span><span class="p">(</span><span class="nx">grid</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
   <span class="c1">// 当grid大小为0时，我们就退出循环
</span><span class="c1"></span>   <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">grid</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span> <span class="o">||</span> <span class="nb">len</span><span class="p">(</span><span class="nx">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">==</span><span class="mi">0</span> <span class="p">{</span>
      <span class="k">return</span> <span class="mi">0</span>
   <span class="p">}</span>
   <span class="c1">// 当前最大区域为0
</span><span class="c1"></span>   <span class="nx">maxArea</span><span class="o">:=</span><span class="mi">0</span>
   <span class="c1">// 我们开始遍历整个grid数组
</span><span class="c1"></span>   <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">grid</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
      <span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">grid</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
         <span class="c1">// 当当前这个点为1的时候，我们就获取一下当前的区域信息
</span><span class="c1"></span>         <span class="k">if</span> <span class="nx">grid</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="c1">// 使用dfs来获取当前的地域信息
</span><span class="c1"></span>            <span class="nx">area</span><span class="o">:=</span><span class="nf">dfs</span><span class="p">(</span><span class="nx">grid</span><span class="p">,</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">)</span>
            <span class="c1">// 更新最大的区域
</span><span class="c1"></span>            <span class="k">if</span> <span class="nx">area</span> <span class="p">&gt;</span> <span class="nx">maxArea</span> <span class="p">{</span>
               <span class="nx">maxArea</span> <span class="p">=</span> <span class="nx">area</span>
            <span class="p">}</span>
         <span class="p">}</span>
      <span class="p">}</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="nx">maxArea</span>
<span class="p">}</span>
<span class="c1">// 使用一个辅函数，这个就是我们的关键部分了
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">dfs</span><span class="p">(</span><span class="nx">grid</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">,</span><span class="nx">r</span> <span class="kt">int</span><span class="p">,</span><span class="nx">c</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
   <span class="c1">// 因为是递归函数，所以我们需要设置一个递归的条件
</span><span class="c1"></span>   <span class="k">if</span> <span class="nx">grid</span><span class="p">[</span><span class="nx">r</span><span class="p">][</span><span class="nx">c</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
      <span class="k">return</span> <span class="mi">0</span>
   <span class="p">}</span>
   <span class="c1">// 如果r，c所在的值不为0，那么当前区域值就为1，同时把当前区域值置为0
</span><span class="c1"></span>   <span class="nx">area</span><span class="o">:=</span> <span class="mi">1</span>
   <span class="kd">var</span> <span class="nx">x</span><span class="p">,</span><span class="nx">y</span> <span class="kt">int</span>
   <span class="nx">grid</span><span class="p">[</span><span class="nx">r</span><span class="p">][</span><span class="nx">c</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span>
   <span class="c1">// 对当前位置进行遍历，判断上下左右四个方向
</span><span class="c1"></span>   <span class="k">for</span> <span class="nx">k</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">k</span> <span class="p">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="nx">k</span><span class="o">++</span> <span class="p">{</span>
      <span class="c1">// 这里我们通过direction数组来实现获取当前位置的上下左右
</span><span class="c1"></span>      <span class="nx">x</span><span class="p">=</span><span class="nx">direction</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span><span class="o">+</span><span class="nx">r</span>
      <span class="nx">y</span><span class="p">=</span><span class="nx">direction</span><span class="p">[</span><span class="nx">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="nx">c</span>
      <span class="c1">// 确保这个值在矩阵的范围内
</span><span class="c1"></span>      <span class="k">if</span> <span class="nx">x</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">y</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">x</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">grid</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">y</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
         <span class="c1">// 注意这我们不需要判断当前位置是否为0，因为dfs会自己计算，如果为0就会返回0
</span><span class="c1"></span>         <span class="nx">area</span><span class="o">+=</span><span class="nf">dfs</span><span class="p">(</span><span class="nx">grid</span><span class="p">,</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">)</span>
      <span class="p">}</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="nx">area</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="省份的数量">省份的数量</h3>
<p><a href="https://leetcode-cn.com/problems/number-of-provinces/">547. 省份数量 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<p><img src="https://img.xiaoyou66.com/2021/03/24/83841b86c71db.png" alt="image-20210316170608966"></p>
<p>思路：这个我一开始就想不到。。但是后面看了一遍代码，就大概知道其原理了。我们如何判断i城市和j城市是否相连呢？直接判断arr<code>[i][j]</code>是否为1即可，知道这点后我们做起来就方便多了</p>
<p>首先我们可以创建一个和城市大小一样的数组，然后我们可以通过设置一个标志位，如果当前城市访问了那么我们就不管，如果我们没访问，我们就遍历这个城市，把所有相连的城市全部连接起来</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">findCircleNum</span><span class="p">(</span><span class="nx">isConnected</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
   <span class="c1">// 首先我们获取城市的数量
</span><span class="c1"></span>   <span class="nx">n</span><span class="o">:=</span><span class="nb">len</span><span class="p">(</span><span class="nx">isConnected</span><span class="p">)</span>
   <span class="c1">// count表示省份的数量
</span><span class="c1"></span>   <span class="nx">count</span><span class="o">:=</span><span class="mi">0</span>
   <span class="c1">// 我们创建一个visited数组，这个用于表示当前城市是否访问过了
</span><span class="c1"></span>   <span class="nx">visited</span><span class="o">:=</span><span class="nb">make</span><span class="p">([]</span><span class="kt">bool</span><span class="p">,</span><span class="nx">n</span><span class="p">)</span>
   <span class="c1">// 我们遍历这些城市
</span><span class="c1"></span>   <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nx">n</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
      <span class="c1">// 选择一个没有访问过得城市，并进行深度优先搜索
</span><span class="c1"></span>      <span class="k">if</span> <span class="p">!</span><span class="nx">visited</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">{</span>
         <span class="c1">// 进行深度优先搜索，我们传入i的位置
</span><span class="c1"></span>         <span class="nf">dfs</span><span class="p">(</span><span class="nx">isConnected</span><span class="p">,</span><span class="nx">i</span><span class="p">,</span><span class="nx">visited</span><span class="p">)</span>
         <span class="c1">// 没有访问过得一定是一个城市
</span><span class="c1"></span>         <span class="nx">count</span><span class="o">++</span>
      <span class="p">}</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="nx">count</span>
<span class="p">}</span>

<span class="c1">// 使用一个辅助函数，这个就是我们的关键部分了
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">dfs</span><span class="p">(</span><span class="nx">area</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">,</span><span class="nx">i</span> <span class="kt">int</span><span class="p">,</span><span class="nx">visited</span> <span class="p">[]</span><span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
   <span class="c1">// 表示当前城市已经被我们访问了
</span><span class="c1"></span>   <span class="nx">visited</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
   <span class="c1">// 我们继续遍历，找到与i城市连接的点
</span><span class="c1"></span>   <span class="k">for</span> <span class="nx">k</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">k</span><span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">area</span><span class="p">);</span><span class="nx">k</span><span class="o">++</span> <span class="p">{</span>
      <span class="c1">// 如果k城市与i城市是连接的那么就为1，同时我们还要确保当前城市没有被访问
</span><span class="c1"></span>      <span class="k">if</span> <span class="nx">area</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">k</span><span class="p">]</span> <span class="o">==</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">visited</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span> <span class="p">{</span>
         <span class="c1">// 这里我们获取与k城市相连的点
</span><span class="c1"></span>         <span class="nf">dfs</span><span class="p">(</span><span class="nx">area</span><span class="p">,</span><span class="nx">k</span><span class="p">,</span><span class="nx">visited</span><span class="p">)</span>
      <span class="p">}</span>
   <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="太平洋大西洋流水问题">太平洋，大西洋流水问题</h3>
<p><a href="https://leetcode-cn.com/problems/pacific-atlantic-water-flow/">417. 太平洋大西洋水流问题 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<p><img src="https://img.xiaoyou66.com/2021/03/24/656dda2393a4b.png" alt="image-20210316171500899"></p>
<p>这个题目其实可以使用逆向的方法来做，我们可以大洋那边出发，水往上流，因为大洋是两条线的，所以我们需计算这两条线上得每一个点所能到达的区域，最后我们就可以得出两个数组（分别代表太平洋和大西洋能流经的位置）如果这两个点都可以满足的话，那么这个点就是我们的答案</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">direction</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">}</span>
<span class="kd">func</span> <span class="nf">pacificAtlantic</span><span class="p">(</span><span class="nx">matrix</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
   <span class="c1">// 先判断题目是否有解
</span><span class="c1"></span>   <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">matrix</span><span class="p">)</span> <span class="o">==</span><span class="mi">0</span> <span class="o">||</span> <span class="nb">len</span><span class="p">(</span><span class="nx">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span><span class="mi">0</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">{}</span>
   <span class="p">}</span>
   <span class="kd">var</span> <span class="nx">ans</span> <span class="p">[][]</span><span class="kt">int</span>
   <span class="c1">// 获取矩阵的大小
</span><span class="c1"></span>   <span class="nx">m</span><span class="p">,</span><span class="nx">n</span><span class="o">:=</span><span class="nb">len</span><span class="p">(</span><span class="nx">matrix</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="nx">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
   <span class="c1">// 因为有两个大洋，我们这里创建两个数组来分别表示两个大洋各自可以到达的位置
</span><span class="c1"></span>   <span class="nx">reachP</span><span class="o">:=</span><span class="nb">make</span><span class="p">([][]</span><span class="kt">bool</span><span class="p">,</span><span class="nx">m</span><span class="p">)</span>
   <span class="nx">reachA</span><span class="o">:=</span><span class="nb">make</span><span class="p">([][]</span><span class="kt">bool</span><span class="p">,</span><span class="nx">m</span><span class="p">)</span>
   <span class="c1">// 因为make只能初始化一维，我们这里还需要遍历来初始二维值
</span><span class="c1"></span>   <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">m</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
      <span class="nx">reachP</span><span class="p">[</span><span class="nx">i</span><span class="p">]=</span><span class="nb">make</span><span class="p">([]</span><span class="kt">bool</span><span class="p">,</span><span class="nx">n</span><span class="p">)</span>
      <span class="nx">reachA</span><span class="p">[</span><span class="nx">i</span><span class="p">]=</span><span class="nb">make</span><span class="p">([]</span><span class="kt">bool</span><span class="p">,</span><span class="nx">n</span><span class="p">)</span>
   <span class="p">}</span>
   <span class="c1">// 下面我们就分别计算两个大洋可以到达的点
</span><span class="c1"></span>
   <span class="c1">// 首先是y轴，也就是一维
</span><span class="c1"></span>   <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">m</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
      <span class="c1">// 这里我们的reachP是左边的线，我们计算这条线上每个点能到达的位置
</span><span class="c1"></span>      <span class="c1">// 这个n-1其实就是右边的线了
</span><span class="c1"></span>      <span class="c1">// 因为我们左边是P右边为A
</span><span class="c1"></span>      <span class="nf">dfs</span><span class="p">(</span><span class="nx">matrix</span><span class="p">,</span><span class="nx">reachP</span><span class="p">,</span><span class="nx">i</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
      <span class="nf">dfs</span><span class="p">(</span><span class="nx">matrix</span><span class="p">,</span><span class="nx">reachA</span><span class="p">,</span><span class="nx">i</span><span class="p">,</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
   <span class="p">}</span>
   <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
      <span class="c1">// 同样我们这里计算上边的线和下边的线能到达的位置
</span><span class="c1"></span>      <span class="nf">dfs</span><span class="p">(</span><span class="nx">matrix</span><span class="p">,</span><span class="nx">reachP</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="nx">i</span><span class="p">)</span>
      <span class="nf">dfs</span><span class="p">(</span><span class="nx">matrix</span><span class="p">,</span><span class="nx">reachA</span><span class="p">,</span><span class="nx">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="nx">i</span><span class="p">)</span>
   <span class="p">}</span>
   <span class="c1">// 最后我们遍历整个数组，来判断那个点P可以到达，A也可以到达
</span><span class="c1"></span>   <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">m</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
      <span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
         <span class="k">if</span> <span class="nx">reachP</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">reachA</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="p">{</span>
            <span class="nx">ans</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">ans</span><span class="p">,[]</span><span class="kt">int</span><span class="p">{</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">})</span>
         <span class="p">}</span>
      <span class="p">}</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="nx">ans</span>
<span class="p">}</span>

<span class="c1">// 辅助函数，用于计算能到达的位置
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">dfs</span><span class="p">(</span><span class="nx">matrix</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">,</span><span class="nx">reach</span> <span class="p">[][]</span><span class="kt">bool</span><span class="p">,</span><span class="nx">r</span> <span class="kt">int</span><span class="p">,</span><span class="nx">c</span> <span class="kt">int</span><span class="p">)</span>  <span class="p">{</span>
   <span class="c1">// 如果已经统计了，我们就直接退出
</span><span class="c1"></span>   <span class="k">if</span> <span class="nx">reach</span><span class="p">[</span><span class="nx">r</span><span class="p">][</span><span class="nx">c</span><span class="p">]</span> <span class="p">{</span>
      <span class="k">return</span>
   <span class="p">}</span>
   <span class="c1">// reach设置为true
</span><span class="c1"></span>   <span class="nx">reach</span><span class="p">[</span><span class="nx">r</span><span class="p">][</span><span class="nx">c</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
   <span class="kd">var</span> <span class="nx">x</span><span class="p">,</span><span class="nx">y</span> <span class="kt">int</span>
   <span class="c1">// 这里我们从四个方向开始遍历
</span><span class="c1"></span>   <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
      <span class="nx">x</span> <span class="p">=</span> <span class="nx">r</span><span class="o">+</span><span class="nx">direction</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
      <span class="nx">y</span><span class="p">=</span> <span class="nx">c</span><span class="o">+</span><span class="nx">direction</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
      <span class="c1">// 只要这上下左右四个方向大于当前点，我们的大洋就可以逆流而上
</span><span class="c1"></span>      <span class="k">if</span> <span class="nx">x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">y</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">x</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">matrix</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">y</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="nx">matrix</span><span class="p">[</span><span class="nx">r</span><span class="p">][</span><span class="nx">c</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="nx">matrix</span><span class="p">[</span><span class="nx">x</span><span class="p">][</span><span class="nx">y</span><span class="p">]</span> <span class="p">{</span>
         <span class="c1">// 可以到达的点再次计算
</span><span class="c1"></span>         <span class="nf">dfs</span><span class="p">(</span><span class="nx">matrix</span><span class="p">,</span><span class="nx">reach</span><span class="p">,</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">)</span>
      <span class="p">}</span>
   <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="回溯法">回溯法</h2>
<p>回溯法（backtracking）是优先搜索的一种特殊情况，又称为试探法，常用于需要记录节点状 态的深度优先搜索。通常来说，<strong>排列、组合、选择类问题使用回溯法比较方便</strong>。 顾名思义，回溯法的<strong>核心是回溯</strong>。在搜索到某一节点的时候，如果我们发现目前的节点（及 其子节点）并不是需求目标时，我们回退到原来的节点继续搜索，并且<strong>把在目前节点修改的状态 还原</strong>。这样的好处是我们可以始终只对图的总状态进行修改，而非每次遍历时新建一个图来储存 状态。在具体的写法上，它与普通的深度优先搜索一样，都有 [修改当前节点状态]→[递归子节 点] 的步骤，只是多了回溯的步骤，变成了 [修改当前节点状态]→[递归子节点]→**[回改当前节点 状态]**。 没有接触过回溯法的读者可能会不明白我在讲什么，这也完全正常，希望以下几道题可以让 您理解回溯法。如果还是不明白，可以记住两个小诀窍，一是按引用传状态，二是所有的状态修改在递归完成后回改。 回溯法修改一般有两种情况，一种是修改最后一位输出，比如排列组合；一种是修改访问标 记，比如矩阵里搜字符串。</p>
<h3 id="全排列">全排列</h3>
<p><img src="https://img.xiaoyou66.com/2021/03/24/c1ee6c268afc3.png" alt="image-20210317095303224"></p>
<p>思路：我们如何输出所有的排列方式呢？对于每一个当前位置i，我们只需要对后面每一位和当前位进行替换，替换完后我们在处理i+1位。</p>
<p>这里回溯体现在 我们进行递归前，先替换，递归完后，我们再换回来，进行下一轮替换</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">permute</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
   <span class="nx">ans</span><span class="o">:=</span><span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
   <span class="c1">// 直接调用辅助函数来获取值即可
</span><span class="c1"></span>   <span class="nf">backtracking</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">&amp;</span><span class="nx">ans</span><span class="p">)</span>
   <span class="k">return</span> <span class="nx">ans</span>
<span class="p">}</span>

<span class="c1">// 注意这里为了能传递值，我们必须使用指针
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">backtracking</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">level</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">ans</span> <span class="o">*</span><span class="p">[][]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
   <span class="c1">// 当我们的level为nums时，就说明已经到最后一位了
</span><span class="c1"></span>   <span class="k">if</span> <span class="nx">level</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
      <span class="c1">// 因为nums是个指针，我们必须使用临时变量拷贝值，要不然会报错
</span><span class="c1"></span>      <span class="nx">tmp</span><span class="o">:=</span><span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">))</span>
      <span class="nb">copy</span><span class="p">(</span><span class="nx">tmp</span><span class="p">,</span><span class="nx">nums</span><span class="p">)</span>
      <span class="c1">// 我们直接把nums添加到结果里就行了
</span><span class="c1"></span>      <span class="o">*</span><span class="nx">ans</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="o">*</span><span class="nx">ans</span><span class="p">,</span> <span class="nx">tmp</span><span class="p">)</span>
      <span class="k">return</span>
   <span class="p">}</span>
   <span class="c1">// 这里就是关键部代码了
</span><span class="c1"></span>   <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">level</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
      <span class="c1">// 这里其实就是i和当前位置换一下值（这个i是不断递增的）
</span><span class="c1"></span>      <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span><span class="nx">nums</span><span class="p">[</span><span class="nx">level</span><span class="p">]</span> <span class="p">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">level</span><span class="p">],</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
      <span class="c1">// 下面这里就是进行替换和判断
</span><span class="c1"></span>      <span class="nf">backtracking</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span><span class="nx">level</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nx">ans</span><span class="p">)</span>
      <span class="c1">// 替换回去，进行下一轮交换
</span><span class="c1"></span>      <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span><span class="nx">nums</span><span class="p">[</span><span class="nx">level</span><span class="p">]</span> <span class="p">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">level</span><span class="p">],</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
   <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="组合">组合</h3>
<p><a href="https://leetcode-cn.com/problems/combinations/">77. 组合 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<p><img src="https://img.xiaoyou66.com/2021/03/24/bf329c029a526.png" alt="image-20210317100751645"></p>
<p>这题目我一开始没思路，后面照着敲了一遍代码后，大概懂了，关键部分就是在于回溯部分，因为我们要计算k个数组合，所以我们可以使用count来表示组合的数的大小。这里拿最简单的两个数字来比较，首先第一个数我们会遍历从1到n（pos表示从哪里开始）。已知第一个数为i的情况下，我们会进行递归计算第二个数，第二个数会从i+1开始遍历到n。获取到数后，我们就把count置为0，继续开始下一个组合计算</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">combine</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">k</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
   <span class="c1">// ans表示结果，comb表示当前的组合，count表示组合的位数
</span><span class="c1"></span>   <span class="nx">ans</span><span class="o">:=</span><span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
   <span class="nx">comb</span><span class="o">:=</span><span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="nx">k</span><span class="p">)</span>
   <span class="nx">count</span><span class="o">:=</span><span class="mi">0</span>
   <span class="c1">// 进行回溯获取结果，题目是从1到n所以我们的pos一开始为1
</span><span class="c1"></span>   <span class="nf">getOrder</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ans</span><span class="p">,</span><span class="nx">comb</span><span class="p">,</span><span class="nx">count</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="nx">n</span><span class="p">,</span><span class="nx">k</span><span class="p">)</span>
   <span class="k">return</span> <span class="nx">ans</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">getOrder</span><span class="p">(</span><span class="nx">ans</span> <span class="o">*</span><span class="p">[][]</span><span class="kt">int</span><span class="p">,</span><span class="nx">comb</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span><span class="nx">count</span> <span class="kt">int</span><span class="p">,</span><span class="nx">pos</span> <span class="kt">int</span><span class="p">,</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span><span class="nx">k</span> <span class="kt">int</span><span class="p">)</span>  <span class="p">{</span>
   <span class="c1">// 当count等于k的时候，我们就可以把答案加到结果里去了
</span><span class="c1"></span>   <span class="k">if</span> <span class="nx">count</span> <span class="o">==</span> <span class="nx">k</span> <span class="p">{</span>
      <span class="nx">tmp</span><span class="o">:=</span><span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="nx">k</span><span class="p">)</span>
      <span class="nb">copy</span><span class="p">(</span><span class="nx">tmp</span><span class="p">,</span><span class="nx">comb</span><span class="p">)</span>
      <span class="o">*</span><span class="nx">ans</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="o">*</span><span class="nx">ans</span><span class="p">,</span><span class="nx">tmp</span><span class="p">)</span>
      <span class="k">return</span>
   <span class="p">}</span>
   <span class="c1">// 因为题目是1到n，所以可以为n，然后我们从pos开始进行计算
</span><span class="c1"></span>   <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="nx">pos</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;=</span><span class="nx">n</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
      <span class="c1">// count表示当前组合的数量,我们把当前的位置放入数组中
</span><span class="c1"></span>      <span class="nx">comb</span><span class="p">[</span><span class="nx">count</span><span class="p">]</span> <span class="p">=</span> <span class="nx">i</span>
      <span class="nx">count</span><span class="o">++</span>
      <span class="c1">// 这里我们进行计算获取ans结果
</span><span class="c1"></span>      <span class="c1">// 这个地方可能难以理解，为什么我们这里可以实现所有组合呢
</span><span class="c1"></span>      <span class="c1">// 就拿最简单的两个来说，第一个位置我们可以取 pos -&gt; n
</span><span class="c1"></span>      <span class="c1">// 第二个位置同样会执行这个递归 这里会取 pos+1 -&gt; n
</span><span class="c1"></span>      <span class="nf">getOrder</span><span class="p">(</span><span class="nx">ans</span><span class="p">,</span><span class="nx">comb</span><span class="p">,</span><span class="nx">count</span><span class="p">,</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nx">n</span><span class="p">,</span><span class="nx">k</span><span class="p">)</span>
      <span class="nx">count</span><span class="o">--</span> <span class="c1">// 回溯，返回上一次状态
</span><span class="c1"></span>   <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="单词搜索待做">单词搜索（待做）</h3>
<p><a href="https://leetcode-cn.com/problems/word-search/">79. 单词搜索 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<p><img src="https://img.xiaoyou66.com/2021/03/24/21861ac08189e.png" alt="image-20210317133022972"></p>
<h3 id="n皇后问题待做">N皇后问题（待做）</h3>
<p><a href="https://leetcode-cn.com/problems/n-queens/">51. N 皇后 - 力扣（LeetCode） (leetcode-cn.com)</a><img src="https://img.xiaoyou66.com/2021/03/24/23ba725062e11.png" alt="image-20210317133546759"></p>
<h2 id="广度优先搜索">广度优先搜索</h2>
<p>广度优先搜索（breadth-first search，BFS）不同与深度优先搜索，它是一层层进行遍历的，因 此需要用先入先出的队列而非先入后出的栈进行遍历。由于是按层次进行遍历，广度优先搜索时 按照“广”的方向进行遍历的，也常常用来处理最短路径等问题。</p>
<p>考虑如下一颗简单的树。我们从 1 号节点开始遍历，假如遍历顺序是从左子节点到右子节点， 那么按照优先向着“广”的方向前进的策略，队列顶端的元素变化过程为 [1]-&gt;[2-&gt;3]-&gt;[4]，其中 方括号代表每一层的元素。</p>
<p><img src="https://img.xiaoyou66.com/2021/03/24/ca37f91fc2ec5.png" alt="image-20210317133711658"></p>
<p>这里要注意，深度优先搜索和广度优先搜索都可以处理可达性问题，即从一个节点开始是否 能达到另一个节点。因为深度优先搜索可以利用递归快速实现，很多人会习惯使用深度优先搜索 刷此类题目。实际软件工程中，笔者很少见到递归的写法，因为一方面难以理解，另一方面可能 产生栈溢出的情况；而用栈实现的深度优先搜索和用队列实现的广度优先搜索在写法上并没有太 大差异，因此使用哪一种搜索方式需要根据实际的功能需求来判断。</p>
<h3 id="最短的桥待做">最短的桥（待做）</h3>
<p><a href="https://leetcode-cn.com/problems/shortest-bridge/">934. 最短的桥 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<p><img src="https://img.xiaoyou66.com/2021/03/24/c281aaa777c4c.png" alt="image-20210317133844113"></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">LYR</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2021-03-24
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags//"></a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/06.%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/04.cmu%E7%A1%95%E5%A3%AB%E7%BB%8F%E5%85%B8100%E9%A2%98/04.%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">各种排序</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/06.%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/04.cmu%E7%A1%95%E5%A3%AB%E7%BB%8F%E5%85%B8100%E9%A2%98/01.%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/">
            <span class="next-text nav-default">贪心算法</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>

  
  
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:lyr-2000@qq.com" class="iconfont icon-email" title="email"></a>
  <a href="" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span>lyr</span>
  </span>
</div>



<script 
 
    src="https://cdn.jsdelivr.net/gh/lyr-2000/live2d-widget@latest/autoload.js"></script>



    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c12618f9a600c40bd024996677e951e64d3487006775aeb22e200c990006c5c7.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>






<script src="/js//custom/latex_plugin.js"></script>
<script src="/js/custom/docsearch.min.js" ></script>
<script>
 
  docsearch({
    apiKey: "2991187e127fb95e62db841ea946bc06",
    indexName: "blog",
    appId: "UVGAU2QDTQ",
    inputSelector: '.docsearch-input',
    debug: false,
  });
  docsearch({
    apiKey: "2991187e127fb95e62db841ea946bc06",
    indexName: "blog",
    appId: "UVGAU2QDTQ",
    inputSelector: '.mob-docsearch-input',
    debug: false,
  });
 
</script>

  <script src="/custom/post/back_btn.js"></script>
</body>
</html>
