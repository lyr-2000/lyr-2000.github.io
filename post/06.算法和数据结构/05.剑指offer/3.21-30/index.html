<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>21-30 - 凌冬的个人博客</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="LYR" /><meta name="description" content="21.调整数组顺序使奇数位于偶数前面 剑指 Offer 21. 调整数组顺序使奇数位于偶数前面 - 力扣（LeetCode） (leetcode-cn.com) 哈哈，居然做出来了，这题其实最简单的方" /><meta name="keywords" content="凌冬的博客, LYR的个人博客, even" />






<meta name="generator" content="Hugo 0.74.2 with theme even" />


<link rel="canonical" href="https://lyr-2000.github.io/post/06.%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/05.%E5%89%91%E6%8C%87offer/3.21-30/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.b5a744db6de49a86cadafb3b70f555ab443f83c307a483402259e94726b045ff.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="21-30" />
<meta property="og:description" content="21.调整数组顺序使奇数位于偶数前面 剑指 Offer 21. 调整数组顺序使奇数位于偶数前面 - 力扣（LeetCode） (leetcode-cn.com) 哈哈，居然做出来了，这题其实最简单的方" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://lyr-2000.github.io/post/06.%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/05.%E5%89%91%E6%8C%87offer/3.21-30/" />
<meta property="article:published_time" content="2021-03-29T08:56:23+00:00" />
<meta property="article:modified_time" content="2021-03-29T08:56:23+00:00" />
<meta itemprop="name" content="21-30">
<meta itemprop="description" content="21.调整数组顺序使奇数位于偶数前面 剑指 Offer 21. 调整数组顺序使奇数位于偶数前面 - 力扣（LeetCode） (leetcode-cn.com) 哈哈，居然做出来了，这题其实最简单的方">
<meta itemprop="datePublished" content="2021-03-29T08:56:23&#43;00:00" />
<meta itemprop="dateModified" content="2021-03-29T08:56:23&#43;00:00" />
<meta itemprop="wordCount" content="2584">



<meta itemprop="keywords" content="," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="21-30"/>
<meta name="twitter:description" content="21.调整数组顺序使奇数位于偶数前面 剑指 Offer 21. 调整数组顺序使奇数位于偶数前面 - 力扣（LeetCode） (leetcode-cn.com) 哈哈，居然做出来了，这题其实最简单的方"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">凌冬的博客</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><li style="display:inline-block;margin-right:10px;">
			<input type="search" class="mob-docsearch-input" placeholder="Search" />
		</li><a href="/">
        <li class="mobile-menu-item">首页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档页</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a><a href="/friends">
        <li class="mobile-menu-item">大佬</li>
      </a>
	
	
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">凌冬的博客</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">首页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/friends">大佬</a>
      </li><li style="menu-item;list-style: none;position: relative;left: 360px;bottom: 32px;">
		<input type="search" class="docsearch-input PC_MARK1" placeholder="Search" />
	  </li></ul>
</nav>


<style>
  .mob-docsearch-input {
	border: 1px solid #ccc;
	padding: 6px 0px;
	border-radius: 3px;
	padding-left:5px;
	position: relative;
    vertical-align: top;
    width: 93%;
    margin: auto;
    margin-left: 7px;
  
  }
  input.PC_MARK1{
	border: 1px solid #ccc;
	padding: 6px 0px;
	border-radius: 3px;
	padding-left:5px;
	-webkit-box-shadow: inset 0 1px 1px rgba(0,0,0,.075);
	box-shadow: inset 0 1px 1px rgba(0,0,0,.075);
	-webkit-transition: border-color ease-in-out .15s,-webkit-box-shadow ease-in-out .15s;
	-o-transition: border-color ease-in-out .15s,box-shadow ease-in-out .15s;
	transition: border-color ease-in-out .15s,box-shadow ease-in-out .15s
}
input.PC_MARK1:focus{
		border-color: #66afe9;
		outline: 0;
		-webkit-box-shadow: inset 0 1px 1px rgba(0,0,0,.075),0 0 8px rgba(102,175,233,.6);
		box-shadow: inset 0 1px 1px rgba(0,0,0,.075),0 0 8px rgba(102,175,233,.6)
}
</style>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">21-30</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-03-29 </span>
        <div class="post-category">
            <a href="/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"> 算法和数据结构 </a>
            <a href="/categories/%E5%89%91%E6%8C%87offer/"> 剑指offer </a>
            </div>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#21调整数组顺序使奇数位于偶数前面">21.调整数组顺序使奇数位于偶数前面</a>
          <ul>
            <li><a href="#解法一-双指针">解法一： 双指针</a></li>
            <li><a href="#解法二快慢指针">解法二：快慢指针</a></li>
          </ul>
        </li>
        <li><a href="#22链表中倒数第k个节点">22.链表中倒数第K个节点</a>
          <ul>
            <li><a href="#解法一-两次循环">解法一： 两次循环</a></li>
            <li><a href="#解法二-快慢指针">解法二： 快慢指针</a></li>
          </ul>
        </li>
        <li><a href="#24反转链表">24.反转链表</a>
          <ul>
            <li><a href="#解法一递归法">解法一：递归法</a></li>
            <li><a href="#解法二双指针">解法二：双指针</a></li>
          </ul>
        </li>
        <li><a href="#25合并两个排序链表">25.合并两个排序链表</a>
          <ul>
            <li><a href="#解法一-头指针">解法一： 头指针</a></li>
            <li><a href="#解法二-使用递归">解法二： 使用递归</a></li>
          </ul>
        </li>
        <li><a href="#26树的子结构">26.树的子结构</a>
          <ul>
            <li><a href="#方法一-使用递归">方法一： 使用递归</a></li>
          </ul>
        </li>
        <li><a href="#27二叉树的镜像">27.二叉树的镜像</a>
          <ul>
            <li><a href="#解法一-使用递归">解法一： 使用递归</a></li>
            <li><a href="#解法二-辅助栈">解法二： 辅助栈</a></li>
          </ul>
        </li>
        <li><a href="#28对称二叉树">28.对称二叉树</a>
          <ul>
            <li><a href="#方法一-递归法">方法一： 递归法</a></li>
          </ul>
        </li>
        <li><a href="#29顺时针打印矩阵">29.顺时针打印矩阵</a>
          <ul>
            <li><a href="#解法一-模拟法">解法一 模拟法</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="21调整数组顺序使奇数位于偶数前面">21.调整数组顺序使奇数位于偶数前面</h2>
<p><a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">剑指 Offer 21. 调整数组顺序使奇数位于偶数前面 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<p><img src="https://img.xiaoyou66.com/2021/04/05/71262de1aadeb.png" alt="image-20210405091909752"></p>
<p>哈哈，居然做出来了，这题其实最简单的方法就是使用双指针进行替换</p>
<h3 id="解法一-双指针">解法一： 双指针</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">exchange</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="nx">low</span><span class="p">,</span><span class="nx">high</span><span class="o">:=</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
	<span class="k">for</span> <span class="nx">low</span> <span class="p">&lt;</span> <span class="nx">high</span> <span class="p">{</span>
		<span class="c1">// 首先我们找到一个偶数
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">high</span><span class="p">&gt;</span><span class="nx">low</span> <span class="o">&amp;&amp;</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">high</span><span class="p">]</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">high</span><span class="o">--</span>
		<span class="p">}</span>
		<span class="c1">// 然后找到一个奇数
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">high</span><span class="p">&gt;</span><span class="nx">low</span> <span class="o">&amp;&amp;</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">low</span><span class="p">]</span><span class="o">%</span><span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">low</span><span class="o">++</span>
		<span class="p">}</span>
		<span class="c1">// 然后我们进行替换
</span><span class="c1"></span>		<span class="nx">nums</span><span class="p">[</span><span class="nx">low</span><span class="p">],</span><span class="nx">nums</span><span class="p">[</span><span class="nx">high</span><span class="p">]=</span><span class="nx">nums</span><span class="p">[</span><span class="nx">high</span><span class="p">],</span><span class="nx">nums</span><span class="p">[</span><span class="nx">low</span><span class="p">]</span>
		<span class="c1">// 指针移动
</span><span class="c1"></span>		<span class="nx">low</span><span class="o">++</span>
		<span class="nx">high</span><span class="o">--</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">nums</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="解法二快慢指针">解法二：快慢指针</h3>
<p>这个其实和双指针差不多，只不过这里我们直接只遍历一次，我们的块指针每次都指向奇数慢指针指向偶数，然后我们进行交换</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">exchange</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
   <span class="c1">// 定义快慢两个指针
</span><span class="c1"></span>   <span class="nx">slow</span><span class="p">,</span><span class="nx">fast</span><span class="o">:=</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span>
   <span class="c1">// 遍历直到fast遍历到数组尾巴为止
</span><span class="c1"></span>   <span class="k">for</span> <span class="nx">fast</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 当我们发送fast为奇数时，我们交换一下内容
</span><span class="c1"></span>      <span class="k">if</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">fast</span><span class="p">]</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">&gt;</span><span class="mi">0</span> <span class="p">{</span>
         <span class="c1">// 因为slow是偶数（fast只会交换奇数，交换后的就是偶数了）
</span><span class="c1"></span>         <span class="nx">nums</span><span class="p">[</span><span class="nx">fast</span><span class="p">],</span><span class="nx">nums</span><span class="p">[</span><span class="nx">slow</span><span class="p">]</span> <span class="p">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">slow</span><span class="p">],</span><span class="nx">nums</span><span class="p">[</span><span class="nx">fast</span><span class="p">]</span>
         <span class="nx">slow</span><span class="o">++</span>
      <span class="p">}</span>
      <span class="c1">// 移动快指针
</span><span class="c1"></span>      <span class="nx">fast</span><span class="o">++</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="nx">nums</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="22链表中倒数第k个节点">22.链表中倒数第K个节点</h2>
<p><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指 Offer 22. 链表中倒数第k个节点 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<p><img src="https://img.xiaoyou66.com/2021/04/05/3259e50475fcc.png" alt="image-20210405103435899"></p>
<h3 id="解法一-两次循环">解法一： 两次循环</h3>
<p>第一次循环，我们获取一下链表长度，第二次循环我们找到倒数第k个节点</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">getKthFromEnd</span><span class="p">(</span><span class="nx">head</span> <span class="o">*</span><span class="nx">ListNode</span><span class="p">,</span> <span class="nx">k</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">ListNode</span> <span class="p">{</span>
   <span class="nx">root</span><span class="o">:=</span><span class="nx">head</span>
   <span class="c1">// n表示链表长度
</span><span class="c1"></span>   <span class="nx">n</span><span class="o">:=</span><span class="mi">0</span>
   <span class="c1">// 第一遍for循环，判断链表长度
</span><span class="c1"></span>   <span class="k">for</span> <span class="nx">head</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="nx">n</span><span class="o">++</span>
      <span class="nx">head</span><span class="p">=</span><span class="nx">head</span><span class="p">.</span><span class="nx">Next</span>
   <span class="p">}</span>
   <span class="c1">// 第二遍，返回倒数倒数第k个节点
</span><span class="c1"></span>   <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="o">-</span><span class="nx">k</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
      <span class="nx">root</span> <span class="p">=</span> <span class="nx">root</span><span class="p">.</span><span class="nx">Next</span>
   <span class="p">}</span>
   <span class="c1">// 返回节点
</span><span class="c1"></span>   <span class="k">return</span> <span class="nx">root</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="解法二-快慢指针">解法二： 快慢指针</h3>
<p>这里原理也很好理解，我们先让快指针移动，慢指针先不动，只有当我们的慢指针和快指针相差k的时候，我们的慢指针就和快指针同步移动</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">getKthFromEnd</span><span class="p">(</span><span class="nx">head</span> <span class="o">*</span><span class="nx">ListNode</span><span class="p">,</span> <span class="nx">k</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">ListNode</span> <span class="p">{</span>
   <span class="c1">// 定义快慢两个节点
</span><span class="c1"></span>   <span class="nx">slow</span><span class="p">,</span><span class="nx">fast</span><span class="o">:=</span><span class="nx">head</span><span class="p">,</span><span class="nx">head</span>
   <span class="nx">t</span><span class="o">:=</span><span class="mi">0</span>
   <span class="k">for</span> <span class="nx">fast</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="c1">// 只有当t&gt;=k的时候我们才移动慢指针，因为我们的t相当于快指针，我们的慢指针要比快指针要小于k
</span><span class="c1"></span>      <span class="k">if</span> <span class="nx">t</span> <span class="o">&gt;=</span> <span class="nx">k</span> <span class="p">{</span>
         <span class="nx">slow</span><span class="p">=</span><span class="nx">slow</span><span class="p">.</span><span class="nx">Next</span>
      <span class="p">}</span>
      <span class="c1">// 移动快指针
</span><span class="c1"></span>      <span class="nx">fast</span> <span class="p">=</span> <span class="nx">fast</span><span class="p">.</span><span class="nx">Next</span>
      <span class="nx">t</span><span class="o">++</span>
   <span class="p">}</span>
   <span class="c1">// 判断越界问题
</span><span class="c1"></span>   <span class="k">if</span> <span class="nx">t</span> <span class="p">&lt;</span> <span class="nx">k</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">nil</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="nx">slow</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="24反转链表">24.反转链表</h2>
<p><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">剑指 Offer 24. 反转链表 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<p><img src="https://img.xiaoyou66.com/2021/04/05/aa52159e94968.png" alt="image-20210405112452004"></p>
<h3 id="解法一递归法">解法一：递归法</h3>
<p>这里其实就是直接使用递归到达尾结点，然后我们修改一下结点的顺序，从而达到反转的目的</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">reverseList</span><span class="p">(</span><span class="nx">head</span> <span class="o">*</span><span class="nx">ListNode</span><span class="p">)</span> <span class="o">*</span><span class="nx">ListNode</span> <span class="p">{</span>
   <span class="c1">// 当我们的head为空的时候我们停止循环,这个时候返回我们的头节点（其实就是返回尾结点）
</span><span class="c1"></span>   <span class="k">if</span> <span class="nx">head</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">head</span><span class="p">.</span><span class="nx">Next</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">head</span>
   <span class="p">}</span>
   <span class="c1">// 开始递归获取尾结点
</span><span class="c1"></span>   <span class="nx">node</span><span class="o">:=</span><span class="nf">reverseList</span><span class="p">(</span><span class="nx">head</span><span class="p">.</span><span class="nx">Next</span><span class="p">)</span>
   <span class="c1">// 此时我们修改一下指向的顺序
</span><span class="c1"></span>   <span class="c1">// 即当前指针的下一个指针的下一个指针指向当前指针
</span><span class="c1"></span>   <span class="nx">head</span><span class="p">.</span><span class="nx">Next</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="nx">head</span>
   <span class="c1">// 此时头节点相当于尾结点了，我们需要置为nil
</span><span class="c1"></span>   <span class="nx">head</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="kc">nil</span>
   <span class="k">return</span> <span class="nx">node</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="解法二双指针">解法二：双指针</h3>
<p>这个解法我想出来了，比较简单，自己可以画一个草稿来简单演示即可</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">reverseList</span><span class="p">(</span><span class="nx">head</span> <span class="o">*</span><span class="nx">ListNode</span><span class="p">)</span> <span class="o">*</span><span class="nx">ListNode</span> <span class="p">{</span>
   <span class="c1">// 表示前一个指针
</span><span class="c1"></span>   <span class="kd">var</span> <span class="nx">prev</span> <span class="o">*</span><span class="nx">ListNode</span>
   <span class="c1">// curr表示当前指针
</span><span class="c1"></span>   <span class="nx">curr</span> <span class="o">:=</span> <span class="nx">head</span>
   <span class="k">for</span> <span class="nx">curr</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="c1">// 先记录下一个指针
</span><span class="c1"></span>      <span class="nx">next</span> <span class="o">:=</span> <span class="nx">curr</span><span class="p">.</span><span class="nx">Next</span>
      <span class="c1">// 反转一下位置
</span><span class="c1"></span>      <span class="nx">curr</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="nx">prev</span>
      <span class="c1">// 移动一下指针
</span><span class="c1"></span>      <span class="nx">prev</span> <span class="p">=</span> <span class="nx">curr</span>
      <span class="nx">curr</span> <span class="p">=</span> <span class="nx">next</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="nx">prev</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="25合并两个排序链表">25.合并两个排序链表</h2>
<p><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">剑指 Offer 25. 合并两个排序的链表 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<p><img src="https://img.xiaoyou66.com/2021/04/05/fbe5597eb794f.png" alt="image-20210405135720542"></p>
<h3 id="解法一-头指针">解法一： 头指针</h3>
<p>我们定义一个头指针，然后每次比较大小并把新值接到链表中</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">mergeTwoLists1</span><span class="p">(</span><span class="nx">l1</span> <span class="o">*</span><span class="nx">ListNode</span><span class="p">,</span> <span class="nx">l2</span> <span class="o">*</span><span class="nx">ListNode</span><span class="p">)</span> <span class="o">*</span><span class="nx">ListNode</span> <span class="p">{</span>
   <span class="nx">res</span><span class="o">:=&amp;</span><span class="nx">ListNode</span><span class="p">{}</span>
   <span class="nx">cur</span><span class="o">:=</span><span class="nx">res</span>
   <span class="k">for</span> <span class="nx">l1</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">l2</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="c1">// 比较判断
</span><span class="c1"></span>      <span class="k">if</span> <span class="nx">l1</span><span class="p">.</span><span class="nx">Val</span> <span class="p">&lt;</span> <span class="nx">l2</span><span class="p">.</span><span class="nx">Val</span> <span class="p">{</span>
         <span class="nx">cur</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="nx">l1</span>
         <span class="nx">l1</span><span class="p">=</span><span class="nx">l1</span><span class="p">.</span><span class="nx">Next</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
         <span class="nx">cur</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="nx">l2</span>
         <span class="nx">l2</span><span class="p">=</span><span class="nx">l2</span><span class="p">.</span><span class="nx">Next</span>
      <span class="p">}</span>
      <span class="nx">cur</span> <span class="p">=</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">Next</span>
   <span class="p">}</span>
   <span class="c1">// 判断两个节点是否为空
</span><span class="c1"></span>   <span class="k">if</span> <span class="nx">l1</span><span class="o">!=</span><span class="kc">nil</span> <span class="p">{</span>
      <span class="nx">cur</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="nx">l1</span>
   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">cur</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="nx">l2</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="nx">res</span><span class="p">.</span><span class="nx">Next</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="解法二-使用递归">解法二： 使用递归</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">mergeTwoLists</span><span class="p">(</span><span class="nx">l1</span> <span class="o">*</span><span class="nx">ListNode</span><span class="p">,</span> <span class="nx">l2</span> <span class="o">*</span><span class="nx">ListNode</span><span class="p">)</span> <span class="o">*</span><span class="nx">ListNode</span><span class="p">{</span>
   <span class="c1">// 如果一个节点为空的情况下，我们返回另外一个非空节点
</span><span class="c1"></span>   <span class="k">if</span> <span class="nx">l1</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">l2</span> <span class="p">}</span>
   <span class="k">if</span> <span class="nx">l2</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">l1</span> <span class="p">}</span>
   <span class="k">if</span> <span class="nx">l1</span><span class="p">.</span><span class="nx">Val</span> <span class="p">&lt;</span> <span class="nx">l2</span><span class="p">.</span><span class="nx">Val</span> <span class="p">{</span>
      <span class="nx">l1</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="nf">mergeTwoLists</span><span class="p">(</span><span class="nx">l1</span><span class="p">.</span><span class="nx">Next</span><span class="p">,</span><span class="nx">l2</span><span class="p">)</span>
      <span class="k">return</span> <span class="nx">l1</span>
   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">l2</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="nf">mergeTwoLists</span><span class="p">(</span><span class="nx">l1</span><span class="p">,</span><span class="nx">l2</span><span class="p">.</span><span class="nx">Next</span><span class="p">)</span>
      <span class="k">return</span> <span class="nx">l2</span>
   <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="26树的子结构">26.树的子结构</h2>
<p><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">剑指 Offer 26. 树的子结构 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<p><img src="https://img.xiaoyou66.com/2021/04/05/1e0e6c6af00a1.png" alt="image-20210405161531994"></p>
<h3 id="方法一-使用递归">方法一： 使用递归</h3>
<p>这题关键的地方就在于如何判断两颗子树是否相等，我们这里最简单粗暴的方法就是遍历所有A子树的节点，然后依次和B进行比较</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">isSubStructure</span><span class="p">(</span><span class="nx">A</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">,</span> <span class="nx">B</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
   <span class="c1">// 这里我们先判断两个节点是否都不为空
</span><span class="c1"></span>   <span class="c1">// 如果不为空的话，我们尝试判断AB这两颗树是否一样
</span><span class="c1"></span>   <span class="c1">// 如果不一样我们再判断A的左子树或者A的右子树和B是否一样
</span><span class="c1"></span>   <span class="k">return</span> <span class="p">(</span><span class="nx">A</span><span class="o">!=</span><span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">B</span><span class="o">!=</span> <span class="kc">nil</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nf">isSame</span><span class="p">(</span><span class="nx">A</span><span class="p">,</span><span class="nx">B</span><span class="p">)</span> <span class="o">||</span> <span class="nf">isSubStructure</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">Left</span><span class="p">,</span><span class="nx">B</span><span class="p">)</span> <span class="o">||</span> <span class="nf">isSubStructure</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">Right</span><span class="p">,</span><span class="nx">B</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// 判断两颗树是否相等
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">isSame</span><span class="p">(</span><span class="nx">A</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">,</span> <span class="nx">B</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="kt">bool</span><span class="p">{</span>
   <span class="c1">// 当B为空时，此时我们就返回true(因为已经比较完毕了)
</span><span class="c1"></span>   <span class="k">if</span> <span class="nx">B</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">true</span> <span class="p">}</span>
   <span class="c1">// 如果A节点为空，B节点不为空
</span><span class="c1"></span>   <span class="c1">// 或者A B两个节点的值不相等，我们就返回false
</span><span class="c1"></span>   <span class="k">if</span> <span class="nx">A</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">A</span><span class="p">.</span><span class="nx">Val</span> <span class="o">!=</span> <span class="nx">B</span><span class="p">.</span><span class="nx">Val</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">false</span>
   <span class="p">}</span>
   <span class="c1">// 然后我们分别判断左右子树，确保左右子树也符合条件
</span><span class="c1"></span>   <span class="k">return</span> <span class="nf">isSubStructure</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">Left</span><span class="p">,</span><span class="nx">B</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nf">isSubStructure</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">Right</span><span class="p">,</span><span class="nx">B</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="27二叉树的镜像">27.二叉树的镜像</h2>
<p><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">剑指 Offer 27. 二叉树的镜像 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<p><img src="https://img.xiaoyou66.com/2021/04/05/eb20859e433ba.png" alt="image-20210405164425395"></p>
<p>这题我居然做出来了哈哈哈哈哈！害，我这渣渣也只能做做简单题了</p>
<h3 id="解法一-使用递归">解法一： 使用递归</h3>
<p>递归的思路很简单，其实就是我们在遍历的时候，分别交换一下树左右节点就行了</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">mirrorTree</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="o">*</span><span class="nx">TreeNode</span> <span class="p">{</span>
   <span class="c1">// 如果节点为空，那么我们就返回空值
</span><span class="c1"></span>   <span class="k">if</span> <span class="nx">root</span><span class="o">==</span><span class="kc">nil</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">root</span> <span class="p">}</span>
   <span class="c1">// 遍历左右节点
</span><span class="c1"></span>   <span class="nx">right</span> <span class="o">:=</span> <span class="nf">mirrorTree</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
   <span class="nx">left</span> <span class="o">:=</span> <span class="nf">mirrorTree</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
   <span class="c1">// 交换在左右节点
</span><span class="c1"></span>   <span class="nx">root</span><span class="p">.</span><span class="nx">Left</span> <span class="p">=</span> <span class="nx">right</span>
   <span class="nx">root</span><span class="p">.</span><span class="nx">Right</span> <span class="p">=</span> <span class="nx">left</span>
   <span class="k">return</span> <span class="nx">root</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="解法二-辅助栈">解法二： 辅助栈</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">mirrorTree</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="o">*</span><span class="nx">TreeNode</span> <span class="p">{</span>
	<span class="c1">// 如果根节点为空，那么我们就返回空
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">root</span><span class="o">==</span><span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="c1">// 初始化一个栈
</span><span class="c1"></span>	<span class="nx">stack</span><span class="o">:=</span><span class="nx">list</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
	<span class="c1">// 元素入栈操作
</span><span class="c1"></span>	<span class="nx">stack</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="nx">root</span><span class="p">)</span>
	<span class="c1">// 当我们栈为空时表示我们替换结束
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">stack</span><span class="p">.</span><span class="nf">Len</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// 元素出栈
</span><span class="c1"></span>		<span class="nx">node</span><span class="o">:=</span><span class="nx">stack</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">stack</span><span class="p">.</span><span class="nf">Back</span><span class="p">()).(</span><span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span>
		<span class="c1">// 然后我们判断左右子树是否为空
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Left</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">stack</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Right</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">stack</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c1">// 交换一下元素
</span><span class="c1"></span>		<span class="nx">tmp</span><span class="o">:=</span><span class="nx">node</span><span class="p">.</span><span class="nx">Left</span>
		<span class="nx">node</span><span class="p">.</span><span class="nx">Left</span> <span class="p">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Right</span>
		<span class="nx">node</span><span class="p">.</span><span class="nx">Right</span> <span class="p">=</span> <span class="nx">tmp</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">root</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="28对称二叉树">28.对称二叉树</h2>
<p><a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/">剑指 Offer 28. 对称的二叉树 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<p><img src="https://img.xiaoyou66.com/2021/04/05/80736253ee20d.png" alt="image-20210405193253350"></p>
<p>这题emm，我看了上一题以为是先求镜像树，然后再用镜像树和当前树对比。。看了大佬的题解后不禁感慨，果然是我太菜了。。。。</p>
<h3 id="方法一-递归法">方法一： 递归法</h3>
<p>不得不说，大佬的思路就是牛逼，这里我们通过一个辅助函数就非常简单的把这些东西给判断出来了</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">isSymmetric</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
   <span class="k">if</span> <span class="nx">root</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">true</span>
   <span class="p">}</span>
   <span class="c1">// 判断左右两边是否对称
</span><span class="c1"></span>   <span class="k">return</span> <span class="nf">recur</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Right</span><span class="p">,</span><span class="nx">root</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">recur</span><span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">,</span><span class="nx">r</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
   <span class="c1">// 当左右两边都为空的时候我们返回 true
</span><span class="c1"></span>   <span class="k">if</span> <span class="nx">l</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">r</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">true</span> <span class="p">}</span>
   <span class="c1">// 当两个节点不相同或者有一个节点为空时，我们退出循环
</span><span class="c1"></span>   <span class="k">if</span> <span class="nx">l</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">r</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">l</span><span class="p">.</span><span class="nx">Val</span> <span class="o">!=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Val</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">false</span> <span class="p">}</span>
   <span class="c1">// 这里我们简单的判断两端是否对称
</span><span class="c1"></span>   <span class="k">return</span> <span class="nf">recur</span><span class="p">(</span><span class="nx">l</span><span class="p">.</span><span class="nx">Left</span><span class="p">,</span><span class="nx">r</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nf">recur</span><span class="p">(</span><span class="nx">l</span><span class="p">.</span><span class="nx">Right</span><span class="p">,</span><span class="nx">r</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="29顺时针打印矩阵">29.顺时针打印矩阵</h2>
<p><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">剑指 Offer 29. 顺时针打印矩阵 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<p><img src="https://img.xiaoyou66.com/2021/04/05/5a523dd871fa3.png" alt="image-20210405200909500"></p>
<p>这题看到简单我以为我可以了，没想到一做就被打回原形了。。。。我是菜鸡。。。</p>
<h3 id="解法一-模拟法">解法一 模拟法</h3>
<p>说实话，这题其实不算很难，但是这种题目很恶心，需要确定好边界条件，要不然很容易出错</p>
<p><img src="https://img.xiaoyou66.com/2021/04/06/e6a448c2fdba5.gif" alt="test"></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">spiralOrder</span><span class="p">(</span><span class="nx">matrix</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
   <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">matrix</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{}</span>
   <span class="p">}</span>
   <span class="c1">// 初始化上下左右
</span><span class="c1"></span>   <span class="nx">t</span><span class="p">,</span><span class="nx">b</span><span class="p">,</span><span class="nx">l</span><span class="p">,</span><span class="nx">r</span><span class="o">:=</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="nx">matrix</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="nx">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span>
   <span class="c1">// 初始化结果数组
</span><span class="c1"></span>   <span class="nx">res</span><span class="o">:=</span><span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,(</span><span class="nx">r</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="nx">b</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
   <span class="nx">x</span> <span class="o">:=</span><span class="mi">0</span>
   <span class="c1">// 开始进行遍历
</span><span class="c1"></span>   <span class="k">for</span>  <span class="p">{</span>
      <span class="c1">// 从左到右
</span><span class="c1"></span>      <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="nx">l</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;=</span><span class="nx">r</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span> <span class="p">{</span> <span class="nx">res</span><span class="p">[</span><span class="nx">x</span><span class="p">]</span> <span class="p">=</span> <span class="nx">matrix</span><span class="p">[</span><span class="nx">t</span><span class="p">][</span><span class="nx">i</span><span class="p">];</span><span class="nx">x</span><span class="o">++</span> <span class="p">}</span>
      <span class="k">if</span> <span class="nx">t</span><span class="o">++</span><span class="p">;</span> <span class="nx">t</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span> <span class="k">break</span> <span class="p">}</span>
      <span class="c1">// 从上到下
</span><span class="c1"></span>      <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="nx">t</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;=</span><span class="nx">b</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span> <span class="p">{</span> <span class="nx">res</span><span class="p">[</span><span class="nx">x</span><span class="p">]</span> <span class="p">=</span> <span class="nx">matrix</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">r</span><span class="p">];</span><span class="nx">x</span><span class="o">++</span> <span class="p">}</span>
      <span class="k">if</span> <span class="nx">r</span><span class="o">--</span><span class="p">;</span> <span class="nx">l</span> <span class="p">&gt;</span> <span class="nx">r</span> <span class="p">{</span> <span class="k">break</span> <span class="p">}</span>
      <span class="c1">// 从右到左
</span><span class="c1"></span>      <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="nx">r</span><span class="p">;</span><span class="nx">i</span><span class="o">&gt;=</span><span class="nx">l</span><span class="p">;</span><span class="nx">i</span><span class="o">--</span> <span class="p">{</span> <span class="nx">res</span><span class="p">[</span><span class="nx">x</span><span class="p">]</span> <span class="p">=</span> <span class="nx">matrix</span><span class="p">[</span><span class="nx">b</span><span class="p">][</span><span class="nx">i</span><span class="p">];</span><span class="nx">x</span><span class="o">++</span> <span class="p">}</span>
      <span class="k">if</span> <span class="nx">b</span><span class="o">--</span><span class="p">;</span> <span class="nx">t</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span> <span class="k">break</span> <span class="p">}</span>
      <span class="c1">// 从下到上
</span><span class="c1"></span>      <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="nx">b</span><span class="p">;</span><span class="nx">i</span><span class="o">&gt;=</span><span class="nx">t</span><span class="p">;</span><span class="nx">i</span><span class="o">--</span> <span class="p">{</span> <span class="nx">res</span><span class="p">[</span><span class="nx">x</span><span class="p">]</span> <span class="p">=</span> <span class="nx">matrix</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">l</span><span class="p">];</span><span class="nx">x</span><span class="o">++</span> <span class="p">}</span>
      <span class="k">if</span> <span class="nx">l</span><span class="o">++</span><span class="p">;</span> <span class="nx">l</span> <span class="p">&gt;</span> <span class="nx">r</span> <span class="p">{</span> <span class="k">break</span> <span class="p">}</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div>
    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">LYR</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2021-03-29
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags//"></a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/06.%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/05.%E5%89%91%E6%8C%87offer/2.11-20/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">11-20</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/06.%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/05.%E5%89%91%E6%8C%87offer/1.3-10/">
            <span class="next-text nav-default">3-10</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:lyr-2000@qq.com" class="iconfont icon-email" title="email"></a>
  <a href="" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span>lyr</span>
  </span>
</div>


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css">

<script 
 defer
 async  src="https://cdn.jsdelivr.net/gh/lyr-2000/live2d-widget@latest/autoload.js"></script>



    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c12618f9a600c40bd024996677e951e64d3487006775aeb22e200c990006c5c7.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>






<script src="/js//custom/latex_plugin.js"></script>
<script src="/js/custom/docsearch.min.js" ></script>
<script>
document.addEventListener('load',function(){
  docsearch({
    apiKey: "2991187e127fb95e62db841ea946bc06",
    indexName: "blog",
    appId: "UVGAU2QDTQ",
    inputSelector: '.docsearch-input',
    debug: false,
  });
  docsearch({
    apiKey: "2991187e127fb95e62db841ea946bc06",
    indexName: "blog",
    appId: "UVGAU2QDTQ",
    inputSelector: '.mob-docsearch-input',
    debug: false,
  });
});
</script>
</body>
</html>
