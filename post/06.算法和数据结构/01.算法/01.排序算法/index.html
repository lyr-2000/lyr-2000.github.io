<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>排序算法 - 凌冬的个人博客</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="LYR" /><meta name="description" content="插入排序 直接插入排序 插入排序是最简单的，我们不断比较插入数据 // 插入排序 // 时间复杂度 n^2 // 因为我们这里是两层for循环，运气好的话，如果是有序的" /><meta name="keywords" content="凌冬的博客, LYR的个人博客, 二次元技术宅" />






<meta name="generator" content="Hugo 0.74.2 with theme even" />


<link rel="canonical" href="https://lyr-2000.github.io/post/06.%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01.%E7%AE%97%E6%B3%95/01.%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<link href="/sass/main.min.4d31fe93a248bf2a033aec98b3dca0e0e3f55453ad76230e57f190d60450d008.css" rel="stylesheet"> 

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="排序算法" />
<meta property="og:description" content="插入排序 直接插入排序 插入排序是最简单的，我们不断比较插入数据 // 插入排序 // 时间复杂度 n^2 // 因为我们这里是两层for循环，运气好的话，如果是有序的" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://lyr-2000.github.io/post/06.%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01.%E7%AE%97%E6%B3%95/01.%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" />
<meta property="article:published_time" content="2021-03-21T19:07:54+00:00" />
<meta property="article:modified_time" content="2021-03-21T19:07:54+00:00" />
<meta itemprop="name" content="排序算法">
<meta itemprop="description" content="插入排序 直接插入排序 插入排序是最简单的，我们不断比较插入数据 // 插入排序 // 时间复杂度 n^2 // 因为我们这里是两层for循环，运气好的话，如果是有序的">
<meta itemprop="datePublished" content="2021-03-21T19:07:54&#43;00:00" />
<meta itemprop="dateModified" content="2021-03-21T19:07:54&#43;00:00" />
<meta itemprop="wordCount" content="6288">



<meta itemprop="keywords" content="," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="排序算法"/>
<meta name="twitter:description" content="插入排序 直接插入排序 插入排序是最简单的，我们不断比较插入数据 // 插入排序 // 时间复杂度 n^2 // 因为我们这里是两层for循环，运气好的话，如果是有序的"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css">

</head>
<body>
  <div>
    <button class="button pink back">back</button>
    <button class="button pink go">go</button>
    <button class="button pink topUrl">top</button>
    
  </div>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">凌冬的博客</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><li style="display:inline-block;margin-right:10px;">
			<input type="search" class="mob-docsearch-input" placeholder="Search" />
		</li><a href="/">
        <li class="mobile-menu-item">首页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档页</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a><a href="/friends">
        <li class="mobile-menu-item">友人帐</li>
      </a>
	
	
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">凌冬的博客</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">首页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/friends">友人帐</a>
      </li><li  style="list-style: none;position: relative;left: 360px;bottom: 32px;">
		<input type="search" class="docsearch-input PC_MARK1" placeholder="Search" />
	  </li></ul>
</nav>
<link rel="stylesheet" href="/custom/css/post.css">

<style>
  .mob-docsearch-input {
	border: 1px solid #ccc;
	padding: 6px 0px;
	border-radius: 3px;
	padding-left:5px;
	position: relative;
    vertical-align: top;
    width: 93%;
    margin: auto;
    margin-left: 7px;
  
  }
  input.PC_MARK1{
	border: 1px solid #ccc;
	padding: 6px 0px;
	border-radius: 3px;
	padding-left:5px;
	-webkit-box-shadow: inset 0 1px 1px rgba(0,0,0,.075);
	box-shadow: inset 0 1px 1px rgba(0,0,0,.075);
	-webkit-transition: border-color ease-in-out .15s,-webkit-box-shadow ease-in-out .15s;
	-o-transition: border-color ease-in-out .15s,box-shadow ease-in-out .15s;
	transition: border-color ease-in-out .15s,box-shadow ease-in-out .15s
}
input.PC_MARK1:focus{
		border-color: #66afe9;
		outline: 0;
		-webkit-box-shadow: inset 0 1px 1px rgba(0,0,0,.075),0 0 8px rgba(102,175,233,.6);
		box-shadow: inset 0 1px 1px rgba(0,0,0,.075),0 0 8px rgba(102,175,233,.6)
}
</style>

    </header>
	
	

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">排序算法</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-03-21 </span>
        <div class="post-category">
            <a href="/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"> 算法和数据结构 </a>
            <a href="/categories/%E7%AE%97%E6%B3%95/"> 算法 </a>
            </div>
          <span class="more-meta"> 约 6288 字 </span>
          <span class="more-meta"> 预计阅读 13 分钟 </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 次阅读 </span>
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#插入排序">插入排序</a>
          <ul>
            <li><a href="#直接插入排序">直接插入排序</a></li>
            <li><a href="#折半插入排序">折半插入排序</a></li>
            <li><a href="#希尔排序">希尔排序</a></li>
          </ul>
        </li>
        <li><a href="#交换排序">交换排序</a>
          <ul>
            <li><a href="#冒泡排序">冒泡排序</a></li>
            <li><a href="#快速排序">快速排序</a></li>
          </ul>
        </li>
        <li><a href="#选择排序">选择排序</a>
          <ul>
            <li><a href="#简单选择排序">简单选择排序</a></li>
            <li><a href="#堆排序">堆排序</a></li>
            <li><a href="#归并排序">归并排序</a></li>
          </ul>
        </li>
        <li><a href="#其他排序">其他排序</a>
          <ul>
            <li><a href="#计数排序">计数排序</a></li>
            <li><a href="#桶排序">桶排序</a></li>
            <li><a href="#基数排序">基数排序</a></li>
          </ul>
        </li>
        <li><a href="#动图展示">动图展示</a>
          <ul>
            <li><a href="#冒泡排序-1">冒泡排序</a></li>
            <li><a href="#选择排序-1">选择排序</a></li>
            <li><a href="#插入排序-1">插入排序</a></li>
            <li><a href="#希尔排序-1">希尔排序</a></li>
            <li><a href="#归并排序-1">归并排序</a></li>
            <li><a href="#快速排序-1">快速排序</a></li>
            <li><a href="#堆排序-1">堆排序</a></li>
            <li><a href="#计数排序-1">计数排序</a></li>
            <li><a href="#桶排序-1">桶排序</a></li>
            <li><a href="#基数排序-1">基数排序</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>

    <div class="post-content">
      <p><img src="https://img.xiaoyou66.com/2021/03/21/da92ad2a88146.png" alt="image-20210310152450389"></p>
<h2 id="插入排序">插入排序</h2>
<h3 id="直接插入排序">直接插入排序</h3>
<p>插入排序是最简单的，我们不断比较插入数据</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// 插入排序
</span><span style="color:#75715e">// 时间复杂度 n^2
</span><span style="color:#75715e">// 因为我们这里是两层for循环，运气好的话，如果是有序的那么只需要执行一层，时间复杂度就是n
</span><span style="color:#75715e">// 运气不好的话时间复杂度就是 n^2 平均的时间复杂度为 n^2
</span><span style="color:#75715e">// 空间复杂度 1 ，因为我们只使用了一个临时变量，然后就没申请其他的了，所以空间复杂度为 1
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">insertSort</span>(<span style="color:#a6e22e">arr</span> []<span style="color:#66d9ef">int</span>){
	<span style="color:#75715e">// 使用j来表示当前排序的位置
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">j</span> = <span style="color:#ae81ff">0</span>
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span><span style="color:#f92672">:=</span><span style="color:#ae81ff">1</span>;<span style="color:#a6e22e">i</span>&lt;len(<span style="color:#a6e22e">arr</span>);<span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>{
		<span style="color:#75715e">// 使用临时变量存储
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">tmp</span><span style="color:#f92672">:=</span><span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">i</span>]
		<span style="color:#75715e">// 这个就是核心部分，首先我们让j处于i上
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// 当j-1大于tmp也就是arr[i]的时候,我们就需要把数字向后移动
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">j</span> = <span style="color:#a6e22e">i</span> ; <span style="color:#a6e22e">j</span>&gt;<span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">j</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] &gt; <span style="color:#a6e22e">tmp</span> ; <span style="color:#a6e22e">j</span><span style="color:#f92672">--</span>{
			<span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">j</span>] = <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">j</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
		}
		<span style="color:#75715e">// for循环的顺序 就是先j=1，然后执行判断语句，成功的话我们就执行函数体，最后才执行j--
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// 所以我们这里移动后，j实际上减了1，这样我们就可以直接替换了
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">j</span>] = <span style="color:#a6e22e">tmp</span>
	}
}
</code></pre></div><p>插入排序的思想如下</p>
<p><img src="https://img.xiaoyou66.com/2021/03/21/da5ab445a3753.png" alt="image-20210128094237098"></p>
<p>时间复杂度为o(n^2) 空间复杂度为o(1)</p>
<h3 id="折半插入排序">折半插入排序</h3>
<p><img src="https://img.xiaoyou66.com/2021/03/21/42f4510a65212.png" alt="image-20210128102903185"></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// 折半插入排序（这个不算10大排序算法）
</span><span style="color:#75715e">// 时间复杂度为 n^2，为什么是n^2呢，外面这一层不必多说就是n
</span><span style="color:#75715e">// 里面这层，虽然有两个for循环，但是实际情况下，这个执行的时间是随n线性变化的，所以也可以看成n
</span><span style="color:#75715e">// 空间复杂度为 1 这里为什么不是3呢，因为我们这个空间复杂度反映的是一个趋势
</span><span style="color:#75715e">// 无论我们的n是多大，我们始终只用了三个变量，所以空间复杂度为1
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bInsertSort</span>(<span style="color:#a6e22e">arr</span> []<span style="color:#66d9ef">int</span>){
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">j</span> = <span style="color:#ae81ff">0</span>
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span><span style="color:#f92672">:=</span><span style="color:#ae81ff">1</span>;<span style="color:#a6e22e">i</span>&lt;len(<span style="color:#a6e22e">arr</span>);<span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>{
		<span style="color:#75715e">// 存储临时变量
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">tmp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">i</span>]
		<span style="color:#75715e">// 赋值low和high，这里high等于i-1
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// 这里为什么i-1，因为我们最后计算的时候要确保low指针+1不会越界
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">low</span>,<span style="color:#a6e22e">high</span>,<span style="color:#a6e22e">mid</span><span style="color:#f92672">:=</span><span style="color:#ae81ff">0</span>,<span style="color:#a6e22e">i</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">0</span>
		<span style="color:#75715e">// 我们使用指针来查找需要插入的位置
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">low</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">high</span> {
			<span style="color:#a6e22e">mid</span> = (<span style="color:#a6e22e">low</span><span style="color:#f92672">+</span><span style="color:#a6e22e">high</span>) <span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>
			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">mid</span>] &gt; <span style="color:#a6e22e">tmp</span> {
				<span style="color:#a6e22e">high</span> = <span style="color:#a6e22e">mid</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
			} <span style="color:#66d9ef">else</span> {
				<span style="color:#a6e22e">low</span> = <span style="color:#a6e22e">mid</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
			}
		}
		<span style="color:#75715e">// 这里说一下为什么最后这个low就是我们应该放入的位置
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// low,high,mid的值是两个一组的，上一组是a[i]和a[mid]未经比较以前的，
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// 下一组是比较后，经过调整的。调整结果要么是low=mid+1，要么是high=mid-1。
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// 不知大家从上面的数据看出了什么。对！我们现在可以清楚的肯定：新元素的插入位置就是low。
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// 并且还发现high比low要小一，即high+1才与low相等。这是显然的，否则while循环如何结束。
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// 我想此刻大家的疑惑肯定是解开了。那么插入位置的写法就很随意了:low和high+1都行！
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// fmt.Println(low,mid,high)
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// 这里为什么要取low因为我们结束后j一定为是low，所以我们可以直接替换
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// 我也尝试过high不减一，low&lt;high 但是就是调不出来，我也不知道为什么
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">j</span>=<span style="color:#a6e22e">i</span>;<span style="color:#a6e22e">j</span>&gt;<span style="color:#a6e22e">low</span>;<span style="color:#a6e22e">j</span><span style="color:#f92672">--</span> {
			<span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">j</span>] = <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">j</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
		}
		<span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">low</span>] = <span style="color:#a6e22e">tmp</span>
	}
}
</code></pre></div><p>时间复杂度为o(n^2) 时间复杂度为O(1)</p>
<h3 id="希尔排序">希尔排序</h3>
<p><img src="https://img.xiaoyou66.com/2021/03/21/b674a6b489086.png" alt="image-20210310105042665"></p>
<p>也叫缩小增量排序，通过把整个待排序记录序列分割成几组，从而减少需要排序的数据量</p>
<p><img src="https://img.xiaoyou66.com/2021/03/21/6b2b3f93f9185.png" alt="image-20210310105238782"></p>
<p>我们的代码如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// 希尔排序
</span><span style="color:#75715e">// 时间复杂度 n^1.3 这个是别人试验验证的结果
</span><span style="color:#75715e">// 空间复杂度 不随n变化就是1
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">shellSort</span>(<span style="color:#a6e22e">arr</span> []<span style="color:#66d9ef">int</span>) {
	<span style="color:#75715e">// 首先我们就是要确定增量大小，默认情况下，我们取n=len(arr)/2，后面我们的增量就会不断的缩小
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">gap</span><span style="color:#f92672">:=</span>len(<span style="color:#a6e22e">arr</span>)<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>;<span style="color:#a6e22e">gap</span>&gt;<span style="color:#ae81ff">0</span>;<span style="color:#a6e22e">gap</span><span style="color:#f92672">/=</span><span style="color:#ae81ff">2</span>{
		<span style="color:#75715e">// 确定好增量后我们就从gap开始,这里为什么是i等于gap呢，因为我们后面是j-gap，所以我们需要从这个增量开始计算
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span><span style="color:#f92672">:=</span><span style="color:#a6e22e">gap</span>;<span style="color:#a6e22e">i</span>&lt;len(<span style="color:#a6e22e">arr</span>);<span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>{
			<span style="color:#75715e">// 用一个变量来暂存i的位置
</span><span style="color:#75715e"></span>			<span style="color:#a6e22e">j</span><span style="color:#f92672">:=</span><span style="color:#a6e22e">i</span>
			<span style="color:#75715e">// 这里就开始比较了，我们是从gap开始的，j-gap 是我们比的第二个数字，然后我们进行交换
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">j</span><span style="color:#f92672">-</span><span style="color:#a6e22e">gap</span><span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">j</span>] &lt; <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">j</span><span style="color:#f92672">-</span><span style="color:#a6e22e">gap</span>] {
				<span style="color:#75715e">// 如果发现右边大于左边的，我们就交换一下
</span><span style="color:#75715e"></span>				<span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">j</span>],<span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">j</span><span style="color:#f92672">-</span><span style="color:#a6e22e">gap</span>] = <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">j</span><span style="color:#f92672">-</span><span style="color:#a6e22e">gap</span>],<span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">j</span>]
				<span style="color:#75715e">// 这一步其实是优化，要不要都一样，我们这里就是确保后面排序后再给前面排序，加快排序速度
</span><span style="color:#75715e"></span>				<span style="color:#a6e22e">j</span><span style="color:#f92672">-=</span><span style="color:#a6e22e">gap</span>
			}
		}
	}
}
</code></pre></div><h2 id="交换排序">交换排序</h2>
<h3 id="冒泡排序">冒泡排序</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// 冒泡排序
</span><span style="color:#75715e">// 时间复杂度 n^2 因为我们用了两层循环，这种两层循环的一般都是n^2
</span><span style="color:#75715e">// 空间复杂度 1 这个和上面一样，不解释
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bubbleSort</span>(<span style="color:#a6e22e">arr</span> []<span style="color:#66d9ef">int</span>)  {
	<span style="color:#a6e22e">flag</span><span style="color:#f92672">:=</span><span style="color:#66d9ef">true</span>
	<span style="color:#75715e">// 首先我们直接设置i，i表示当前未排序的区间最大值,同时为了避免重复比较，设置一个flag来进行标记
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span><span style="color:#f92672">:=</span>len(<span style="color:#a6e22e">arr</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;<span style="color:#a6e22e">i</span>&gt;<span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">flag</span>;<span style="color:#a6e22e">i</span><span style="color:#f92672">--</span> {
		<span style="color:#75715e">// 把flag置为false，如果没有排序那么我们就退出循环
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">flag</span> = <span style="color:#66d9ef">false</span>
		<span style="color:#75715e">// 然后我们只需要按顺序排好i前面的就行了
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">j</span><span style="color:#f92672">:=</span><span style="color:#ae81ff">0</span>;<span style="color:#a6e22e">j</span>&lt;<span style="color:#a6e22e">i</span>;<span style="color:#a6e22e">j</span><span style="color:#f92672">++</span> {
			<span style="color:#75715e">// 冒泡排序是比较相邻两个位置的元素
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">j</span>] &gt; <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">j</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] {
				<span style="color:#75715e">// flag置为true表示已经排过序了
</span><span style="color:#75715e"></span>				<span style="color:#a6e22e">flag</span> = <span style="color:#66d9ef">true</span>
				<span style="color:#75715e">// 交换
</span><span style="color:#75715e"></span>				<span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">j</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>],<span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">j</span>] = <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">j</span>],<span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">j</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]
			}
		}
	}
}
</code></pre></div><p>算法思路如下</p>
<p><img src="https://img.xiaoyou66.com/2021/03/21/8b70039e1ab2c.png" alt="image-20210202102330722"></p>
<blockquote>
<p>算法特点</p>
</blockquote>
<p>(1)稳定排序。</p>
<p>(2)可用于链式存储结构。</p>
<p>(3)移动记录次数较多，算法平均时间性能比直接插入排序差。当初始记录无序，n较大时此算法不宜采用。</p>
<h3 id="快速排序">快速排序</h3>
<p>快速排序(QuickSort) 是由冒泡排序改进而得的。在冒泡排序过程中， 只对相邻的两个记录进行比较，因此每次交换两个相邻记录时只能消除一个逆序。如果能通过两个(不相邻)记录的一次交换，消除多个逆序，则会大大加快排序的速度。快速排序方法中的一次交换可能消除多个逆序。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// 快速排序-返回枢纽位置并进行排序，传入一个low指针，一个high指针，然后给数组进行简单排序
</span><span style="color:#75715e">// 这里我们的数组排序好后返回一个中间位置的指针
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">partition</span>(<span style="color:#a6e22e">arr</span> []<span style="color:#66d9ef">int</span>,<span style="color:#a6e22e">low</span> <span style="color:#66d9ef">int</span>,<span style="color:#a6e22e">high</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
	<span style="color:#75715e">// 一般情况下我们直接取low点作为枢纽，然后我们就要进行排序，把比low小的排左边，比low大的排右边
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">tmp</span><span style="color:#f92672">:=</span><span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">low</span>]
	<span style="color:#75715e">// 当low大于high时我们的排序就已经好了,这个时候其实low就是high同时这个值为我们的枢纽
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">low</span> &lt; <span style="color:#a6e22e">high</span> {
		<span style="color:#75715e">// 首先我们从high哪里往左遍历，找出第一个比tmp小的点
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">low</span> &lt; <span style="color:#a6e22e">high</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">high</span>] <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">tmp</span> {
			<span style="color:#a6e22e">high</span> <span style="color:#f92672">--</span>
		}
		<span style="color:#75715e">// 找到这个比tmp小的点后我们就替换过去，这个时候我们的high其实留了一个空
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">low</span>] = <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">high</span>]
		<span style="color:#75715e">// 因为上面high有一个空，所以这时候我们就可以从low指针开始出发，找到一个比tmp大的
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">low</span> &lt; <span style="color:#a6e22e">high</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">low</span>] <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">tmp</span> {
			<span style="color:#a6e22e">low</span> <span style="color:#f92672">++</span>
		}
		<span style="color:#75715e">// 找到后我们就可以替换了，这个时候我们就把high给替换了，此时low就没用了
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// 然后我们就可以进行下一轮比较了，然后我们可以继续把比tmp小的点放到low这里
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">high</span>] = <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">low</span>]
	}
	<span style="color:#75715e">// fmt.Println(low,high)
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// 最后替换完后，low和high其实就指向同一个位置了，这时我们就可以把low换成tmp了
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">low</span>] = <span style="color:#a6e22e">tmp</span>
	<span style="color:#75715e">// 返回low指针
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">low</span>
}

<span style="color:#75715e">// 快速排序
</span><span style="color:#75715e">// 时间复杂度 nlogn 这东西推导比较复杂
</span><span style="color:#75715e">// 具体参考 https://www.zhihu.com/question/22393997
</span><span style="color:#75715e">// 空间复杂度 最好情况nlogn（注意这个log以2为底），最坏情况就是n
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">quickSort</span>(<span style="color:#a6e22e">arr</span> []<span style="color:#66d9ef">int</span>,<span style="color:#a6e22e">low</span> <span style="color:#66d9ef">int</span>,<span style="color:#a6e22e">high</span> <span style="color:#66d9ef">int</span>)  {
	<span style="color:#75715e">// 这里也要判断，要不然会堆栈溢出
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">low</span> &lt; <span style="color:#a6e22e">high</span> {
		<span style="color:#75715e">// 给数组进行简单排序，同时留下一个mid位置的指针
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">mid</span><span style="color:#f92672">:=</span><span style="color:#a6e22e">partition</span>(<span style="color:#a6e22e">arr</span>,<span style="color:#a6e22e">low</span>,<span style="color:#a6e22e">high</span>)
		<span style="color:#75715e">// 这里我们使用递归来分别递归左右两部分
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">quickSort</span>(<span style="color:#a6e22e">arr</span>,<span style="color:#a6e22e">low</span>,<span style="color:#a6e22e">mid</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
		<span style="color:#a6e22e">quickSort</span>(<span style="color:#a6e22e">arr</span>,<span style="color:#a6e22e">mid</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,<span style="color:#a6e22e">high</span>)
	}
}
</code></pre></div><blockquote>
<p>算法特点</p>
</blockquote>
<p>(1)记录非顺次的移动导致排序方法是不稳定的。</p>
<p>(2)排序过程中需要定位表的下界和上界，所以适合用于顺序结构，很难用于链式结构。</p>
<p>(3)当n较大时，在平均情况下快速排序是所有内部排序方法中速度最快的一种，所以其适合初始记录无序、n较大时的情况。</p>
<h2 id="选择排序">选择排序</h2>
<p>选择排序的基本思想是：每一趟从待排序的记录中选出关键字最小的记录，按顺序放在已排序的记录序列的最后，直到全部排完为止。本节首先介绍一种简单选择排序方法，然后给出另一种改进的选择排序方法——堆排序。</p>
<h3 id="简单选择排序">简单选择排序</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// 选择排序
</span><span style="color:#75715e">// 时间复杂度 n^2 这个很简单，因为是for循环嵌套
</span><span style="color:#75715e">// 空间复杂度为1 
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">selectSort</span>(<span style="color:#a6e22e">arr</span> []<span style="color:#66d9ef">int</span>){
	<span style="color:#a6e22e">j</span><span style="color:#f92672">:=</span><span style="color:#ae81ff">0</span>
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">arr</span>); <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#75715e">// 记录最小值的位置
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">min</span><span style="color:#f92672">:=</span><span style="color:#a6e22e">i</span>
		<span style="color:#75715e">// 找出最小的那个值，这里我们从i开始往后找，找到一个最小的
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">j</span>=<span style="color:#a6e22e">i</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;<span style="color:#a6e22e">j</span>&lt;len(<span style="color:#a6e22e">arr</span>);<span style="color:#a6e22e">j</span><span style="color:#f92672">++</span>{
			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">j</span>] &lt; <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">min</span>]{
				<span style="color:#a6e22e">min</span> = <span style="color:#a6e22e">j</span>
			}
		}
		<span style="color:#75715e">// 最小值进行替换一下
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">i</span>],<span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">min</span>] = <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">min</span>],<span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">i</span>]
	}
}
</code></pre></div><p><img src="https://img.xiaoyou66.com/2021/03/21/c1989e6313203.png" alt="image-20210203145740355"></p>
<p>(1)就选择排序方法本身来讲，它是一种稳定的排序方法，但图8.6所表现出来的现象是不稳定的，这是因为上述实现选择排序的算法采用“交换记录”的策略所造成的，改变这个策略，可以写出不产生“不稳定现象”的选择排序算法。</p>
<p>(2)可用于链式存储结构。</p>
<p>(3)移动记录次数较少，当每一记录占用的空间较多时，此方法比直接插入排序快。</p>
<h3 id="堆排序">堆排序</h3>
<p>堆排序(HeapSort) 是一种树形选择排序， 在排序过程中， 将待排序的记录[.] 看成是一根完全二叉树的顺序存储结构、利用完全二叉树中双亲结点和孩子结点之间的内在关系、在当前无序的序列中选择关键字最大(或最小)的记录。</p>
<blockquote>
<p>堆的定义</p>
</blockquote>
<p>堆要满足下面这样的条件</p>
<p><img src="https://img.xiaoyou66.com/2021/03/21/229b9060ac35d.png" alt="image-20210203160925522"></p>
<p>堆可以看成完全二叉树</p>
<p><img src="https://img.xiaoyou66.com/2021/03/21/4c0d20ff9dc1d.png" alt="image-20210203161155273"></p>
<blockquote>
<p>堆排序的步骤</p>
</blockquote>
<p>首先需要建初堆，建初堆的目的是将无序序列调整为堆，然后我们不断交换堆顶和堆最后一个元素，然后重新调整堆</p>
<p>筛选法调整堆的算法步骤如下</p>
<p><img src="https://img.xiaoyou66.com/2021/03/21/2ce1ccad34d6e.png" alt="image-20210203162419868"></p>
<p>建初堆的步骤如下</p>
<p><img src="https://img.xiaoyou66.com/2021/03/21/abc86fe9db917.png" alt="image-20210203162626056"></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// 建初堆
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">createHeap</span>(<span style="color:#a6e22e">arr</span> []<span style="color:#66d9ef">int</span>)  {
	<span style="color:#75715e">// 这里我们使用筛选法来建初堆，我们依次把、[n/2],[n/2]-1,....,1的节点都调整为堆即可
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> len(<span style="color:#a6e22e">arr</span>) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
	<span style="color:#75715e">// 根据堆的性质，在完全二叉树中所有序号大于 [n/2]的节点都是叶子，
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// 所以我们只需要调整 1 - n/2 这个区间把这几个点调整为大根堆就行
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// 这里调整堆传入了一个开始点和结束点
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span><span style="color:#a6e22e">n</span><span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>;<span style="color:#a6e22e">i</span><span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">0</span>;<span style="color:#a6e22e">i</span><span style="color:#f92672">--</span>{
		<span style="color:#a6e22e">adjustHeap</span>(<span style="color:#a6e22e">arr</span>,<span style="color:#a6e22e">i</span>,<span style="color:#a6e22e">n</span>)
	}
}

<span style="color:#75715e">// 调整堆
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">adjustHeap</span>(<span style="color:#a6e22e">arr</span> []<span style="color:#66d9ef">int</span>,<span style="color:#a6e22e">s</span> <span style="color:#66d9ef">int</span>,<span style="color:#a6e22e">m</span> <span style="color:#66d9ef">int</span>)  {
	<span style="color:#75715e">// 保存起始点的值作为临变量
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">rc</span><span style="color:#f92672">:=</span><span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">s</span>]
	<span style="color:#75715e">// 我们使用筛选法来调整堆
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// 这里使用了堆的性质
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// 当 ki&gt;=k2i 且 ki &gt;= k2i+1 或 ki &lt;=k2i 且 ki &lt;= k2i+1
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">j</span><span style="color:#f92672">:=</span><span style="color:#ae81ff">2</span><span style="color:#f92672">*</span><span style="color:#a6e22e">s</span>;<span style="color:#a6e22e">j</span><span style="color:#f92672">&lt;=</span><span style="color:#a6e22e">m</span>;<span style="color:#a6e22e">j</span><span style="color:#f92672">*=</span><span style="color:#ae81ff">2</span>{
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">j</span>&lt;<span style="color:#a6e22e">m</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">j</span>]&lt;<span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">j</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]{ <span style="color:#a6e22e">j</span><span style="color:#f92672">++</span> }
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">rc</span> <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">j</span>] { <span style="color:#66d9ef">break</span>}
		<span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">s</span>] = <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">j</span>]
		<span style="color:#a6e22e">s</span>=<span style="color:#a6e22e">j</span>
	}
	<span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">s</span>] = <span style="color:#a6e22e">rc</span>
}

<span style="color:#75715e">// 堆排序
</span><span style="color:#75715e">// 时间复杂度 nlogn
</span><span style="color:#75715e">// 这里耗时操作在于筛选和调整 筛选需要n-1次 然后n个节点的二叉树深度为logn +1
</span><span style="color:#75715e">// 空间复杂度 1 因为只需要一个临时空间
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">heapSort</span>(<span style="color:#a6e22e">arr</span> []<span style="color:#66d9ef">int</span>)  {
	<span style="color:#75715e">// 先建堆，保证初始的时候是一个堆
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">createHeap</span>(<span style="color:#a6e22e">arr</span>)
	<span style="color:#75715e">// 开始进行for循环，进行堆排序
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span><span style="color:#f92672">:=</span>len(<span style="color:#a6e22e">arr</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;<span style="color:#a6e22e">i</span>&gt;<span style="color:#ae81ff">0</span>;<span style="color:#a6e22e">i</span><span style="color:#f92672">--</span>{
		<span style="color:#75715e">// 这里我们把最大的那个最后一个（这个指的是当前堆的最大一个）互换
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// 因为我们堆排序后0号是最大的
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">arr</span>[<span style="color:#ae81ff">0</span>],<span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">i</span>] = <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">i</span>],<span style="color:#a6e22e">arr</span>[<span style="color:#ae81ff">0</span>]
		<span style="color:#75715e">// 我们i号是最大的了，所以我们忽略i，从i-1开始进行调整
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">adjustHeap</span>(<span style="color:#a6e22e">arr</span>,<span style="color:#ae81ff">0</span>,<span style="color:#a6e22e">i</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
	}
}
</code></pre></div><p>利用了堆里面首部元素最大的特点</p>
<p><img src="https://img.xiaoyou66.com/2021/03/21/cb931655fc9d7.png" alt="image-20210203163030143"></p>
<h3 id="归并排序">归并排序</h3>
<p><img src="https://img.xiaoyou66.com/2021/03/21/84dcfcf2cff3c.png" alt="image-20210203163313449"></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// 合并表
</span><span style="color:#75715e">// 注意这里我们arr2是一个空数组，然后arr1的low和mid是一个排好序的数组，mid+1和high也是一个排好序的数组
</span><span style="color:#75715e">// 这个函数的作用就是把两个数组合并为一个数组，放入arr2中
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Merge</span>(<span style="color:#a6e22e">arr1</span> []<span style="color:#66d9ef">int</span>,<span style="color:#a6e22e">arr2</span> []<span style="color:#66d9ef">int</span>,<span style="color:#a6e22e">low</span> <span style="color:#66d9ef">int</span>,<span style="color:#a6e22e">mid</span> <span style="color:#66d9ef">int</span>,<span style="color:#a6e22e">high</span> <span style="color:#66d9ef">int</span>)  {
	<span style="color:#75715e">// 这里我们使用i和j来表示arr1数组的两部分，然后k就表示arr2数组的位置
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">i</span>,<span style="color:#a6e22e">j</span>,<span style="color:#a6e22e">k</span><span style="color:#f92672">:=</span><span style="color:#a6e22e">low</span>,<span style="color:#a6e22e">mid</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,<span style="color:#a6e22e">low</span>
	<span style="color:#75715e">// 只要有一个数组到头了，我们就介绍排序
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">mid</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">j</span><span style="color:#f92672">&lt;=</span><span style="color:#a6e22e">high</span> {
		<span style="color:#75715e">// 因为我们要合并两个数组，所以我们需要判断一下数组的两部分到底谁大
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">arr1</span>[<span style="color:#a6e22e">i</span>] &gt; <span style="color:#a6e22e">arr1</span>[<span style="color:#a6e22e">j</span>] {
			<span style="color:#75715e">// 注意，k表示arr2的位置，然后j表示的是 mid+1 到high这个数组
</span><span style="color:#75715e"></span>			<span style="color:#a6e22e">arr2</span>[<span style="color:#a6e22e">k</span>] = <span style="color:#a6e22e">arr1</span>[<span style="color:#a6e22e">j</span>];<span style="color:#a6e22e">k</span><span style="color:#f92672">++</span>;<span style="color:#a6e22e">j</span><span style="color:#f92672">++</span>
		} <span style="color:#66d9ef">else</span> {
			<span style="color:#75715e">// 注意，k表示arr2的位置，然后j表示的是 low 到mid 这个数组
</span><span style="color:#75715e"></span>			<span style="color:#a6e22e">arr2</span>[<span style="color:#a6e22e">k</span>] = <span style="color:#a6e22e">arr1</span>[<span style="color:#a6e22e">i</span>];<span style="color:#a6e22e">k</span><span style="color:#f92672">++</span>;<span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>
		}
	}
	<span style="color:#75715e">// 剩余部分因为已经是一个有序的数组了，所以我们直接按顺序加到arr2就行
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span><span style="color:#f92672">&lt;=</span><span style="color:#a6e22e">mid</span> {
		<span style="color:#a6e22e">arr2</span>[<span style="color:#a6e22e">k</span>] = <span style="color:#a6e22e">arr1</span>[<span style="color:#a6e22e">i</span>];<span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>;<span style="color:#a6e22e">k</span><span style="color:#f92672">++</span>
	}
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">j</span><span style="color:#f92672">&lt;=</span><span style="color:#a6e22e">high</span> {
		<span style="color:#a6e22e">arr2</span>[<span style="color:#a6e22e">k</span>] = <span style="color:#a6e22e">arr1</span>[<span style="color:#a6e22e">j</span>];<span style="color:#a6e22e">j</span><span style="color:#f92672">++</span>;<span style="color:#a6e22e">k</span><span style="color:#f92672">++</span>
	}
}

<span style="color:#75715e">// 2-路归并排序
</span><span style="color:#75715e">// 时间复杂度nlogn
</span><span style="color:#75715e">// 空间复杂度 n 因为我们排序的时候需要申请n个空间来存储
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">mSort</span>(<span style="color:#a6e22e">arr</span> []<span style="color:#66d9ef">int</span>,<span style="color:#a6e22e">arr2</span> []<span style="color:#66d9ef">int</span>,<span style="color:#a6e22e">low</span> <span style="color:#66d9ef">int</span>,<span style="color:#a6e22e">high</span> <span style="color:#66d9ef">int</span>)  {
	<span style="color:#75715e">// 当low和high相等的时候，这个时候大小为1，我们直接放到arr2就行
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">low</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">high</span>{
		<span style="color:#a6e22e">arr2</span>[<span style="color:#a6e22e">low</span>] = <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">low</span>]
	} <span style="color:#66d9ef">else</span> {
		<span style="color:#75715e">// 我们准备开始进行拆分,我们需要把我们的数组拆成两部分
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">arr3</span><span style="color:#f92672">:=</span>make([]<span style="color:#66d9ef">int</span>,<span style="color:#a6e22e">high</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)
		<span style="color:#75715e">// 直接取mid作为数组的分界点
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">mid</span><span style="color:#f92672">:=</span> (<span style="color:#a6e22e">low</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">high</span>) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>
		<span style="color:#75715e">// 首先我们把low和mid 进行排序并放入arr3中
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">mSort</span>(<span style="color:#a6e22e">arr</span>,<span style="color:#a6e22e">arr3</span>,<span style="color:#a6e22e">low</span>,<span style="color:#a6e22e">mid</span>)
		<span style="color:#75715e">// 然后我们把mid+1和high 进行排序并放入arr3中
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">mSort</span>(<span style="color:#a6e22e">arr</span>,<span style="color:#a6e22e">arr3</span>,<span style="color:#a6e22e">mid</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,<span style="color:#a6e22e">high</span>)
		<span style="color:#75715e">// 最后我们得到的数组在arr3中已经排好序并分成了两部分
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// 因为arr2是一个空数组，所以我们把arr3再进行排序，最后就是合并为一个有序的表并放入arr2中
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">Merge</span>(<span style="color:#a6e22e">arr3</span>,<span style="color:#a6e22e">arr2</span>,<span style="color:#a6e22e">low</span>,<span style="color:#a6e22e">mid</span>,<span style="color:#a6e22e">high</span>)
	}
}
</code></pre></div><h2 id="其他排序">其他排序</h2>
<h3 id="计数排序">计数排序</h3>
<p>参考：<a href="https://www.cxyxiaowu.com/5437.html">漫画：什么是计数排序？-五分钟学算法 (cxyxiaowu.com)</a></p>
<p>这个算法不是基于元素比较，而是利用数组下标来确定元素的正确位置</p>
<p>假定我的的20个随机整数值如下：</p>
<pre><code>9，3，5，4，9，1，2，7，8，1，3，6，5，3，4，0，10，9 ，7，9
</code></pre><p>我们可以确定最大值为10最小值为0，这样我们就建立一个大小为11的数组</p>
<p><img src="https://img.xiaoyou66.com/2021/03/21/5bef6772d5153.png" alt="image-20210311103052699"></p>
<p>非常简单，让我们遍历这个无序的随机数列，每一个整数按照其值对号入座，对应数组下标的元素进行加1操作。比如第一个整数是9，那么数组下标为9的元素加1</p>
<p><img src="https://img.xiaoyou66.com/2021/03/21/3b5862164bea3.png" alt="image-20210311103146018"></p>
<p>最终，数列遍历完毕时，数组的状态如下：</p>
<p><img src="https://img.xiaoyou66.com/2021/03/21/4a2963699bcbc.png" alt="image-20210311103157084"></p>
<p>有了这个“统计结果”，排序就很简单了。直接遍历数组，输出数组元素的下标值，元素的值是几，就输出几次：</p>
<pre><code>0，1，1，2，3，3，3，4，4，5，5，6，7，7，8，9，9，9，9，10
</code></pre><p>通常，我们为了节省空间，需要确定一个最大值和最小值</p>
<p><img src="https://img.xiaoyou66.com/2021/03/21/b17700d544132.png" alt="image-20210311104347879"></p>
<p>实际代码如下:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// 计数排序,这里我们传入一个数组，一个最小值，一个最大值
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">countingSort</span>(<span style="color:#a6e22e">arr</span> []<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">minvalue</span>, <span style="color:#a6e22e">maxValue</span> <span style="color:#66d9ef">int</span>){
	<span style="color:#75715e">// 首先我们建立一个统计数组,为了节省空间我们直接取最大值和最小值的差+1的空间，这个时候最大值在最后一个，最小值在第一个
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">count</span><span style="color:#f92672">:=</span>make([]<span style="color:#66d9ef">int</span>,<span style="color:#a6e22e">maxValue</span><span style="color:#f92672">-</span><span style="color:#a6e22e">minvalue</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)
	<span style="color:#75715e">// 遍历数组，统计出现的次数，注意我们计算的时候需要减minValue
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>,<span style="color:#a6e22e">v</span><span style="color:#f92672">:=</span><span style="color:#66d9ef">range</span> <span style="color:#a6e22e">arr</span>{
		<span style="color:#a6e22e">count</span>[<span style="color:#a6e22e">v</span><span style="color:#f92672">-</span><span style="color:#a6e22e">minvalue</span>] <span style="color:#f92672">++</span>
	}
	<span style="color:#75715e">// 最后我们输出数组，这里我们使用i来标记arr数组
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">i</span><span style="color:#f92672">:=</span><span style="color:#ae81ff">0</span>
	<span style="color:#75715e">// 遍历count
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">k</span>,<span style="color:#a6e22e">v</span><span style="color:#f92672">:=</span><span style="color:#66d9ef">range</span> <span style="color:#a6e22e">count</span>{
		<span style="color:#75715e">// 如果count数组为0那么就不管，如果不为0那么就为几，我们就输出几次
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">v</span><span style="color:#f92672">!=</span><span style="color:#ae81ff">0</span> {
			<span style="color:#75715e">// 输出v次
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">j</span><span style="color:#f92672">:=</span><span style="color:#ae81ff">0</span>;<span style="color:#a6e22e">j</span>&lt;<span style="color:#a6e22e">v</span>;<span style="color:#a6e22e">j</span><span style="color:#f92672">++</span>{
				<span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">i</span>] = <span style="color:#a6e22e">minvalue</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">k</span>
				<span style="color:#a6e22e">i</span> <span style="color:#f92672">++</span>
			}
		}
	}
}
</code></pre></div><h3 id="桶排序">桶排序</h3>
<p><a href="https://www.runoob.com/w3cnote/bucket-sort.html">1.9 桶排序 | 菜鸟教程 (runoob.com)</a></p>
<p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：</p>
<ol>
<li>在额外空间充足的情况下，尽量增大桶的数量</li>
<li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中</li>
</ol>
<p>同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。</p>
<p><strong>1. 什么时候最快</strong></p>
<p>当输入的数据可以均匀的分配到每一个桶中。</p>
<p><strong>2. 什么时候最慢</strong></p>
<p>当输入的数据被分配到了同一个桶中。</p>
<p><img src="https://img.xiaoyou66.com/2021/03/21/4fb64a1f7d2af.png" alt="image-20210311105443539"></p>
<p>比如我们有下面这几个数组</p>
<pre><code>[63,157,189,51,101,47,141,121,157,156,194,117,98,139,67,133,181,13,28,109] 
</code></pre><p>我们分成5个桶，下面开始排序</p>
<ol>
<li>找到数组中的最大值194和最小值13，然后根据桶数为5，计算出每个桶中的数据范围为<code>(194-13+1)/5=36.4</code></li>
<li>遍历原始数据，(以第一个数据63为例)先找到该数据对应的桶序列<code>Math.floor(63 - 13) / 36.4) =1</code>，然后将该数据放入序列为1的桶中(从0开始算)</li>
<li>当向同一个序列的桶中第二次插入数据时，判断桶中已存在的数字与新插入的数字的大小，按从左到右，从小打大的顺序插入。如第一个桶已经有了63，再插入51，67后，桶中的排序为(51,63,67) <strong>一般通过链表来存放桶中数据，但js中可以使用数组来模拟</strong></li>
<li>全部数据装桶完毕后，按序列，从小到大合并所有非空的桶(如0,1,2,3,4桶)</li>
<li>合并完之后就是已经排完序的数据</li>
</ol>
<p><img src="https://img.xiaoyou66.com/2021/03/21/079dbab6a522f.png" alt="image-20210311105823407"></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// 桶排序，这里我们传入一个最大值，还有一为个桶的数量
</span><span style="color:#75715e">// 时间复杂度 为n+k
</span><span style="color:#75715e">// 空间复杂度为 n+k
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sortBucket</span>(<span style="color:#a6e22e">arr</span> []<span style="color:#66d9ef">int</span>,<span style="color:#a6e22e">max</span> <span style="color:#66d9ef">int</span>,<span style="color:#a6e22e">num</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#75715e">// 创建桶，大小为我们传入桶的数量
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">buckets</span> <span style="color:#f92672">:=</span> make([][]<span style="color:#66d9ef">int</span>,<span style="color:#a6e22e">num</span>)
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">index</span> <span style="color:#66d9ef">int</span>
	<span style="color:#75715e">// 遍历数组
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>,<span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">arr</span>{
		<span style="color:#75715e">// 分配桶 index = value * (n-1)/k 这里我们使用公式来确放入的位置
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">index</span> = <span style="color:#a6e22e">v</span> <span style="color:#f92672">*</span> (<span style="color:#a6e22e">num</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">/</span> <span style="color:#a6e22e">max</span>
		<span style="color:#75715e">// 把我们的数字放入桶内
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">buckets</span>[<span style="color:#a6e22e">index</span>] = append(<span style="color:#a6e22e">buckets</span>[<span style="color:#a6e22e">index</span>],<span style="color:#a6e22e">v</span>)
	}
	<span style="color:#75715e">// 桶内排序
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">tmpPos</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
	<span style="color:#75715e">// 这里我们遍历每一个桶
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">k</span><span style="color:#f92672">:=</span><span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">k</span> &lt; <span style="color:#a6e22e">num</span>; <span style="color:#a6e22e">k</span><span style="color:#f92672">++</span> {
		<span style="color:#75715e">// 获取桶里面数据的长度
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">bucketLen</span> <span style="color:#f92672">:=</span> len(<span style="color:#a6e22e">buckets</span>[<span style="color:#a6e22e">k</span>])
		<span style="color:#75715e">// 如果我们这个桶大小为0，那么我们就对桶里面进行排序
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">bucketLen</span>&gt;<span style="color:#ae81ff">0</span>{
			<span style="color:#75715e">// 使用插入排序对数组进行排序
</span><span style="color:#75715e"></span>			<span style="color:#a6e22e">insertSort</span>(<span style="color:#a6e22e">buckets</span>[<span style="color:#a6e22e">k</span>])
			<span style="color:#75715e">// 我们把排序好的部分复制到数组中
</span><span style="color:#75715e"></span>			copy(<span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">tmpPos</span>:],<span style="color:#a6e22e">buckets</span>[<span style="color:#a6e22e">k</span>])
			<span style="color:#75715e">// 数组位置加上桶的大小，开始保存下一个桶
</span><span style="color:#75715e"></span>			<span style="color:#a6e22e">tmpPos</span> <span style="color:#f92672">+=</span><span style="color:#a6e22e">bucketLen</span>
		}
	}
}
</code></pre></div><h3 id="基数排序">基数排序</h3>
<p>基数排序与桶排序、计数排序都用到了桶的概念，但对桶的使用方法上有明显差异：</p>
<ul>
<li>基数排序：根据键值的每位数字来分配桶；</li>
<li>计数排序：每个桶只存储单一键值；</li>
<li>桶排序：每个桶存储一定范围的数值；</li>
</ul>
<p>基数排序按取数方向分为两种：从左取每个数列上的数，为<strong>最高位优先（Most Significant Digit first, MSD）</strong>；从右取每个数列上的数，为<strong>最低位优先（Least Significant Digit first, LSD）</strong>。下列以LSD为例。</p>
<p>基数排序步骤：</p>
<ul>
<li>将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零</li>
<li>从最低位开始，依次进行一次排序</li>
<li>从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">radixSort</span>(<span style="color:#a6e22e">theArray</span> []<span style="color:#66d9ef">int</span>,<span style="color:#a6e22e">max</span> <span style="color:#66d9ef">int</span>){
	<span style="color:#75715e">// 因为前面我们获取了最大值，这里我们获取一下最大值的位数
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">count</span> = <span style="color:#ae81ff">0</span>
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">max</span> <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span>&gt;<span style="color:#ae81ff">0</span>{
		<span style="color:#a6e22e">max</span> <span style="color:#f92672">/=</span> <span style="color:#ae81ff">10</span>
		<span style="color:#a6e22e">count</span><span style="color:#f92672">++</span>
	}
	<span style="color:#75715e">// 给桶中对应的位置放数据
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span><span style="color:#f92672">:=</span><span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span>&lt;<span style="color:#a6e22e">count</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#75715e">// 根据不同的位数，我们来获取10的n次方，用于后面获取每位的值
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">theData</span> <span style="color:#f92672">:=</span> int(<span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Pow10</span>(<span style="color:#a6e22e">i</span>))
		<span style="color:#75715e">// 建立空桶
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">bucket</span><span style="color:#f92672">:=</span>make([][]<span style="color:#66d9ef">int</span>,<span style="color:#ae81ff">10</span>)
		<span style="color:#75715e">// 遍历数组
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">k</span><span style="color:#f92672">:=</span><span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">k</span>&lt;len(<span style="color:#a6e22e">theArray</span>); <span style="color:#a6e22e">k</span><span style="color:#f92672">++</span>{
			<span style="color:#75715e">// 这里我们进行取余操作，目的是为了获取这个数组在每位上的值
</span><span style="color:#75715e"></span>			<span style="color:#a6e22e">theResidue</span> <span style="color:#f92672">:=</span> (<span style="color:#a6e22e">theArray</span>[<span style="color:#a6e22e">k</span>]<span style="color:#f92672">/</span><span style="color:#a6e22e">theData</span>) <span style="color:#f92672">%</span><span style="color:#ae81ff">10</span>
			<span style="color:#75715e">// 获取到了位数后我们直接放入对应的桶中
</span><span style="color:#75715e"></span>			<span style="color:#a6e22e">bucket</span>[<span style="color:#a6e22e">theResidue</span>] = append(<span style="color:#a6e22e">bucket</span>[<span style="color:#a6e22e">theResidue</span>],<span style="color:#a6e22e">theArray</span>[<span style="color:#a6e22e">k</span>])
		}

		<span style="color:#75715e">// 一遍循环完之后需要把数组二维数据进行重新排序，比如数组开始是10 1 18 30 23 12 7 5 18 233 144 ，循环个位数
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// 循环之后的结果为10 30 1 12 23 233 144 5 7 18 18 ，然后循环十位数，结果为1 5 7 10 12 18 18 23 30 233 144
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// 最后循环百位数，结果为1 5 7 10 12 18 18 23 30 144 233
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">x</span> = <span style="color:#ae81ff">0</span>
		<span style="color:#75715e">// 遍历我们的桶
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">p</span><span style="color:#f92672">:=</span><span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">p</span>&lt;len(<span style="color:#a6e22e">bucket</span>); <span style="color:#a6e22e">p</span><span style="color:#f92672">++</span> {
			<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">q</span><span style="color:#f92672">:=</span><span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">q</span>&lt;len(<span style="color:#a6e22e">bucket</span>[<span style="color:#a6e22e">p</span>]); <span style="color:#a6e22e">q</span><span style="color:#f92672">++</span> {
				<span style="color:#75715e">// 这里按照桶的结构，按桶的顺序把桶里面的数据放入数组中
</span><span style="color:#75715e"></span>				<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">bucket</span>[<span style="color:#a6e22e">p</span>][<span style="color:#a6e22e">q</span>]<span style="color:#f92672">!=</span><span style="color:#ae81ff">0</span> {
					<span style="color:#a6e22e">theArray</span>[<span style="color:#a6e22e">x</span>] = <span style="color:#a6e22e">bucket</span>[<span style="color:#a6e22e">p</span>][<span style="color:#a6e22e">q</span>]
					<span style="color:#a6e22e">x</span><span style="color:#f92672">++</span>
				}<span style="color:#66d9ef">else</span> {
					<span style="color:#66d9ef">break</span>
				}
			}
		}
	}
}
</code></pre></div><h2 id="动图展示">动图展示</h2>
<h3 id="冒泡排序-1">冒泡排序</h3>
<p><img src="https://img.xiaoyou66.com/2021/03/21/951aff5d869c3.gif" alt="img"></p>
<h3 id="选择排序-1">选择排序</h3>
<p><img src="https://img.xiaoyou66.com/2021/03/21/5ed0ae683a31a.gif" alt="img"></p>
<h3 id="插入排序-1">插入排序</h3>
<p><img src="https://img.xiaoyou66.com/2021/03/21/a945cc090e486.gif" alt="img"></p>
<h3 id="希尔排序-1">希尔排序</h3>
<p><img src="https://img.xiaoyou66.com/2021/03/21/0a0918702b478.gif" alt="归并排序"></p>
<h3 id="归并排序-1">归并排序</h3>
<p><img src="https://img.xiaoyou66.com/2021/03/21/5a6e77b2dd552.gif" alt="img"></p>
<p><img src="https://img.xiaoyou66.com/2021/03/21/6f7105de6ceb1.gif" alt="img"></p>
<h3 id="快速排序-1">快速排序</h3>
<p><img src="https://img.xiaoyou66.com/2021/03/21/3c1572ae25ca1.gif" alt="img"></p>
<p><img src="https://img.xiaoyou66.com/2021/03/21/4ea3a4530f2c4.gif" alt="img"></p>
<h3 id="堆排序-1">堆排序</h3>
<p><img src="https://img.xiaoyou66.com/2021/03/21/91246bdf58339.gif" alt="img"></p>
<p><img src="https://img.xiaoyou66.com/2021/03/21/ba376597c7685.gif" alt="img"></p>
<h3 id="计数排序-1">计数排序</h3>
<p><img src="https://img.xiaoyou66.com/2021/03/21/f6df9e7ff91c9.gif" alt="img"></p>
<h3 id="桶排序-1">桶排序</h3>
<p><img src="https://img.xiaoyou66.com/2021/03/21/4455032208e07.gif" alt="img"></p>
<h3 id="基数排序-1">基数排序</h3>
<p><img src="https://img.xiaoyou66.com/2021/03/21/685892720c3c9.gif" alt="img"></p>
<p>参考<a href="https://www.jianshu.com/p/bd7d6f1be6e7">收集一波十大算法动态图 - 简书 (jianshu.com)</a></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">LYR</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2021-03-21
        
    </span>
  </p>
  
  
</div>
<div class="post-reward">
  <input type="checkbox" name="reward" id="reward" hidden />
  <label class="reward-button" for="reward">赞赏支持</label>
  <div class="qr-code">
    
    <label class="qr-code-image" for="reward">
        <img class="image" src="/img/reward/wechat.jpg">
        <span>微信打赏</span>
      </label>
    <label class="qr-code-image" for="reward">
        <img class="image" src="/img/reward/alipay.jpg">
        <span>支付宝打赏</span>
      </label>
  </div>
</div><footer class="post-footer">
      <div class="post-tags">
          <a href="/tags//"></a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/06.%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01.%E7%AE%97%E6%B3%95/03.%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">时间复杂度和空间复杂度</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/06.%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01.%E7%AE%97%E6%B3%95/02.%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/">
            <span class="next-text nav-default">查找算法</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>

  
  
        </div>
        <div id="gitalk-container"></div>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js" crossorigin="anonymous"></script>
    <script type="text/javascript">
      var gitalk = new Gitalk({
        id: '2021-03-21 19:07:54 \u002b0000 UTC',
        title: '排序算法',
        clientID: '604ae0a4eff099135503',
        clientSecret: '403ff7c3a3ff6a91d905110c91eb1651219b7233',
        repo: 'lyr-2000.github.io',
        owner: 'lyr-2000',
        admin: ['lyr-2000'],
        body: decodeURI(location.href)
      });
      gitalk.render('gitalk-container');
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/gitalk/gitalk">comments powered by gitalk.</a></noscript>

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:lyr-2000@qq.com" class="iconfont icon-email" title="email"></a>
  <a href="" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> 本站总访问量 <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 次 </span>
      <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> 本站总访客数 <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 人 </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2021-08-01 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span>LYR</span>
  </span>
</div>



<script 
 
    src="https://cdn.jsdelivr.net/gh/lyr-2000/live2d-widget@latest/autoload.js"></script>








    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script><script></script><script src="https://cdn.jsdelivr.net/npm/raphael@2.2.7/raphael.min.js" integrity="sha256-67By+NpOtm9ka1R6xpUefeGOY8kWWHHRAKlvaTJ7ONI=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/flowchart.js@1.8.0/release/flowchart.min.js" integrity="sha256-zNGWjubXoY6rb5MnmpBNefO0RgoVYfle9p0tvOQM+6k=" crossorigin="anonymous"></script><script></script><script src="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.js" integrity="sha256-4O4pS1SH31ZqrSO2A/2QJTVjTPqVe+jnYgOWUVr7EEc=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/snapsvg@0.5.1/dist/snap.svg-min.js" integrity="sha256-oI+elz+sIm+jpn8F/qEspKoKveTc5uKeFHNNVexe6d8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/underscore@1.8.3/underscore-min.js" integrity="sha256-obZACiHd7gkOk9iIL/pimWMTJ4W/pBsKu+oZnSeBIek=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/gh/bramp/js-sequence-diagrams@2.0.1/dist/sequence-diagram-min.js" integrity="sha384-8748Vn52gHJYJI0XEuPB2QlPVNUkJlJn9tHqKec6J3q2r9l8fvRxrgn/E5ZHV0sP" crossorigin="anonymous"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/bramp/js-sequence-diagrams@2.0.1/dist/sequence-diagram-min.css" integrity="sha384-6QbLKJMz5dS3adWSeINZe74uSydBGFbnzaAYmp+tKyq60S7H2p6V7g1TysM5lAaF" crossorigin="anonymous">



<script type="text/javascript" src="/js/main.min.997ae6d980b0d253afd76f324409f121745697345cd7aa95647153ea145416fa.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>






<script defer="defer" async src="/js/custom/docsearch.min.js" ></script>
<script defer="defer" async>
 
  window.addEventListener('load',function() {
  
	docsearch({
		apiKey: "2991187e127fb95e62db841ea946bc06",
		indexName: "blog",
		appId: "UVGAU2QDTQ",
		inputSelector: '.docsearch-input',
		debug: false,
    });
    docsearch({
	 apiKey: "2991187e127fb95e62db841ea946bc06",
	 indexName: "blog",
	 appId: "UVGAU2QDTQ",
	 inputSelector: '.mob-docsearch-input',
	 debug: false,
    });
  });
 
</script>
  
  <script  src="/custom/img/lazyload.min.js"></script>
  <script defer="defer" async src="/custom/post/back_btn.js"></script>
  

</body>
</html>
