<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ES6 on 凌冬的个人博客</title>
    <link>https://lyr-2000.github.io/tags/es6/</link>
    <description>Recent content in ES6 on 凌冬的个人博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>lyr</copyright>
    <lastBuildDate>Sun, 09 Feb 2020 16:00:30 +0000</lastBuildDate>
    
	<atom:link href="https://lyr-2000.github.io/tags/es6/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Mixin</title>
      <link>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/32.mixin/</link>
      <pubDate>Sun, 09 Feb 2020 16:00:30 +0000</pubDate>
      
      <guid>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/32.mixin/</guid>
      <description>Mixin JavaScript 语言的设计是单一继承，即子类只能继承一个父类，不允许继承多个父类。这种设计保证了对象继承的层次结构是树状的，而不是复杂的网状结构。 但是，</description>
    </item>
    
    <item>
      <title>SIMD</title>
      <link>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/33.simd/</link>
      <pubDate>Sun, 09 Feb 2020 16:00:30 +0000</pubDate>
      
      <guid>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/33.simd/</guid>
      <description>SIMD 概述 SIMD（发音/sim-dee/）是“Single Instruction/Multiple Data”的缩写，意为“单指令，多数据”。它是 JavaScript 操作 CPU 对应指令的接口，你可以看做这</description>
    </item>
    
    <item>
      <title>函数式编程</title>
      <link>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/31.%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Sun, 09 Feb 2020 16:00:30 +0000</pubDate>
      
      <guid>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/31.%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</guid>
      <description>函数式编程 JavaScript 语言从一诞生，就具有函数式编程的烙印。它将函数作为一种独立的数据类型，与其他数据类型处于完全平等的地位。在 JavaScript 语言中，你可以采用面</description>
    </item>
    
    <item>
      <title>参考链接</title>
      <link>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/34.%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5/</link>
      <pubDate>Sun, 09 Feb 2020 16:00:30 +0000</pubDate>
      
      <guid>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/34.%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5/</guid>
      <description>参考链接 官方文件 ECMAScript® 2015 Language Specification: ECMAScript 2015 规格 ECMAScript® 2016 Language Specification: ECMAScript 2016 规格 ECMAScript® 2017 Language Specification</description>
    </item>
    
    <item>
      <title>最新提案</title>
      <link>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/29.%E6%9C%80%E6%96%B0%E6%8F%90%E6%A1%88/</link>
      <pubDate>Sun, 09 Feb 2020 16:00:30 +0000</pubDate>
      
      <guid>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/29.%E6%9C%80%E6%96%B0%E6%8F%90%E6%A1%88/</guid>
      <description>最新提案 本章介绍一些尚未进入标准、但很有希望的最新提案。 do 表达式 本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。 1 2 3 4 { let</description>
    </item>
    
    <item>
      <title>装饰器</title>
      <link>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/30.%E8%A3%85%E9%A5%B0%E5%99%A8/</link>
      <pubDate>Sun, 09 Feb 2020 16:00:30 +0000</pubDate>
      
      <guid>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/30.%E8%A3%85%E9%A5%B0%E5%99%A8/</guid>
      <description>装饰器 [说明] Decorator 提案经过了大幅修改，目前还没有定案，不知道语法会不会再变。下面的内容完全依据以前的提案，已经有点过时了。等待定案以后，需要完</description>
    </item>
    
    <item>
      <title>ArrayBuffer</title>
      <link>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/28.arraybuffer/</link>
      <pubDate>Sun, 09 Feb 2020 16:00:29 +0000</pubDate>
      
      <guid>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/28.arraybuffer/</guid>
      <description>ArrayBuffer ArrayBuffer对象、TypedArray视图和DataView视图是 JavaScript 操作二进制数据的一个接口。这些对象早就存在，属于独立的规格（</description>
    </item>
    
    <item>
      <title>async 函数</title>
      <link>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/20.async-%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sun, 09 Feb 2020 16:00:29 +0000</pubDate>
      
      <guid>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/20.async-%E5%87%BD%E6%95%B0/</guid>
      <description>async 函数 含义 ES2017 标准引入了 async 函数，使得异步操作变得更加方便。 async 函数是什么？一句话，它就是 Generator 函数的语法糖。 前文有一个 Generator 函数，依次读取两个文件。 1 2</description>
    </item>
    
    <item>
      <title>Class 的基本语法</title>
      <link>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/21.class-%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</link>
      <pubDate>Sun, 09 Feb 2020 16:00:29 +0000</pubDate>
      
      <guid>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/21.class-%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</guid>
      <description>Class 的基本语法 简介 类的由来 JavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。 1 2 3 4 5 6 7 8 9 10 function Point(x, y) { this.x = x; this.y = y; } Point.prototype.toString = function () {</description>
    </item>
    
    <item>
      <title>Class 的继承</title>
      <link>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/22.class-%E7%9A%84%E7%BB%A7%E6%89%BF/</link>
      <pubDate>Sun, 09 Feb 2020 16:00:29 +0000</pubDate>
      
      <guid>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/22.class-%E7%9A%84%E7%BB%A7%E6%89%BF/</guid>
      <description>Class 的继承 简介 Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。 1 2 3 4 5 class Point { } class ColorPoint extends Point { } 上面代码</description>
    </item>
    
    <item>
      <title>Generator 函数的异步应用</title>
      <link>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/19.generator-%E5%87%BD%E6%95%B0%E7%9A%84%E5%BC%82%E6%AD%A5%E5%BA%94%E7%94%A8/</link>
      <pubDate>Sun, 09 Feb 2020 16:00:29 +0000</pubDate>
      
      <guid>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/19.generator-%E5%87%BD%E6%95%B0%E7%9A%84%E5%BC%82%E6%AD%A5%E5%BA%94%E7%94%A8/</guid>
      <description>Generator 函数的异步应用 异步编程对 JavaScript 语言太重要。JavaScript 语言的执行环境是“单线程”的，如果没有异步编程，根本没法用，非卡死不可。本章主要</description>
    </item>
    
    <item>
      <title>Generator 函数的语法</title>
      <link>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/18.generator-%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%B3%95/</link>
      <pubDate>Sun, 09 Feb 2020 16:00:29 +0000</pubDate>
      
      <guid>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/18.generator-%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%B3%95/</guid>
      <description>Generator 函数的语法 简介 基本概念 Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。本章详细介绍 Generator 函数的语法和 API，它的异步编程应用</description>
    </item>
    
    <item>
      <title>Iterator 和 for-of 循环</title>
      <link>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/17.iterator-%E5%92%8C-for-of-%E5%BE%AA%E7%8E%AF/</link>
      <pubDate>Sun, 09 Feb 2020 16:00:29 +0000</pubDate>
      
      <guid>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/17.iterator-%E5%92%8C-for-of-%E5%BE%AA%E7%8E%AF/</guid>
      <description>Iterator 和 for&amp;hellip;of 循环 Iterator（遍历器）的概念 JavaScript 原有的表示“集合”的数据结构，主要是数组（Array）和对象（Object），ES6 又添加了Ma</description>
    </item>
    
    <item>
      <title>let 和 const 命令</title>
      <link>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/02.let-%E5%92%8C-const-%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Sun, 09 Feb 2020 16:00:29 +0000</pubDate>
      
      <guid>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/02.let-%E5%92%8C-const-%E5%91%BD%E4%BB%A4/</guid>
      <description>let 和 const 命令 let 命令 基本用法 ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效(块级作用</description>
    </item>
    
    <item>
      <title>Module 的加载实现</title>
      <link>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/24.module-%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Sun, 09 Feb 2020 16:00:29 +0000</pubDate>
      
      <guid>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/24.module-%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0/</guid>
      <description>Module 的加载实现 上一章介绍了模块的语法，本章介绍如何在浏览器和 Node.js 之中加载 ES6 模块，以及实际开发中经常遇到的一些问题（比如循环加载）。 浏览器加载 传统</description>
    </item>
    
    <item>
      <title>Module 的语法</title>
      <link>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/23.module-%E7%9A%84%E8%AF%AD%E6%B3%95/</link>
      <pubDate>Sun, 09 Feb 2020 16:00:29 +0000</pubDate>
      
      <guid>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/23.module-%E7%9A%84%E8%AF%AD%E6%B3%95/</guid>
      <description>Module 的语法 概述 历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其</description>
    </item>
    
    <item>
      <title>Promise 对象</title>
      <link>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/16.promise-%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Sun, 09 Feb 2020 16:00:29 +0000</pubDate>
      
      <guid>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/16.promise-%E5%AF%B9%E8%B1%A1/</guid>
      <description>Promise 对象 Promise 的含义 Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言</description>
    </item>
    
    <item>
      <title>Proxy</title>
      <link>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/14.proxy/</link>
      <pubDate>Sun, 09 Feb 2020 16:00:29 +0000</pubDate>
      
      <guid>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/14.proxy/</guid>
      <description>Proxy 概述 Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程</description>
    </item>
    
    <item>
      <title>Reflect</title>
      <link>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/15.reflect/</link>
      <pubDate>Sun, 09 Feb 2020 16:00:29 +0000</pubDate>
      
      <guid>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/15.reflect/</guid>
      <description>Reflect 概述 Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。Reflect对象的设计目的有这样几个。 （1） **将Obj</description>
    </item>
    
    <item>
      <title>Set 和 Map 数据结构</title>
      <link>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/13.set-%E5%92%8C-map-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <pubDate>Sun, 09 Feb 2020 16:00:29 +0000</pubDate>
      
      <guid>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/13.set-%E5%92%8C-map-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      <description>Set 和 Map 数据结构 Set 基本用法 ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 Set本身是一个构造函数，用来生成 Set</description>
    </item>
    
    <item>
      <title>Symbol</title>
      <link>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/12.symbol/</link>
      <pubDate>Sun, 09 Feb 2020 16:00:29 +0000</pubDate>
      
      <guid>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/12.symbol/</guid>
      <description>Symbol 概述 ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新</description>
    </item>
    
    <item>
      <title>函数的扩展</title>
      <link>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/08.%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95/</link>
      <pubDate>Sun, 09 Feb 2020 16:00:29 +0000</pubDate>
      
      <guid>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/08.%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95/</guid>
      <description>函数的扩展 函数参数的默认值 基本用法 ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。 1 2 3 4 5 6 7 8 function log(x, y) { y = y || &amp;#39;World&amp;#39;; console.log(x, y); } log(&amp;#39;Hello&amp;#39;) // Hello</description>
    </item>
    
    <item>
      <title>变量的解构赋值</title>
      <link>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/03.%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</link>
      <pubDate>Sun, 09 Feb 2020 16:00:29 +0000</pubDate>
      
      <guid>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/03.%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</guid>
      <description>变量的解构赋值 数组的解构赋值 基本用法 ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 以</description>
    </item>
    
    <item>
      <title>字符串的扩展</title>
      <link>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/04.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95/</link>
      <pubDate>Sun, 09 Feb 2020 16:00:29 +0000</pubDate>
      
      <guid>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/04.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95/</guid>
      <description>字符串的扩展 本章介绍 ES6 对字符串的改造和增强，下一章介绍字符串对象的新增方法。 字符的 Unicode 表示法 ES6 加强了对 Unicode 的支持，允许采用\uxxxx形式表示一</description>
    </item>
    
    <item>
      <title>字符串的新增方法</title>
      <link>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/05.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sun, 09 Feb 2020 16:00:29 +0000</pubDate>
      
      <guid>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/05.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95/</guid>
      <description>字符串的新增方法 本章介绍字符串对象的新增方法。 String.fromCodePoint() ES5 提供String.fromCharCode()方法，用于从 Unicode 码点返回对应字符，但是这个方法</description>
    </item>
    
    <item>
      <title>对象的扩展</title>
      <link>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/10.%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95/</link>
      <pubDate>Sun, 09 Feb 2020 16:00:29 +0000</pubDate>
      
      <guid>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/10.%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95/</guid>
      <description>对象的扩展 对象（object）是 JavaScript 最重要的数据结构。ES6 对它进行了重大升级，本章介绍数据结构本身的改变，下一章介绍Object对象的新增方</description>
    </item>
    
    <item>
      <title>对象的新增方法</title>
      <link>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/11.%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sun, 09 Feb 2020 16:00:29 +0000</pubDate>
      
      <guid>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/11.%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95/</guid>
      <description>对象的新增方法 本章介绍 Object 对象的新增方法。 Object.is() ES5 比较两个值是否相等，只有两个运算符：相等运算符（==）和严格相等运算符（===）。它们都有缺点，</description>
    </item>
    
    <item>
      <title>异步遍历器</title>
      <link>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/27.%E5%BC%82%E6%AD%A5%E9%81%8D%E5%8E%86%E5%99%A8/</link>
      <pubDate>Sun, 09 Feb 2020 16:00:29 +0000</pubDate>
      
      <guid>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/27.%E5%BC%82%E6%AD%A5%E9%81%8D%E5%8E%86%E5%99%A8/</guid>
      <description>异步遍历器 同步遍历器的问题 《遍历器》一章说过，Iterator 接口是一种数据遍历的协议，只要调用遍历器对象的next方法，就会得到一个对象，</description>
    </item>
    
    <item>
      <title>数值的扩展</title>
      <link>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/07.%E6%95%B0%E5%80%BC%E7%9A%84%E6%89%A9%E5%B1%95/</link>
      <pubDate>Sun, 09 Feb 2020 16:00:29 +0000</pubDate>
      
      <guid>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/07.%E6%95%B0%E5%80%BC%E7%9A%84%E6%89%A9%E5%B1%95/</guid>
      <description>数值的扩展 二进制和八进制表示法 ES6 提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。 1 2 0b111110111 === 503 // true 0o767 === 503 // true 从</description>
    </item>
    
    <item>
      <title>数组的扩展</title>
      <link>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/09.%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95/</link>
      <pubDate>Sun, 09 Feb 2020 16:00:29 +0000</pubDate>
      
      <guid>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/09.%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95/</guid>
      <description>数组的扩展 扩展运算符 含义 扩展运算符（spread）是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。 1 2 3 4 5 6</description>
    </item>
    
    <item>
      <title>正则的扩展</title>
      <link>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/06.%E6%AD%A3%E5%88%99%E7%9A%84%E6%89%A9%E5%B1%95/</link>
      <pubDate>Sun, 09 Feb 2020 16:00:29 +0000</pubDate>
      
      <guid>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/06.%E6%AD%A3%E5%88%99%E7%9A%84%E6%89%A9%E5%B1%95/</guid>
      <description>正则的扩展 RegExp 构造函数 在 ES5 中，RegExp构造函数的参数有两种情况。 第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag</description>
    </item>
    
    <item>
      <title>编程风格</title>
      <link>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/25.%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC/</link>
      <pubDate>Sun, 09 Feb 2020 16:00:29 +0000</pubDate>
      
      <guid>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/25.%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC/</guid>
      <description>编程风格 本章探讨如何将 ES6 的新语法，运用到编码实践之中，与传统的 JavaScript 语法结合在一起，写出合理的、易于阅读和维护的代码。 多家公司和组织已经公开了它</description>
    </item>
    
    <item>
      <title>读懂 ECMAScript 规格</title>
      <link>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/26.%E8%AF%BB%E6%87%82-ecmascript-%E8%A7%84%E6%A0%BC/</link>
      <pubDate>Sun, 09 Feb 2020 16:00:29 +0000</pubDate>
      
      <guid>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/26.%E8%AF%BB%E6%87%82-ecmascript-%E8%A7%84%E6%A0%BC/</guid>
      <description>读懂 ECMAScript 规格 概述 规格文件是计算机语言的官方标准，详细描述语法规则和实现方法。 一般来说，没有必要阅读规格，除非你要写编译器。因为规格写得非常抽象</description>
    </item>
    
    <item>
      <title>ECMAScript 6 简介</title>
      <link>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/01.ecmascript-6-%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Sun, 12 Jan 2020 15:45:35 +0000</pubDate>
      
      <guid>https://lyr-2000.github.io/post/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/01.ecmascript-6-%E7%AE%80%E4%BB%8B/</guid>
      <description>说明：本章内容为博主在原教程基础上添加自己的学习笔记，来源http://es6.ruanyifeng.com/，教程版权归原作者所有。 ECMAScript 6 简</description>
    </item>
    
  </channel>
</rss>