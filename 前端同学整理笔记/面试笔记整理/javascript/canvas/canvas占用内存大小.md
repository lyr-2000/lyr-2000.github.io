canvas给我们提供了像素级别的操作手段，那么100px*100px的canvas占用的内存是多少呢

要知道100px*100px的占用内存，我们首先就要知道1px*1px占用的内存是多少，实际上，我们可以从web浏览器使用的颜色来看

我们一般情况下会使用的颜色表达无非就两种，rgb/rgba或者是十六进制表示法，实际上这两种表示法最后的计算结果都是一样的

我们要在页面中渲染一个像素，就需要知道这个像素位置的颜色和透明度，按rgb/rgba的计算，r、g、b的值在0-255，也就是共有256*3的数，而256就是2的8次方，也就是一个字节，所以总的就是3个字节（3Byte），透明度从0-1，每个步长为0.01，所以有100个值，但实际上，在存储中还是用了256个位来存储，我们在下面的例子中会验证这个说法。因此透明度也占了一个字节，总的也就是3+1=4个字节

所以从rgb/rgba来看的话，每个像素占用了4个字节的内存

而从十六进制表示法来看也是一样的，十六进制使用6位表示（不看简写3位的，因为3位简写实际上还是会变为6位），每位有0-9，a-f的值,也就是16个值，即2的4次方，所以总的是6 * 2 ** 4 = 3 * 2 ** 8，也就是说颜色还是使用3个字节表示，加上透明度，还是4个字节

接下来，我们通过getImageData方法来证实一下透明度采用256位表示，如下代码例子
```html
<body>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.querySelector("#canvas")
        canvas.width = 100
        canvas.height = 100
        const ctx = canvas.getContext('2d')
        ctx.fillStyle = "rgba(102,0,0,0.8)"
        ctx.fillRect(0, 0, 10, 10)
        console.log(ctx.getImageData(1,1,1,1))
    </script>
</body>
```
在控制台可以看到，打印出了一个ImageData对象，而这个对象的data属性的数组，里面的这个成员变量，就对应着rgba这个内容
![](https://user-gold-cdn.xitu.io/2020/3/9/170be3f075b1f839?w=550&h=116&f=png&s=12956)
这里可以看到，最后一个数值是204，而我们刚才的透明度设置是0.8，实际上就是255*0.8 == 204 所以这也验证了上面我们说的，透明度也是采用256位来存放的