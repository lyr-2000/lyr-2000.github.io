http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html
# MVC
MVC是比较传统的一种架构模式，M(model)，V(view)，C(controller)  

在我看来，这三个的职责为
* M：负责应用的行为和数据，响应更新状态的指令（通常来自C），和数据请求（通常来自V）并发生变化
* V：负责视图的显示
* C：负责处理用户的输入，并按相应的输入操作M和V

## 依赖关系
在MVC中，M层可以独立工作，但是V层和C层，都需要依赖于M层的数据才能进行工作

## 发布订阅模式
在MVC中，M层可以独立工作，同时，M层无法去获取V层和C层的任何信息，在这种情况下，我们又要使得当M层的数据发生变化的时候，可以对V层和C层造成影响，此时就可以用到发布订阅模式

通过发布订阅模式，对每个M层里的数据，都建立一个相应的发布依赖对象，每当有相应的变化的时候，就将变化发送给所有订阅方

而这里的订阅方，则是指所有会依赖到M层中某个数据的V层的视图和C层的控制器

## 占主导地位的C层
MVC架构中，最为重要的就是C层了，其决定了用户的键入会造成的改变，承担了架构中的大部分逻辑业务。

## 被动的M层
在MVC结构中，M层是不会主动地去向V层和C层发起信息的，一般都是通过另外两层的操作，引起M层的变化，M层才会以发布订阅的方式，将M层的改变发送给V层和C层。（一般都是以这种形式来引起V层视图的变化）

事实上，因为数据的变化来源于V层的触发或者用户键入到C层，所以有的时候，也会直接通过C层去引起V层的变化，而不需要去让M层通过发布订阅模式发布信息，直接由C层完全控制V层和M层的变化

## MVC的应用史
在过去，Web应用较为简单，前端/客户端和后端的代码都部署在同一台服务器上，对这一服务器的代码直接使用MVC架构，比如使用jsp的Java

而到了后来，Web应用渐渐变得复杂，前端/客户端和后端解耦，一般都会进行分开部署，而分开部署的各部分代码，也都遵循MVC架构或者MVC的变种架构

而前端/客户端和后端，通过网络的连接，形成了一个更大的MVC架构，前端/客户端的M层，实际上就是服务端M层在前端/客户端的一个存储，真正的M层存在服务端的M层，而相对的，真正的V层存在前端/客户端的V层，因为前端/客户端的视图才是用户真正能看到的

![MVC流程图](https://user-gold-cdn.xitu.io/2020/4/9/1715e0e3bebdd230?w=690&h=449&f=png&s=56847)


# MVP
MVP是MVC的一个变种，从名字上就可以看到，前两个是一样的，也就是说，在MVP中，M依然负责数据的提供，而V负责视图的显示

不一样的是P，但P又和C有些类似，P一样负责了逻辑的处理，不一样的是，所有的交互都发生在P中

在MVP中，与MVC不同的是，M和V被完全隔开了，他们之间的交互，需要通过P来实现

## 被动的V
在MVC中，只有M是被动的，V可以通过响应用户的行为，来触发M层中数据的改变，而在MVP中，V层在响应用户的行为时，自己并不会去处理这个响应，而是将这个响应交给P，而P在处理后，会根据V的接口去改变视图

而在页面一开始的时候，视图也是由P通过M的数据来初始化的，所以这里的V是被动的

通过让V层不依赖其他层，使得V层变成可测试的

## 通信方式
![MVP流程图](https://user-gold-cdn.xitu.io/2020/4/9/1715e0d6dd03f7bc?w=875&h=477&f=png&s=73212)
1. 当视图接收到来自用户的事件时，会将事件转交给 Presenter 进行处理；
2. 被动的视图向外界暴露接口，当需要更新视图时 Presenter 通过视图暴露的接口更新视图的内容；
3. Presenter 负责对模型进行操作和更新，在需要时取出其中存储的信息；
4. 当模型层改变时，可以将改变的信息发送给观察者 Presenter；

# MVVM
MVVM是PM（Presentation Model）模式的一种实现，所以在谈及MVVM之前，我们要说说PM模式是什么

## PM模式
PM 模式将视图中的全部状态和行为放到一个单独的展示模型中，协调领域对象（模型）并且为视图层提供一个接口。展示模型是视图的一个抽象

在监督控制器中，视图层与模型层中的一些简单属性进行绑定，在模型属性变化时直接更新视图，也就是说，通过让展示模型将数据与业务逻辑处理为简单的数据与属性暴露给视图，让视图和展示模型中的属性进行同步

![](https://user-gold-cdn.xitu.io/2020/4/9/1715e25e4e51b708?w=893&h=450&f=png&s=65169)

## 状态的同步
因为展示模型是视图的抽象，其中包含了视图的状态（属性）和行为（动作），视图的行为可能很少发生改变，但是视图状态的改变就是非常常见的了，那么同步视图和展示模型的代码应该放哪里就是一个需要考虑的问题了。

到目前为止，我们能够放置状态同步代码的地方其实只有两个，也就是视图和展示模型；如果将同步的代码放在视图中，那么可能会影响视图的测试，不过由于现在的大部分客户端程序完全没有测试，这一点其实也影响不大；如果将代码放在展示模型中，实际上就为展示模型增加了视图的依赖，导致不同层级之间的耦合。

## 展示模型与其他模块的关系
在 PM 模式中，同一个展示模型可以与多个领域对象交互，多个视图可以使用相同的展示模型，但是每一个视图只能持有一个展示模型。

![](https://user-gold-cdn.xitu.io/2020/4/9/1715e7141dc89405?w=824&h=488&f=png&s=79140)

## MVVM与PM模式
说回MVVM，MVVM包含了M，V，VM，而实际上，VM就是PM模式中的展示模型，这里我们称为视图模型

除了这三个部分之外，MVVM中还有一个隐式的binder层，声明式的数据和命令的绑定就是通过它完成的

![](https://user-gold-cdn.xitu.io/2020/4/9/1715e7a71f1d74eb?w=781&h=238&f=png&s=39167)

无论是 MVVM 还是 Presentation Model，其中最重要的不是如何同步视图和展示模型/视图模型之间的状态，是使用观察者模式、双向绑定还是其它的机制都不是整个模式中最重要的部分，最为关键的是展示模型/视图模型创建了一个视图的抽象，将视图中的状态和行为抽离出一个新的抽象，这才是 MVVM 和 PM 中需要注意的。



## 总结区别
我们知道，其实三者的区别就在于C，P，VM，MV是一样的，分别为模型和视图

三者具体表现的区别在于

在C中，用户的输入会输入到V或者C，输入到C时，C会将数据传给V，而这导致C非常薄，只起到路由的作用，而 View 非常厚，业务逻辑都部署在 View

相对来说，因为MVP中，V和M没有数据交互，所以用户只能将数据传入P，由P来处理业务逻辑，所以V层非常薄，没有业务逻辑

而MVVM相对于MVP来说，唯一的变化在于，VM与V是采用了双向绑定的，View的变动会自动反映到VM中，反之亦然