# 前端
在file的onchange传入的方法中，```e.target.files[0]```就是我们选中的文件，我们可以通过```const [file] = e.target.files```来获得这个文件的信息，而```file.size```就是文件的大小

生成对应的hash，只做图片的分片上传也可以简单通过文件名+排序来当做hash，但我们也可以通过一些包来生成hash

计算hash的时间可能比较久，所以我们可以将其放在**web worker**里面计算

在计算完毕后，要手动关闭web worker线程

将上传状态改为**uploading**

在正式上传前，我们要发起一个请求，查看当前的hash对应的文件是否已经被上传过了，如果被上传过了，则不再发起请求

依次上传切片，判断上传状态，如果上传状态为**uploading**，则上传文件，使用formData进行上传

在发起请求时，将每个切片的请求放入一个数组中，发起请求，每个请求对应的会有一个顺序属性，在后面缺少对应切片时，直接找到这个切片重新发起请求

在显示进度时，每上传一个切片，就添加一个切片大小占整个文件大小的百分比，比如我们将一个10M的文件切分成十个，每上传一个，就添加10%，这样就可以做一个进度条的展示

暂停时，将上传状态改为**pause**，并执行xhr的**abort**方法，将请求停止


# 服务端
在上传文件时，会在上传文件出创建一个文件夹，对应于这个文件的hash

将这个文件对应的分片存储在这个文件夹下，当接收到合并请求时，就将这几个分片合并，并删除这个文件夹

根据传送过来的排序合并切片，先取得文件名和文件后缀名，创建该文件，再使用
```javascript
const fse = require("fs-extra");
fse.createWriteStream()
```
将切片内容写入该文件，传入文件的路径和开始写的位置

在写的时候缺少某个切片时，返回缺少切片对应的顺序，前端在接收到合并文件的响应后，如果里面有缺少切片的顺序，在请求列表中找到对应的切片，500ms后重新发起请求，若无法找到所有缺乏的切片，则告知用户上传失败

在这个过程中，如果能找到所有缺少的切片，那么除了重新上传这些切片对应的请求外，还将不缺乏的数组里的其他请求去掉，减少后面的遍历过程

在遍历过程中，采用**二分法**来找到缺乏的请求