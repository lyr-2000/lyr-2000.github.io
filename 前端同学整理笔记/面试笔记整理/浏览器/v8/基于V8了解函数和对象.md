我们知道，V8是Chrome用来编译执行JavaScript的JavaScript引擎，所以如果我们要了解JavaScript，那么结合V8能让我们更好地理解，这篇博客将结合V8，来谈谈JavaScript中的对象和函数

# 对象
## 什么是JavaScript的对象
什么是JavaScript的对象， JavaScript中的对象，并不是单单指Object，JavaScript这门语言本身，是**基于对象**的，可以说，JavaScript里面的大部分内容，都是由对象构成的。比如函数，数组，这些都是由对象构成的，甚至一些基本类型还有相关的内置对象诸如Number，String，Boolean

对象在运行时可以被动态修改属性的特点，让JavaScript变得十分灵活，但同时，也带来了一些难以理解的问题。

JavaScript对象可以说简单，也可以说复杂。简单来收，它不过是存储了一些属性，和这些属性对应的值而已，是一种key-value的结构。

而说它复杂，确实因为它的属性的值可以为任意类型。这也是它做为弱类型语言的特性，像Java，对象的每个属性对应的类型是确定的，而JavaScript并不。由于可以为任意类型，所以我们可以为一个属性，赋值为基本类型如Number、String、Boolean、null、undefiend等，也可以给它一个数组，一个普通对象，或者一个函数，使这个属性变成一个方法。这也可以看成，对象的属性的值可以有三种类型
* 基本类型
* 普通对象
* 函数


此外，我们要明白的是，JavaScript虽然是基于对象的，但却不是面向对象的，学过Java的同学应该知道，面向对象三大特点，封装、继承、多态，而JavaScript里面并没有多态的实现。

除了多态没有实现外，继承上也与其他语言存在区别，JavaScript采用原型来实现继承，而原型在JavaScript中只是添加了一个属性，所以我们先来聊聊V8的对象属性存储策略。

## V8的对象属性存储策略
我们所看到的对象属性存储，看起来像是字典的存储，哪个先存进去，遍历的时候就先存储哪个，但实际上，JavaScript的对象的属性存储并非完全如此，

一般情况下，属性确实是按存储进去的顺序，但是如果属性的名字是数值的话，那会按数值的形式存储
```javascript
function Obj(){
    this[100] = 't100'
    this[50] = 't50'
    this.a = 'ta'
    this[20] = 't20'
    this.c = 'tc'
    this[25] = 't25'
    this[1] = 't1'
    this.b = 'tb'
}
let obj = new Obj()
for(let k in obj){
    console.log(k)
}
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200513123744839.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3plbXByb2dyYW0=,size_16,color_FFFFFF,t_70)
可以看到，打印结果里面，数字是按数字的顺序打印出来，而a、b、c是按我们写入的顺序打印出来的

直接在控制台查看obj对象也能看出顺序
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200513123910607.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3plbXByb2dyYW0=,size_16,color_FFFFFF,t_70)

之所以出现这样的结果，是因为在**ECMAScript规范**中定义了数字属性应该按照索引值大小升序排列，字符串属性根据创建时的顺序升序排列。

我们把按索引值大小排列的属性称为elements属性，而根据创建时的顺序排列的属性称为property属性。（这是按照Chrome浏览器控制台里Memory快照的属性名称取的）

因为elements属性是按索引顺序排序，所以删除和添加一个elements属性，都会引起一次属性排序，而property属性并不会。在V8中，为了能提升存储和访问这些属性的性能，对这两种属性采用了两种不同的线性结构来存储。

在遍历一个对象属性时，如上面我们打印的一样，V8会先去到elements属性中，根据索引遍历所有的elements属性，然后再去遍历property属性

使用两种线性结构来存储，解决了两种属性不同处理的问题，但在我们访问对象属性的时候，需要先判断这个属性的键是什么类型的，然后再根据类型，去到不同的结构中查找，增加了我们访问属性的时间

我们可以来看看Memory中的快照
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200513130621762.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3plbXByb2dyYW0=,size_16,color_FFFFFF,t_70)   

我们可以看到，这里有elements属性，里面就是我们用索引排序的属性，但是，没有看到property属性，这和V8的权衡机制有关。

我们上面也提到了，使用两种线性结构，然后根据属性键值来遍历不同的属性，会降低访问效率，V8对此做了一定的权衡。当property属性不超过10个的时候，就直接将属性放在对象上，而不放到property属性上。

我们试试超过十个的property属性
```javascript
function Obj(pNum,eNum) {
    for (let i = 0; i < pNum; i++) {
        let pKey = `property${i}`
        this[pKey] = `property${i}`
    }
    for (let i = 0; i < eNum; i++) {
        this[i] = `element${i}`
    }
}

obj = new Obj(11,10)
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200513160852246.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3plbXByb2dyYW0=,size_16,color_FFFFFF,t_70)
可以看到，多了个properties属性，里面有个property10

我们将直接存储在对象上的property属性称为对象内属性，而在properties属性上的property属性有快属性和慢属性两种。

对象内属性的访问是最快的，因为直接在对象上，而在properties属性上的属性，因为多了一次寻址，所以会比对象内属性慢，但是在properties属性上，其实还有细分。

快属性采用线性结构来存储，我们只需要通过索引就能访问到属性的值，但同时，带来的问题是如果我们插入和删除大量属性时，执行效率会变低。

所以当我们一个对象的属性多了的话，就会变成慢属性了。慢属性也是在properties上，但是它采用非线性的结构来存储属性值的。所以在插入删除时执行效率不会和线性结构一样，需要做大量的移动。
```javascript
obj = new Obj(100,10)
```
看看创建了100个property属性的对象后内存快照
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200515152453822.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3plbXByb2dyYW0=,size_16,color_FFFFFF,t_70)
可以看到，内存中properties属性里面的属性已经是完全无序的，这表明这些属性采用了慢属性的存储方式


### 隐藏类
在上面的内存快照中，我们可以看到一个map属性，这个属性存放了描述命名属性，也就是隐藏类。隐藏类可以看成是一个描述对象结构的对象。

为什么要引入隐藏类，这是为了让JavaScript更快。我们知道，JavaScript是一门动态语言，其运行开发者随时修改对象的属性和值，这种方式带来了灵活的同时，却让JavaScript对属性的访问变慢了。像Java这样的静态语言，因为类型一旦创建不可变，所以可以通过固定的偏移值对对象的属性进行访问，因此比动态语言快，而隐藏类借鉴了部分静态语言的特性。

V8采用的思路是，将JavaScript的对象静态化，即假设JavaScript的对象在创建之后就不会添加新的属性，也不会删除现有的属性。（实际上是会的）

V8为每一个JavaScript对象创建它自己的隐藏类，存放在map中，然后当我们去寻找一个对象的属性时，如果这个属性在map中有记录，那么我们去到map中，找到这个属性相对于对象的偏移值，在对象的地址上加上偏移值就可以找到这个属性了，这样比起上面的查找会更快。

而当我们创建了两个**形状**一样的对象时，即对象的属性个数一样且名称一样，那么这两个对象会共用一个隐藏类
```javascript
function Person(name,age){
    this.name = name
    this.age = age
}
var Bob = new Person('Bob',18)
var Mike = new Person('Mike',20)
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200515160713591.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3plbXByb2dyYW0=,size_16,color_FFFFFF,t_70)
可以看到上图中，两个对象的map隐藏类是一样的，即使我们不采用构造函数来创建对象，也是一样的

这么做，给我们访问对象又带来了一次提速，但是要记住，我们是有假设的，这样做的前提是对象不会增加属性，也不会删除属性，但实际上，这个假设是不成立的，那么也就是说，对于JavaScript来说，对象结构是会变的，那么隐藏类也就会发生改变。

我们可以修改上面的Mike对象，为其添加一个属性
```javascript
Mike.work = 'coding'
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200515161144539.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3plbXByb2dyYW0=,size_16,color_FFFFFF,t_70)
可以从内存快照中看到，Mike的map隐藏类地址发生了改变，也就是说隐藏类发生了改变，符合了我们刚才说的结构改变隐藏类随之改变，这对于V8的执行效率来说，是一笔大的开销。

为了避免这种问题，我们可以在编写代码时注意一些优化细节

1. 字面量声明对象时顺序一致
两个对象的属性顺序不同也会创建不同的隐藏类，所以自己在使用字面量创建对象时，尽量顺序一致，减少创建隐藏类时间和隐藏类个数，像下面这两个对象
```javascript
var p1 = { x:10,y:20 }
var p2 = { y:20,x:10 }
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/2020051516201413.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3plbXByb2dyYW0=,size_16,color_FFFFFF,t_70)
可以看到属性一样，却因为顺序不一样导致了隐藏类不同。

2. 尽量使用使用字面量一次性写入所有的属性，一个个添加属性会导致多次创建隐藏类

3. 减少使用delete，通过delete来删除对象属性，也会造成隐藏类的重新创建

虽然经过隐藏类的引入，我们访问对象属性的速度加快了，但还是有一些问题需要考虑，看看下面的代码
```javascript
var Mike = {
    name:'Mike',
    age:18
}
function getAge(p){
    return p.age
}
for(let i = 0 ; i < 100 ; i++){
    getAge(Mike)
}
```
在上面的代码中，我们getAge去获取Mike的age属性的时候，通过map隐藏类，使用偏移值得到了对象的age属性值，但是这实际上，我们还是需要三步，去到对象的map属性，然后再找到偏移值，计算对象的地址和偏移值相加的值，才能找到age属性值，但实际上，我们一直在找一个相同的值，有什么方法可以优化这种寻找吗

### 内联缓存
上面的问题，V8采用了内联缓存(IC：Inline Cache)来处理。

知道怎么处理之前，我们先要知道IC的原理。简单来说，V8通过在JavaScript执行过程中观察一些调用点的关键数据，然后将这些关键数据存储起来，当再次调用这个函数时，就会去直接使用这些关键数据，节省了再次获取的时间。那么，V8是如何观察调用点的，又是如何存储关键数据，存储在哪的

首先，V8会为每个函数维护一个反馈向量（FeedBack Vector），记录函数在执行过程中的一些关键的中间数据，反馈向量实际上就是一个表，表中的每一项都是一个slot插槽，每个关键数据对应一个slot。每个插槽中包括了插槽的索引(slot index)、插槽的类型(type)、插槽的状态(state)、隐藏类(map)的地址、还有属性的偏移量

IC会存储三种插槽类型：存储类型、调用类型、加载类型，对应着数据的存储，函数的调用和对象属性的加载

看下面这段代码
```javascript
function foo(){}
function loadX(o) { 
    o.y = 4
    foo()
    return o.x
}
loadX({x:1,y:4})
``` 
* 当我们执行loadX的时候，就会为其生成一个反馈向量
* 执行到o.y时，就会创建一个存储类型的插槽，将操作结果放入插槽中，然后插入到反馈向量
* 执行foo()时，首先要找到foo的地址，所以要创建一个加载类型的插槽，存储foo的地址，插入到反馈向量中，然后执行方法，创建一个调用类型的插槽，将调用结果放入插槽中，最后将这个插槽插入到反馈向量中
* ```return o.x```，获取到o.x的值，创建一个加载类型的插槽，存储o.x的值，插入到反馈向量中

之后我们再次调用这个函数时，只需要从反馈向量里面找到对应的插槽，就可以完成操作了

然而，这种性能提升的方式，局限于函数内部执行的内容是相同的，如果不相同，又会产生新的问题，看看下面这段代码
```javascript
function loadX(o) { 
    return o.x
}
var o = { x: 1,y:3}
var o1 = { x: 3, y:6,z:4}
for (var i = 0; i < 90000; i++) {
    loadX(o)
    loadX(o1)
}
```
我们可以看到，对象o和对象o1这两个对象的结构是不同的，也就是说，V8为它们创建的隐藏类也是不同的。

而在我们第一次调用loadX的时候，V8会将对象o的隐藏类和属性偏移值记录到反馈向量里面，但是当我们再次调用loadX的时候，V8会发现o1的结构和反馈向量里记录的隐藏类是不同的，所以这次无法使用反馈向量里面的缓存。

遇到这种情况时，V8会选择将同一个调用点的数据，存储在反馈向量里的同一个插槽里面，这样子，当这个函数再次被调用的时候，V8需要先去比对，插槽里记录的隐藏类，哪个和我当前传入的对象隐藏类相同，发现哪一个相同，就去使用哪一个记录，如果没有相同，则为这个插槽加入新的值。

现在我们知道了，一个反馈向量的一个插槽中可以包含多个隐藏类的信息，那么：

* 如果一个插槽中只包含1个隐藏类，那么我们称这种状态为单态(monomorphic)；
* 如果一个插槽中包含了2～4个隐藏类，那我们称这种状态为多态(polymorphic)；
* 如果一个插槽中超过4个隐藏类，那我们称这种状态为超态(magamorphic)。

因此，我们需要尽可能地保持单态，避免多态和超态

## 原型链
聊完对象是怎么存储属性的，接下来我们可以聊聊JavaScript里面重要的继承机制，基于原型链的继承。

原型链是JavaScript重要的基础，也是面试里经常谈及的问题。这里我们谈谈V8里面是怎么去通过原型链实现继承的。

### 继承
首先，什么是继承，简单地说，我们通过让一个对象A继承另一个对象B，那么A可以直接调用B的方法，这就是继承。

继承的实现一般有两种，一种是基于类的继承，一种是基于原型的继承。

我们常看到的Java，C都是基于类的继承，这种继承方式的特点就是，我们能看到一些和继承相关的关键字，诸如public、private、protected、interface、class等，我们通过这些关键字，来实现类的声明和类的继承，同时限定类的访问。

而JavaScript使用的，是基于原型的继承，虽然JavaScript在ES6中出现了class，但它实际上只是一个语法糖而已，它的本质仍是基于原型的继承。JavaScript的原型继承，也只是通过引入了一个指向原型的属性而已。

### 如何实现原型继承
JavaScript的原型继承，通过引入了一个指向原型对象的隐藏属性__proto__，我们可以直接在console看到，也可以通过Memory快照看到对象的这个隐藏属性。

而JavaScript的原型继承，就是通过这个原型指向去寻找属性和方法，如果现在继承是C->B->A（C继承B，B继承A）。那么当我们去调用C的方法或者去访问C的属性，V8首先会在C这个对象上，寻找对应的属性方法，找不到的话，就沿着原型链的指向，去到对象B上找，如果还找不到，就继续沿着原型链，去A对象上找，如果还找不到，就看A是否原型链还有指向的对象，如果没有，返回undefined，如果是方法，此时执行就会报错。

综上，原型继承其实挺简单的，就是沿着原型链寻找而已，但是JavaScript实现继承的方式还有挺多的，在红宝书（《JavaScript高级程序设计》）里面，就说到了6种继承的方式，如果你看过红宝书，应该有印象，如果你没看过，建议你去看看，虽然书名高级，但在我看来只是本比较广泛的基础书籍而已，总的来说还是很有用的。


# 函数
## 什么是函数
上面也提到了，在JavaScript中，函数其实也是一个对象，所以函数也可以有自己的属性和值，它与对象不同的地方在于，它可以被执行，执行时会创建函数作用域。

## V8如何去执行函数
我们知道，在执行函数的时候，我们只需要在函数名后面，加上一个括号，在括号里传入参数，就可以执行这个函数了，但是，V8是怎么做到执行这个函数的，V8如何找到这个函数的相关代码

既然函数是一个对象，那么它就有自己的属性，除了我们给它添加的属性，函数本身有两个属性，分别是name和code。

name属性存储着函数的名字，而code以字符串的形式存储函数

就像下面的代码
```javascript
function fn(){
    // ...
}

console.log(fn.name)
// fn
```
当我们执行代码的时候，V8会去找到这个函数对应的code属性，然后解释执行code属性的值，也就是原函数。

## 使用栈结构来管理函数调用
我们要知道，V8是使用栈结构来管理函数调用的，所以我们经常可以听到函数调用栈，但为什么使用栈结构来管理函数调用呢？

除了栈结构本身的特点：空间连续和先进后出外，也与函数本身有关。

首先，函数是可以被调用的，我们可以在一个函数里面去调用另外一个函数，当我们调用一个函数的时候，代码执行的控制权将由父函数或者全局作用域转移到子函数，而当函数调用完毕后，会返回给父函数或者全局，这与栈结构的先进后出刚好吻合。  
其次，函数具有作用域机制，函数内部的变量，被我们称为局部变量，只要我们不暴露出去，就只能在函数内部被访问到，即使返回，也只是返回一个值或者一个对象的地址，所以一般情况下，当我们一个函数调用完毕时，函数内部的局部变量都该被销毁，而通过使用栈结构，当函数执行完毕出栈时，空间里对应的变量也被清除。

## 函数是一等公民
什么是一等公民，对一种语言来说，如果它的函数和它的基本类型能完成一样的事情，比如可以赋值给变量，可以做为函数的参数，可以做为函数的返回值，可以做为对象的属性值等，那么就说这种语言的函数是一等公民。

函数成为一等公民，让我们可以方便地去传递函数，但也正是因为函数是一等公民，带来了一些麻烦。当我们在函数内部去引用外部变量的时候，V8需要去判断，这个外部变量是否真的存在，闭包就是一个典型的例子。如下面的代码
```javascript
function fn(){
    let count = 0
    function add(){
        count++
        console.log(count)
    }
    return add
}
let a = fn()
a()
```
这里fn内部声明了一个函数add，而这个add函数，调用了它所在的函数作用域里的count变量，所以即使fn已经调用完了，因为add函数内部用到了fn函数作用域里的变量，所以V8不得不去维护这个作用域，不能去销毁这个作用域，这就是函数做为一等公民带来的麻烦。

## V8如何去处理闭包
首先，我们说说闭包，为什么JavaScript会有闭包，有以下三点
1. JavaScript运行在函数内部定义新的函数
2. 可以在内部函数访问父函数中定义的变量
3. 函数是一等公民，可以做为函数的返回值

再有一个，我们要明白，JavaScript出于加快初次解析和减少内存浪费的目的，采用了惰性解析：当解析代码的时候，对函数声明只转换成对用的对象，而不解析函数内部的内容，

我们可以看看下面这个闭包
```javascript
function fn(){
    var fnNum = 1
    return function inner(){
        var innerNum = 2
        return fnNum+innerNum
    }
}
var f = fn()
```
在这里，inner就是一个典型的闭包，这个闭包带来了一定的问题。当我们调用fn函数时，它会将里面的函数inner返回给变量f，然后当函数执行完毕的时候，fn的执行上下文会被V8销毁，但是，我们可以看到，闭包inner调用了fn内的变量fnNum，这导致了fnNum不能被销毁，但是这样就带来问题了。

我们知道，这段代码是可以实现的，而且执行```f()```的时候，会返回3，那就意味着fnNum没用被销毁，那么我们怎么做到它不被销毁，同时，上面提到了，V8采用了惰性解析，既然采用了惰性解析，那也就意味着，当我们执行```fn()```之前，我们是不会去解析inner函数内部的代码的，那我们又怎么知道，fnNum被inner函数使用了呢。

要解决这个问题，我们就需要去判断函数内部是否会用到父函数的变量，V8引入了预解析器去执行这个任务。

引入预解析器后，V8遇到一个函数时，不会直接跳过该函数，而是会对该函数进行以此快速的预解析，预解析有两个工作

1. 判断当前函数是否存在语法错误  
如果这个函数出现了语法错误，那也没必要继续执行下去了
2. 检查函数内部是否引用了外部变量，如果引用了外部变量，预解析器就会将栈中的变量复制到堆中，当下次执行到该函数的时候，直接使用堆中的引用，以此解决闭包的问题。

## 函数表达式
函数表达式是JavaScript中非常重要的基础内容，我们可以使用函数表达式来执行一个函数，同时又不会把实现的逻辑代码暴露出来。

函数表达式说简单，看起来不难，但实际上，还是涉及到挺多东西的。它涉及到一些底层概念，什么是语句，什么是表达式，函数即对象的概念。我们要清楚这些概念，才能更好地去理解函数表达式。

### 函数声明和函数表达式
我们知道，在JavaScript里面，一般情况下，我们可以有两种方式去声明一个函数
```javascript
// 函数声明
function fn(){
    // ...
}
// 函数表达式
var fn = function(){
    // ...
}
```
上面的两行代码，虽然最终都会得到一个函数fn，但是还是存在不同的。

哪里不同，其实从名字就能看出来了，函数声明和函数表达式，既然有声明，那就可能会涉及到JavaScript非人的设计，变量提升。V8在执行JavaScript代码的时候，会先创建全局作用域，然后对代码进行编译，而在编译期间，会把声明内容放到全局作用域中，像下面的这段代码
```javascript
fn()
function fn(){
    console.log('fn')
}
```
V8处理时会变为
```javascript
// 编译阶段
function fn(){
    console.log('fn')
}

// 执行阶段
fn()
```
而对于函数表达式，如下代码
```javascript
fn()
var fn = function(){
    console.log('fn')
}
```
V8处理时会是
```javascript
// 编译阶段
var fn = undefined

// 执行阶段
fn()
fn = function(){
    console.log('fn')
}
```
所以这段代码会报错，因为在fn执行的时候，fn还不是方法。

实际上，这就涉及到了表达式和语句的区别了，表达式在编译阶段是不会执行的。

我们可以简单地区分，表达式，是JavaScript中的一个短语，JavaScript编译执行它会返回一个结果，而语句，是一个完整的句子，它可以单独执行。就像下面的函数表达式
```javascript
(function(){
    //...
})()
```
我们如果不加括号，那么```function(){}```是会报错的，因为编译器看到开头是function，将其看做一个函数声明语句，而函数声明语句function后面要加函数名，但是，放到括号里后，它就被看成一个表达式了，这个括号内通过JavaScript编译器“计算”得到一个函数，然后使用()调用。

我们能看到，函数表达式和函数声明的在创建一个函数时的区别，函数声明可以让声明的函数在编译阶段就放到作用域中，也即是说可以在声明前就调用这个方法了，而函数表达式，可以做为一个匿名函数使用，可以不污染环境。

像上面举例用的的函数表达式
```javascript
(function(){
    //...
})()
```
这是一个立即执行的函数表达式（IIFE），使用这样的函数调用可以让我们不用去污染环境变量。

## V8实现回调函数
回调函数，说到底只是一个函数而已，我们可以在很多个场景见到回调函数，一个简单的定时器setTimeout或者setInterval，一个ajax异步回调，又或者一个forEach方法的回调函数参数，甚至于回调函数的滥用，让我们听到了回调地狱。

具体来说，就我们上面举到的例子其实可以看到了，回调函数分为同步回调和异步回调，同步回调是直接在执行函数内部执行的，而异步回调函数，往往会在另一个任务里面执行，像定时器，或者是ajax异步回调，它们的回调函数和本身所在的函数执行，是在两个宏任务的

对于同步回调函数，我们很容易理解，它在函数内部执行完后就执行，但是异步回调可能就不是很好理解了，这涉及到V8的事件循环机制和消息队列等。而这些又与V8的线程模型相关，所以我们要先分析一下V8的线程模型

### 线程架构
首先我们要明白的是，JavaScript在浏览器中，是在UI线程里面执行的，这与早期浏览器只有UI线程有关。

所谓UI线程，是指运行窗口的线程，当你运行一个窗口时，无论该页面是Windows上的窗口系统，还是Android或者iOS上的窗口系统，它们都需要处理各种事件，诸如有触发绘制页面的事件，有鼠标点击、拖拽、放大缩小的事件，有资源下载、文件读写的事件，等等。

我们知道，上面说到的事件，往往会在同一段时间内发生，可能上一个事件没有处理完，下一个事件就来了，我们要如何控制这些事件的执行，才能保证CPU正常运行和事件有序执行。

针对这种情况，浏览器实现了一个消息队列，每当我们产生一个事件的时候，浏览器就将这个事件推入到队列中，然后依次把事件从队列中推出，因为队列的特点是先进先出，所以事件的执行，是按照事件触发的顺序，我们把UI线程每次从消息队列中取出事件，执行事件的过程称为一个任务。

### 异步回调函数的调用时机
对于定时器来说，会有另一个队列来存放定时器里面的回调函数，当我们执行一个定时器时，会将这个回调函数推入这个队列，然后又一个任务调度器来控制，当时间到了的时候，任务调度器就会将这个回调函数从队列中取出，压入到上面说的消息队列里面。

而对于像XHR这种和网络相关的异步回调，又存在了不同的处理。因为我们的XHR请求会去请求服务端的资源，而这个资源请求花费的时间，相对于我们一个普通的事件来说是很长的，如果只是获取一些数据还好，如果是下载一整个文件，那时间就不是以ms为单位了，甚至会以h为单位了。

而就像上面说的，JavaScript运行在UI线程上，如果我们在这里还是由UI线程来处理这个请求事件的话，那无疑会对页面造成严重的阻塞，为了解决这个问题，浏览器借助了网络线程的力量，由网络线程来处理数据的获取

当我们在UI线程，也就是JavaScript发起一个XHR任务时
* V8会分析出这是一个下载任务，主线程会将该任务交给网络线程去执行
* 网络线程接到任务后，会和服务端建立连接，并不断接受服务端发来的数据
* 网络线程在接受数据的过程中，每接收一次数据，都会将此次接收数据的大小，字节，存放在内存中的位置，封装在一个事件里压入消息队列中
* UI线程不间断地执行消息队列里的任务，当发现下载事件的任务状态变为完成时，就将回调函数压入消息队列中
* 回调函数前面的任务都被执行完，回调函数出队列，被执行，UI线程回调显示数据获取完成