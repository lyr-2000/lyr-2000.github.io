# 模块化

### 模块化进程

1. 全局function：将不同的功能封装成全局函数

   缺点

   - 容易污染全局命名空间或造成命名冲突
   - 模块成员看不出直接的关系

2. namespace模式

   缺点

   - 数据不安全，可以在外部修改数据

3. 匿名函数IIFE

   通过window来向外暴露接口

### 为什么需要模块化

模块化的好处

1. 避免命名冲突
2. 提高复用性和维护性
3. 更好的分离，按需加载

## 模块化规范

### 1.CommonJS

在**Node**应用模块中采用的是CommonJS模块规范，每一个文件都是一个模块，有自己的作用域

**在服务器端，模块的加载是在运行时同步加载的；在浏览器端，模块需要提前编译和打包**

（1）特点

- 所有代码运行在模块内部，不会污染全局作用域
- 加载顺序取决于在代码中出现的顺序
- 模块可以多次加载，但是只会运行一次

（2）语法

- 暴露模块：`module.exports = value`或`exports.xxx = value`
- 引入模块：
  - 如果是第三方模块：`require(模块名)`
  - 如果引用自己写的模块：`require(路径名)`

### 2.AMD

CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是，**如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范**。此外AMD规范比CommonJS规范在浏览器端实现要来着早。

### CMD

CMD专门用于浏览器，模块加载是**异步**的，模块使用时才会加载执行

CMD规范整合了CommonJS和AMD规范的特点。在 Sea.js 中，所有 JavaScript 模块都遵循 CMD模块定义规范。

### ES6模块化



